
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectMember
 * 
 */
export type ProjectMember = $Result.DefaultSelection<Prisma.$ProjectMemberPayload>
/**
 * Model TestSuites
 * 
 */
export type TestSuites = $Result.DefaultSelection<Prisma.$TestSuitesPayload>
/**
 * Model ProjectVariable
 * 
 */
export type ProjectVariable = $Result.DefaultSelection<Prisma.$ProjectVariablePayload>
/**
 * Model TestSuiteVariable
 * 
 */
export type TestSuiteVariable = $Result.DefaultSelection<Prisma.$TestSuiteVariablePayload>
/**
 * Model ProjectFunction
 * 
 */
export type ProjectFunction = $Result.DefaultSelection<Prisma.$ProjectFunctionPayload>
/**
 * Model TestSuiteFunction
 * 
 */
export type TestSuiteFunction = $Result.DefaultSelection<Prisma.$TestSuiteFunctionPayload>
/**
 * Model Page
 * 
 */
export type Page = $Result.DefaultSelection<Prisma.$PagePayload>
/**
 * Model PageElement
 * 
 */
export type PageElement = $Result.DefaultSelection<Prisma.$PageElementPayload>
/**
 * Model TestCase
 * 
 */
export type TestCase = $Result.DefaultSelection<Prisma.$TestCasePayload>
/**
 * Model ProjectInvitation
 * 
 */
export type ProjectInvitation = $Result.DefaultSelection<Prisma.$ProjectInvitationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ProjectInvitationStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  DECLINED: 'DECLINED',
  EXPIRED: 'EXPIRED'
};

export type ProjectInvitationStatus = (typeof ProjectInvitationStatus)[keyof typeof ProjectInvitationStatus]

}

export type ProjectInvitationStatus = $Enums.ProjectInvitationStatus

export const ProjectInvitationStatus: typeof $Enums.ProjectInvitationStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectMember`: Exposes CRUD operations for the **ProjectMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectMembers
    * const projectMembers = await prisma.projectMember.findMany()
    * ```
    */
  get projectMember(): Prisma.ProjectMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testSuites`: Exposes CRUD operations for the **TestSuites** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestSuites
    * const testSuites = await prisma.testSuites.findMany()
    * ```
    */
  get testSuites(): Prisma.TestSuitesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectVariable`: Exposes CRUD operations for the **ProjectVariable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectVariables
    * const projectVariables = await prisma.projectVariable.findMany()
    * ```
    */
  get projectVariable(): Prisma.ProjectVariableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testSuiteVariable`: Exposes CRUD operations for the **TestSuiteVariable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestSuiteVariables
    * const testSuiteVariables = await prisma.testSuiteVariable.findMany()
    * ```
    */
  get testSuiteVariable(): Prisma.TestSuiteVariableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectFunction`: Exposes CRUD operations for the **ProjectFunction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectFunctions
    * const projectFunctions = await prisma.projectFunction.findMany()
    * ```
    */
  get projectFunction(): Prisma.ProjectFunctionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testSuiteFunction`: Exposes CRUD operations for the **TestSuiteFunction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestSuiteFunctions
    * const testSuiteFunctions = await prisma.testSuiteFunction.findMany()
    * ```
    */
  get testSuiteFunction(): Prisma.TestSuiteFunctionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.page`: Exposes CRUD operations for the **Page** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pages
    * const pages = await prisma.page.findMany()
    * ```
    */
  get page(): Prisma.PageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pageElement`: Exposes CRUD operations for the **PageElement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PageElements
    * const pageElements = await prisma.pageElement.findMany()
    * ```
    */
  get pageElement(): Prisma.PageElementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testCase`: Exposes CRUD operations for the **TestCase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestCases
    * const testCases = await prisma.testCase.findMany()
    * ```
    */
  get testCase(): Prisma.TestCaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectInvitation`: Exposes CRUD operations for the **ProjectInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectInvitations
    * const projectInvitations = await prisma.projectInvitation.findMany()
    * ```
    */
  get projectInvitation(): Prisma.ProjectInvitationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification',
    Project: 'Project',
    ProjectMember: 'ProjectMember',
    TestSuites: 'TestSuites',
    ProjectVariable: 'ProjectVariable',
    TestSuiteVariable: 'TestSuiteVariable',
    ProjectFunction: 'ProjectFunction',
    TestSuiteFunction: 'TestSuiteFunction',
    Page: 'Page',
    PageElement: 'PageElement',
    TestCase: 'TestCase',
    ProjectInvitation: 'ProjectInvitation'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "account" | "verification" | "project" | "projectMember" | "testSuites" | "projectVariable" | "testSuiteVariable" | "projectFunction" | "testSuiteFunction" | "page" | "pageElement" | "testCase" | "projectInvitation"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectMember: {
        payload: Prisma.$ProjectMemberPayload<ExtArgs>
        fields: Prisma.ProjectMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findFirst: {
            args: Prisma.ProjectMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findMany: {
            args: Prisma.ProjectMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          create: {
            args: Prisma.ProjectMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          createMany: {
            args: Prisma.ProjectMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          delete: {
            args: Prisma.ProjectMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          update: {
            args: Prisma.ProjectMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          deleteMany: {
            args: Prisma.ProjectMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          upsert: {
            args: Prisma.ProjectMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          aggregate: {
            args: Prisma.ProjectMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectMember>
          }
          groupBy: {
            args: Prisma.ProjectMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberCountAggregateOutputType> | number
          }
        }
      }
      TestSuites: {
        payload: Prisma.$TestSuitesPayload<ExtArgs>
        fields: Prisma.TestSuitesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestSuitesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuitesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestSuitesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuitesPayload>
          }
          findFirst: {
            args: Prisma.TestSuitesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuitesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestSuitesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuitesPayload>
          }
          findMany: {
            args: Prisma.TestSuitesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuitesPayload>[]
          }
          create: {
            args: Prisma.TestSuitesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuitesPayload>
          }
          createMany: {
            args: Prisma.TestSuitesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestSuitesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuitesPayload>[]
          }
          delete: {
            args: Prisma.TestSuitesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuitesPayload>
          }
          update: {
            args: Prisma.TestSuitesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuitesPayload>
          }
          deleteMany: {
            args: Prisma.TestSuitesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestSuitesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestSuitesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuitesPayload>[]
          }
          upsert: {
            args: Prisma.TestSuitesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuitesPayload>
          }
          aggregate: {
            args: Prisma.TestSuitesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestSuites>
          }
          groupBy: {
            args: Prisma.TestSuitesGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestSuitesGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestSuitesCountArgs<ExtArgs>
            result: $Utils.Optional<TestSuitesCountAggregateOutputType> | number
          }
        }
      }
      ProjectVariable: {
        payload: Prisma.$ProjectVariablePayload<ExtArgs>
        fields: Prisma.ProjectVariableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectVariableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectVariablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectVariableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectVariablePayload>
          }
          findFirst: {
            args: Prisma.ProjectVariableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectVariablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectVariableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectVariablePayload>
          }
          findMany: {
            args: Prisma.ProjectVariableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectVariablePayload>[]
          }
          create: {
            args: Prisma.ProjectVariableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectVariablePayload>
          }
          createMany: {
            args: Prisma.ProjectVariableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectVariableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectVariablePayload>[]
          }
          delete: {
            args: Prisma.ProjectVariableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectVariablePayload>
          }
          update: {
            args: Prisma.ProjectVariableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectVariablePayload>
          }
          deleteMany: {
            args: Prisma.ProjectVariableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectVariableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectVariableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectVariablePayload>[]
          }
          upsert: {
            args: Prisma.ProjectVariableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectVariablePayload>
          }
          aggregate: {
            args: Prisma.ProjectVariableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectVariable>
          }
          groupBy: {
            args: Prisma.ProjectVariableGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectVariableGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectVariableCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectVariableCountAggregateOutputType> | number
          }
        }
      }
      TestSuiteVariable: {
        payload: Prisma.$TestSuiteVariablePayload<ExtArgs>
        fields: Prisma.TestSuiteVariableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestSuiteVariableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteVariablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestSuiteVariableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteVariablePayload>
          }
          findFirst: {
            args: Prisma.TestSuiteVariableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteVariablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestSuiteVariableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteVariablePayload>
          }
          findMany: {
            args: Prisma.TestSuiteVariableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteVariablePayload>[]
          }
          create: {
            args: Prisma.TestSuiteVariableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteVariablePayload>
          }
          createMany: {
            args: Prisma.TestSuiteVariableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestSuiteVariableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteVariablePayload>[]
          }
          delete: {
            args: Prisma.TestSuiteVariableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteVariablePayload>
          }
          update: {
            args: Prisma.TestSuiteVariableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteVariablePayload>
          }
          deleteMany: {
            args: Prisma.TestSuiteVariableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestSuiteVariableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestSuiteVariableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteVariablePayload>[]
          }
          upsert: {
            args: Prisma.TestSuiteVariableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteVariablePayload>
          }
          aggregate: {
            args: Prisma.TestSuiteVariableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestSuiteVariable>
          }
          groupBy: {
            args: Prisma.TestSuiteVariableGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestSuiteVariableGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestSuiteVariableCountArgs<ExtArgs>
            result: $Utils.Optional<TestSuiteVariableCountAggregateOutputType> | number
          }
        }
      }
      ProjectFunction: {
        payload: Prisma.$ProjectFunctionPayload<ExtArgs>
        fields: Prisma.ProjectFunctionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFunctionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFunctionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFunctionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFunctionPayload>
          }
          findFirst: {
            args: Prisma.ProjectFunctionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFunctionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFunctionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFunctionPayload>
          }
          findMany: {
            args: Prisma.ProjectFunctionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFunctionPayload>[]
          }
          create: {
            args: Prisma.ProjectFunctionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFunctionPayload>
          }
          createMany: {
            args: Prisma.ProjectFunctionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectFunctionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFunctionPayload>[]
          }
          delete: {
            args: Prisma.ProjectFunctionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFunctionPayload>
          }
          update: {
            args: Prisma.ProjectFunctionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFunctionPayload>
          }
          deleteMany: {
            args: Prisma.ProjectFunctionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectFunctionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectFunctionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFunctionPayload>[]
          }
          upsert: {
            args: Prisma.ProjectFunctionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFunctionPayload>
          }
          aggregate: {
            args: Prisma.ProjectFunctionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectFunction>
          }
          groupBy: {
            args: Prisma.ProjectFunctionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectFunctionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectFunctionCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectFunctionCountAggregateOutputType> | number
          }
        }
      }
      TestSuiteFunction: {
        payload: Prisma.$TestSuiteFunctionPayload<ExtArgs>
        fields: Prisma.TestSuiteFunctionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestSuiteFunctionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteFunctionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestSuiteFunctionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteFunctionPayload>
          }
          findFirst: {
            args: Prisma.TestSuiteFunctionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteFunctionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestSuiteFunctionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteFunctionPayload>
          }
          findMany: {
            args: Prisma.TestSuiteFunctionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteFunctionPayload>[]
          }
          create: {
            args: Prisma.TestSuiteFunctionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteFunctionPayload>
          }
          createMany: {
            args: Prisma.TestSuiteFunctionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestSuiteFunctionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteFunctionPayload>[]
          }
          delete: {
            args: Prisma.TestSuiteFunctionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteFunctionPayload>
          }
          update: {
            args: Prisma.TestSuiteFunctionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteFunctionPayload>
          }
          deleteMany: {
            args: Prisma.TestSuiteFunctionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestSuiteFunctionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestSuiteFunctionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteFunctionPayload>[]
          }
          upsert: {
            args: Prisma.TestSuiteFunctionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestSuiteFunctionPayload>
          }
          aggregate: {
            args: Prisma.TestSuiteFunctionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestSuiteFunction>
          }
          groupBy: {
            args: Prisma.TestSuiteFunctionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestSuiteFunctionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestSuiteFunctionCountArgs<ExtArgs>
            result: $Utils.Optional<TestSuiteFunctionCountAggregateOutputType> | number
          }
        }
      }
      Page: {
        payload: Prisma.$PagePayload<ExtArgs>
        fields: Prisma.PageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findFirst: {
            args: Prisma.PageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findMany: {
            args: Prisma.PageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          create: {
            args: Prisma.PageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          createMany: {
            args: Prisma.PageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          delete: {
            args: Prisma.PageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          update: {
            args: Prisma.PageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          deleteMany: {
            args: Prisma.PageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          upsert: {
            args: Prisma.PageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          aggregate: {
            args: Prisma.PageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePage>
          }
          groupBy: {
            args: Prisma.PageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageCountArgs<ExtArgs>
            result: $Utils.Optional<PageCountAggregateOutputType> | number
          }
        }
      }
      PageElement: {
        payload: Prisma.$PageElementPayload<ExtArgs>
        fields: Prisma.PageElementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageElementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageElementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageElementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageElementPayload>
          }
          findFirst: {
            args: Prisma.PageElementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageElementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageElementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageElementPayload>
          }
          findMany: {
            args: Prisma.PageElementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageElementPayload>[]
          }
          create: {
            args: Prisma.PageElementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageElementPayload>
          }
          createMany: {
            args: Prisma.PageElementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PageElementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageElementPayload>[]
          }
          delete: {
            args: Prisma.PageElementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageElementPayload>
          }
          update: {
            args: Prisma.PageElementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageElementPayload>
          }
          deleteMany: {
            args: Prisma.PageElementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PageElementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PageElementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageElementPayload>[]
          }
          upsert: {
            args: Prisma.PageElementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageElementPayload>
          }
          aggregate: {
            args: Prisma.PageElementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePageElement>
          }
          groupBy: {
            args: Prisma.PageElementGroupByArgs<ExtArgs>
            result: $Utils.Optional<PageElementGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageElementCountArgs<ExtArgs>
            result: $Utils.Optional<PageElementCountAggregateOutputType> | number
          }
        }
      }
      TestCase: {
        payload: Prisma.$TestCasePayload<ExtArgs>
        fields: Prisma.TestCaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestCaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestCaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCasePayload>
          }
          findFirst: {
            args: Prisma.TestCaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestCaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCasePayload>
          }
          findMany: {
            args: Prisma.TestCaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCasePayload>[]
          }
          create: {
            args: Prisma.TestCaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCasePayload>
          }
          createMany: {
            args: Prisma.TestCaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestCaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCasePayload>[]
          }
          delete: {
            args: Prisma.TestCaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCasePayload>
          }
          update: {
            args: Prisma.TestCaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCasePayload>
          }
          deleteMany: {
            args: Prisma.TestCaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestCaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestCaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCasePayload>[]
          }
          upsert: {
            args: Prisma.TestCaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestCasePayload>
          }
          aggregate: {
            args: Prisma.TestCaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestCase>
          }
          groupBy: {
            args: Prisma.TestCaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestCaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestCaseCountArgs<ExtArgs>
            result: $Utils.Optional<TestCaseCountAggregateOutputType> | number
          }
        }
      }
      ProjectInvitation: {
        payload: Prisma.$ProjectInvitationPayload<ExtArgs>
        fields: Prisma.ProjectInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitationPayload>
          }
          findFirst: {
            args: Prisma.ProjectInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitationPayload>
          }
          findMany: {
            args: Prisma.ProjectInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitationPayload>[]
          }
          create: {
            args: Prisma.ProjectInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitationPayload>
          }
          createMany: {
            args: Prisma.ProjectInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitationPayload>[]
          }
          delete: {
            args: Prisma.ProjectInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitationPayload>
          }
          update: {
            args: Prisma.ProjectInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitationPayload>
          }
          deleteMany: {
            args: Prisma.ProjectInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectInvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitationPayload>[]
          }
          upsert: {
            args: Prisma.ProjectInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvitationPayload>
          }
          aggregate: {
            args: Prisma.ProjectInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectInvitation>
          }
          groupBy: {
            args: Prisma.ProjectInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectInvitationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
    project?: ProjectOmit
    projectMember?: ProjectMemberOmit
    testSuites?: TestSuitesOmit
    projectVariable?: ProjectVariableOmit
    testSuiteVariable?: TestSuiteVariableOmit
    projectFunction?: ProjectFunctionOmit
    testSuiteFunction?: TestSuiteFunctionOmit
    page?: PageOmit
    pageElement?: PageElementOmit
    testCase?: TestCaseOmit
    projectInvitation?: ProjectInvitationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
    createdProjects: number
    projectMemberships: number
    createdPages: number
    createdPageElements: number
    createdTestCases: number
    sentInvitations: number
    receivedInvitations: number
    projectVariables: number
    testSuiteVariables: number
    projectFunctions: number
    testSuiteFunctions: number
    testSuites: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    createdProjects?: boolean | UserCountOutputTypeCountCreatedProjectsArgs
    projectMemberships?: boolean | UserCountOutputTypeCountProjectMembershipsArgs
    createdPages?: boolean | UserCountOutputTypeCountCreatedPagesArgs
    createdPageElements?: boolean | UserCountOutputTypeCountCreatedPageElementsArgs
    createdTestCases?: boolean | UserCountOutputTypeCountCreatedTestCasesArgs
    sentInvitations?: boolean | UserCountOutputTypeCountSentInvitationsArgs
    receivedInvitations?: boolean | UserCountOutputTypeCountReceivedInvitationsArgs
    projectVariables?: boolean | UserCountOutputTypeCountProjectVariablesArgs
    testSuiteVariables?: boolean | UserCountOutputTypeCountTestSuiteVariablesArgs
    projectFunctions?: boolean | UserCountOutputTypeCountProjectFunctionsArgs
    testSuiteFunctions?: boolean | UserCountOutputTypeCountTestSuiteFunctionsArgs
    testSuites?: boolean | UserCountOutputTypeCountTestSuitesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedPageElementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageElementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTestCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestCaseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectVariablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectVariableWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTestSuiteVariablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestSuiteVariableWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectFunctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectFunctionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTestSuiteFunctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestSuiteFunctionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTestSuitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestSuitesWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    members: number
    pages: number
    invitations: number
    testSuites: number
    globalVariables: number
    globalFunctions: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ProjectCountOutputTypeCountMembersArgs
    pages?: boolean | ProjectCountOutputTypeCountPagesArgs
    invitations?: boolean | ProjectCountOutputTypeCountInvitationsArgs
    testSuites?: boolean | ProjectCountOutputTypeCountTestSuitesArgs
    globalVariables?: boolean | ProjectCountOutputTypeCountGlobalVariablesArgs
    globalFunctions?: boolean | ProjectCountOutputTypeCountGlobalFunctionsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectInvitationWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTestSuitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestSuitesWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountGlobalVariablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectVariableWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountGlobalFunctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectFunctionWhereInput
  }


  /**
   * Count Type TestSuitesCountOutputType
   */

  export type TestSuitesCountOutputType = {
    testCases: number
    variables: number
    functions: number
  }

  export type TestSuitesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testCases?: boolean | TestSuitesCountOutputTypeCountTestCasesArgs
    variables?: boolean | TestSuitesCountOutputTypeCountVariablesArgs
    functions?: boolean | TestSuitesCountOutputTypeCountFunctionsArgs
  }

  // Custom InputTypes
  /**
   * TestSuitesCountOutputType without action
   */
  export type TestSuitesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuitesCountOutputType
     */
    select?: TestSuitesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestSuitesCountOutputType without action
   */
  export type TestSuitesCountOutputTypeCountTestCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestCaseWhereInput
  }

  /**
   * TestSuitesCountOutputType without action
   */
  export type TestSuitesCountOutputTypeCountVariablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestSuiteVariableWhereInput
  }

  /**
   * TestSuitesCountOutputType without action
   */
  export type TestSuitesCountOutputTypeCountFunctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestSuiteFunctionWhereInput
  }


  /**
   * Count Type PageCountOutputType
   */

  export type PageCountOutputType = {
    elements: number
  }

  export type PageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    elements?: boolean | PageCountOutputTypeCountElementsArgs
  }

  // Custom InputTypes
  /**
   * PageCountOutputType without action
   */
  export type PageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageCountOutputType
     */
    select?: PageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PageCountOutputType without action
   */
  export type PageCountOutputTypeCountElementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageElementWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    createdProjects?: boolean | User$createdProjectsArgs<ExtArgs>
    projectMemberships?: boolean | User$projectMembershipsArgs<ExtArgs>
    createdPages?: boolean | User$createdPagesArgs<ExtArgs>
    createdPageElements?: boolean | User$createdPageElementsArgs<ExtArgs>
    createdTestCases?: boolean | User$createdTestCasesArgs<ExtArgs>
    sentInvitations?: boolean | User$sentInvitationsArgs<ExtArgs>
    receivedInvitations?: boolean | User$receivedInvitationsArgs<ExtArgs>
    projectVariables?: boolean | User$projectVariablesArgs<ExtArgs>
    testSuiteVariables?: boolean | User$testSuiteVariablesArgs<ExtArgs>
    projectFunctions?: boolean | User$projectFunctionsArgs<ExtArgs>
    testSuiteFunctions?: boolean | User$testSuiteFunctionsArgs<ExtArgs>
    testSuites?: boolean | User$testSuitesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    createdProjects?: boolean | User$createdProjectsArgs<ExtArgs>
    projectMemberships?: boolean | User$projectMembershipsArgs<ExtArgs>
    createdPages?: boolean | User$createdPagesArgs<ExtArgs>
    createdPageElements?: boolean | User$createdPageElementsArgs<ExtArgs>
    createdTestCases?: boolean | User$createdTestCasesArgs<ExtArgs>
    sentInvitations?: boolean | User$sentInvitationsArgs<ExtArgs>
    receivedInvitations?: boolean | User$receivedInvitationsArgs<ExtArgs>
    projectVariables?: boolean | User$projectVariablesArgs<ExtArgs>
    testSuiteVariables?: boolean | User$testSuiteVariablesArgs<ExtArgs>
    projectFunctions?: boolean | User$projectFunctionsArgs<ExtArgs>
    testSuiteFunctions?: boolean | User$testSuiteFunctionsArgs<ExtArgs>
    testSuites?: boolean | User$testSuitesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      createdProjects: Prisma.$ProjectPayload<ExtArgs>[]
      projectMemberships: Prisma.$ProjectMemberPayload<ExtArgs>[]
      createdPages: Prisma.$PagePayload<ExtArgs>[]
      createdPageElements: Prisma.$PageElementPayload<ExtArgs>[]
      createdTestCases: Prisma.$TestCasePayload<ExtArgs>[]
      sentInvitations: Prisma.$ProjectInvitationPayload<ExtArgs>[]
      receivedInvitations: Prisma.$ProjectInvitationPayload<ExtArgs>[]
      projectVariables: Prisma.$ProjectVariablePayload<ExtArgs>[]
      testSuiteVariables: Prisma.$TestSuiteVariablePayload<ExtArgs>[]
      projectFunctions: Prisma.$ProjectFunctionPayload<ExtArgs>[]
      testSuiteFunctions: Prisma.$TestSuiteFunctionPayload<ExtArgs>[]
      testSuites: Prisma.$TestSuitesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      emailVerified: boolean
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdProjects<T extends User$createdProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectMemberships<T extends User$projectMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdPages<T extends User$createdPagesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdPagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdPageElements<T extends User$createdPageElementsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdPageElementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdTestCases<T extends User$createdTestCasesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTestCasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentInvitations<T extends User$sentInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$sentInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedInvitations<T extends User$receivedInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectVariables<T extends User$projectVariablesArgs<ExtArgs> = {}>(args?: Subset<T, User$projectVariablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectVariablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testSuiteVariables<T extends User$testSuiteVariablesArgs<ExtArgs> = {}>(args?: Subset<T, User$testSuiteVariablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestSuiteVariablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectFunctions<T extends User$projectFunctionsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectFunctionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectFunctionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testSuiteFunctions<T extends User$testSuiteFunctionsArgs<ExtArgs> = {}>(args?: Subset<T, User$testSuiteFunctionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestSuiteFunctionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testSuites<T extends User$testSuitesArgs<ExtArgs> = {}>(args?: Subset<T, User$testSuitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestSuitesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.createdProjects
   */
  export type User$createdProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.projectMemberships
   */
  export type User$projectMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * User.createdPages
   */
  export type User$createdPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    where?: PageWhereInput
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    cursor?: PageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * User.createdPageElements
   */
  export type User$createdPageElementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageElement
     */
    select?: PageElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageElement
     */
    omit?: PageElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageElementInclude<ExtArgs> | null
    where?: PageElementWhereInput
    orderBy?: PageElementOrderByWithRelationInput | PageElementOrderByWithRelationInput[]
    cursor?: PageElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageElementScalarFieldEnum | PageElementScalarFieldEnum[]
  }

  /**
   * User.createdTestCases
   */
  export type User$createdTestCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCase
     */
    omit?: TestCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    where?: TestCaseWhereInput
    orderBy?: TestCaseOrderByWithRelationInput | TestCaseOrderByWithRelationInput[]
    cursor?: TestCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestCaseScalarFieldEnum | TestCaseScalarFieldEnum[]
  }

  /**
   * User.sentInvitations
   */
  export type User$sentInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvitation
     */
    select?: ProjectInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvitation
     */
    omit?: ProjectInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvitationInclude<ExtArgs> | null
    where?: ProjectInvitationWhereInput
    orderBy?: ProjectInvitationOrderByWithRelationInput | ProjectInvitationOrderByWithRelationInput[]
    cursor?: ProjectInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectInvitationScalarFieldEnum | ProjectInvitationScalarFieldEnum[]
  }

  /**
   * User.receivedInvitations
   */
  export type User$receivedInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvitation
     */
    select?: ProjectInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvitation
     */
    omit?: ProjectInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvitationInclude<ExtArgs> | null
    where?: ProjectInvitationWhereInput
    orderBy?: ProjectInvitationOrderByWithRelationInput | ProjectInvitationOrderByWithRelationInput[]
    cursor?: ProjectInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectInvitationScalarFieldEnum | ProjectInvitationScalarFieldEnum[]
  }

  /**
   * User.projectVariables
   */
  export type User$projectVariablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectVariable
     */
    select?: ProjectVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectVariable
     */
    omit?: ProjectVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectVariableInclude<ExtArgs> | null
    where?: ProjectVariableWhereInput
    orderBy?: ProjectVariableOrderByWithRelationInput | ProjectVariableOrderByWithRelationInput[]
    cursor?: ProjectVariableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectVariableScalarFieldEnum | ProjectVariableScalarFieldEnum[]
  }

  /**
   * User.testSuiteVariables
   */
  export type User$testSuiteVariablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteVariable
     */
    select?: TestSuiteVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteVariable
     */
    omit?: TestSuiteVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteVariableInclude<ExtArgs> | null
    where?: TestSuiteVariableWhereInput
    orderBy?: TestSuiteVariableOrderByWithRelationInput | TestSuiteVariableOrderByWithRelationInput[]
    cursor?: TestSuiteVariableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestSuiteVariableScalarFieldEnum | TestSuiteVariableScalarFieldEnum[]
  }

  /**
   * User.projectFunctions
   */
  export type User$projectFunctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFunction
     */
    select?: ProjectFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFunction
     */
    omit?: ProjectFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFunctionInclude<ExtArgs> | null
    where?: ProjectFunctionWhereInput
    orderBy?: ProjectFunctionOrderByWithRelationInput | ProjectFunctionOrderByWithRelationInput[]
    cursor?: ProjectFunctionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectFunctionScalarFieldEnum | ProjectFunctionScalarFieldEnum[]
  }

  /**
   * User.testSuiteFunctions
   */
  export type User$testSuiteFunctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteFunction
     */
    select?: TestSuiteFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteFunction
     */
    omit?: TestSuiteFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteFunctionInclude<ExtArgs> | null
    where?: TestSuiteFunctionWhereInput
    orderBy?: TestSuiteFunctionOrderByWithRelationInput | TestSuiteFunctionOrderByWithRelationInput[]
    cursor?: TestSuiteFunctionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestSuiteFunctionScalarFieldEnum | TestSuiteFunctionScalarFieldEnum[]
  }

  /**
   * User.testSuites
   */
  export type User$testSuitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuites
     */
    select?: TestSuitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuites
     */
    omit?: TestSuitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuitesInclude<ExtArgs> | null
    where?: TestSuitesWhereInput
    orderBy?: TestSuitesOrderByWithRelationInput | TestSuitesOrderByWithRelationInput[]
    cursor?: TestSuitesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestSuitesScalarFieldEnum | TestSuitesScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    expiresAt: number
    token: number
    createdAt: number
    updatedAt: number
    ipAddress: number
    userAgent: number
    userId: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    expiresAt: Date
    token: string
    createdAt: Date
    updatedAt: Date
    ipAddress: string | null
    userAgent: string | null
    userId: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expiresAt" | "token" | "createdAt" | "updatedAt" | "ipAddress" | "userAgent" | "userId", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expiresAt: Date
      token: string
      createdAt: Date
      updatedAt: Date
      ipAddress: string | null
      userAgent: string | null
      userId: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly token: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "providerId" | "userId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date | null
    updatedAt: Date | null
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    id: number | null
  }

  export type ProjectSumAggregateOutputType = {
    id: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    baseUrl: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    baseUrl: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    baseUrl: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    id?: true
  }

  export type ProjectSumAggregateInputType = {
    id?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    baseUrl?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    baseUrl?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    baseUrl?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: number
    name: string
    description: string | null
    baseUrl: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    baseUrl?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | Project$creatorArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    pages?: boolean | Project$pagesArgs<ExtArgs>
    invitations?: boolean | Project$invitationsArgs<ExtArgs>
    testSuites?: boolean | Project$testSuitesArgs<ExtArgs>
    globalVariables?: boolean | Project$globalVariablesArgs<ExtArgs>
    globalFunctions?: boolean | Project$globalFunctionsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    baseUrl?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | Project$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    baseUrl?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | Project$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    baseUrl?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "baseUrl" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Project$creatorArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    pages?: boolean | Project$pagesArgs<ExtArgs>
    invitations?: boolean | Project$invitationsArgs<ExtArgs>
    testSuites?: boolean | Project$testSuitesArgs<ExtArgs>
    globalVariables?: boolean | Project$globalVariablesArgs<ExtArgs>
    globalFunctions?: boolean | Project$globalFunctionsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Project$creatorArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Project$creatorArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs> | null
      members: Prisma.$ProjectMemberPayload<ExtArgs>[]
      pages: Prisma.$PagePayload<ExtArgs>[]
      invitations: Prisma.$ProjectInvitationPayload<ExtArgs>[]
      testSuites: Prisma.$TestSuitesPayload<ExtArgs>[]
      globalVariables: Prisma.$ProjectVariablePayload<ExtArgs>[]
      globalFunctions: Prisma.$ProjectFunctionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      baseUrl: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends Project$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Project$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    members<T extends Project$membersArgs<ExtArgs> = {}>(args?: Subset<T, Project$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pages<T extends Project$pagesArgs<ExtArgs> = {}>(args?: Subset<T, Project$pagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends Project$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Project$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testSuites<T extends Project$testSuitesArgs<ExtArgs> = {}>(args?: Subset<T, Project$testSuitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestSuitesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    globalVariables<T extends Project$globalVariablesArgs<ExtArgs> = {}>(args?: Subset<T, Project$globalVariablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectVariablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    globalFunctions<T extends Project$globalFunctionsArgs<ExtArgs> = {}>(args?: Subset<T, Project$globalFunctionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectFunctionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'Int'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly baseUrl: FieldRef<"Project", 'String'>
    readonly createdBy: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.creator
   */
  export type Project$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Project.members
   */
  export type Project$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * Project.pages
   */
  export type Project$pagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    where?: PageWhereInput
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    cursor?: PageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Project.invitations
   */
  export type Project$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvitation
     */
    select?: ProjectInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvitation
     */
    omit?: ProjectInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvitationInclude<ExtArgs> | null
    where?: ProjectInvitationWhereInput
    orderBy?: ProjectInvitationOrderByWithRelationInput | ProjectInvitationOrderByWithRelationInput[]
    cursor?: ProjectInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectInvitationScalarFieldEnum | ProjectInvitationScalarFieldEnum[]
  }

  /**
   * Project.testSuites
   */
  export type Project$testSuitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuites
     */
    select?: TestSuitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuites
     */
    omit?: TestSuitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuitesInclude<ExtArgs> | null
    where?: TestSuitesWhereInput
    orderBy?: TestSuitesOrderByWithRelationInput | TestSuitesOrderByWithRelationInput[]
    cursor?: TestSuitesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestSuitesScalarFieldEnum | TestSuitesScalarFieldEnum[]
  }

  /**
   * Project.globalVariables
   */
  export type Project$globalVariablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectVariable
     */
    select?: ProjectVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectVariable
     */
    omit?: ProjectVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectVariableInclude<ExtArgs> | null
    where?: ProjectVariableWhereInput
    orderBy?: ProjectVariableOrderByWithRelationInput | ProjectVariableOrderByWithRelationInput[]
    cursor?: ProjectVariableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectVariableScalarFieldEnum | ProjectVariableScalarFieldEnum[]
  }

  /**
   * Project.globalFunctions
   */
  export type Project$globalFunctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFunction
     */
    select?: ProjectFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFunction
     */
    omit?: ProjectFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFunctionInclude<ExtArgs> | null
    where?: ProjectFunctionWhereInput
    orderBy?: ProjectFunctionOrderByWithRelationInput | ProjectFunctionOrderByWithRelationInput[]
    cursor?: ProjectFunctionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectFunctionScalarFieldEnum | ProjectFunctionScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectMember
   */

  export type AggregateProjectMember = {
    _count: ProjectMemberCountAggregateOutputType | null
    _avg: ProjectMemberAvgAggregateOutputType | null
    _sum: ProjectMemberSumAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  export type ProjectMemberAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ProjectMemberSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ProjectMemberMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type ProjectMemberMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type ProjectMemberCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type ProjectMemberAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ProjectMemberSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ProjectMemberMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type ProjectMemberMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type ProjectMemberCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type ProjectMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMember to aggregate.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectMembers
    **/
    _count?: true | ProjectMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type GetProjectMemberAggregateType<T extends ProjectMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectMember[P]>
      : GetScalarType<T[P], AggregateProjectMember[P]>
  }




  export type ProjectMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithAggregationInput | ProjectMemberOrderByWithAggregationInput[]
    by: ProjectMemberScalarFieldEnum[] | ProjectMemberScalarFieldEnum
    having?: ProjectMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectMemberCountAggregateInputType | true
    _avg?: ProjectMemberAvgAggregateInputType
    _sum?: ProjectMemberSumAggregateInputType
    _min?: ProjectMemberMinAggregateInputType
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type ProjectMemberGroupByOutputType = {
    id: number
    projectId: number
    userId: string
    role: string
    joinedAt: Date
    _count: ProjectMemberCountAggregateOutputType | null
    _avg: ProjectMemberAvgAggregateOutputType | null
    _sum: ProjectMemberSumAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  type GetProjectMemberGroupByPayload<T extends ProjectMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
        }
      >
    >


  export type ProjectMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type ProjectMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "userId" | "role" | "joinedAt", ExtArgs["result"]["projectMember"]>
  export type ProjectMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectMember"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      userId: string
      role: string
      joinedAt: Date
    }, ExtArgs["result"]["projectMember"]>
    composites: {}
  }

  type ProjectMemberGetPayload<S extends boolean | null | undefined | ProjectMemberDefaultArgs> = $Result.GetResult<Prisma.$ProjectMemberPayload, S>

  type ProjectMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectMemberCountAggregateInputType | true
    }

  export interface ProjectMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectMember'], meta: { name: 'ProjectMember' } }
    /**
     * Find zero or one ProjectMember that matches the filter.
     * @param {ProjectMemberFindUniqueArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectMemberFindUniqueArgs>(args: SelectSubset<T, ProjectMemberFindUniqueArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectMemberFindUniqueOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectMemberFindFirstArgs>(args?: SelectSubset<T, ProjectMemberFindFirstArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany()
     * 
     * // Get first 10 ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectMemberFindManyArgs>(args?: SelectSubset<T, ProjectMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectMember.
     * @param {ProjectMemberCreateArgs} args - Arguments to create a ProjectMember.
     * @example
     * // Create one ProjectMember
     * const ProjectMember = await prisma.projectMember.create({
     *   data: {
     *     // ... data to create a ProjectMember
     *   }
     * })
     * 
     */
    create<T extends ProjectMemberCreateArgs>(args: SelectSubset<T, ProjectMemberCreateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectMembers.
     * @param {ProjectMemberCreateManyArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectMemberCreateManyArgs>(args?: SelectSubset<T, ProjectMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectMembers and returns the data saved in the database.
     * @param {ProjectMemberCreateManyAndReturnArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectMembers and only return the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectMember.
     * @param {ProjectMemberDeleteArgs} args - Arguments to delete one ProjectMember.
     * @example
     * // Delete one ProjectMember
     * const ProjectMember = await prisma.projectMember.delete({
     *   where: {
     *     // ... filter to delete one ProjectMember
     *   }
     * })
     * 
     */
    delete<T extends ProjectMemberDeleteArgs>(args: SelectSubset<T, ProjectMemberDeleteArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectMember.
     * @param {ProjectMemberUpdateArgs} args - Arguments to update one ProjectMember.
     * @example
     * // Update one ProjectMember
     * const projectMember = await prisma.projectMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectMemberUpdateArgs>(args: SelectSubset<T, ProjectMemberUpdateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectMembers.
     * @param {ProjectMemberDeleteManyArgs} args - Arguments to filter ProjectMembers to delete.
     * @example
     * // Delete a few ProjectMembers
     * const { count } = await prisma.projectMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectMemberDeleteManyArgs>(args?: SelectSubset<T, ProjectMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectMemberUpdateManyArgs>(args: SelectSubset<T, ProjectMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers and returns the data updated in the database.
     * @param {ProjectMemberUpdateManyAndReturnArgs} args - Arguments to update many ProjectMembers.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectMembers and only return the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectMember.
     * @param {ProjectMemberUpsertArgs} args - Arguments to update or create a ProjectMember.
     * @example
     * // Update or create a ProjectMember
     * const projectMember = await prisma.projectMember.upsert({
     *   create: {
     *     // ... data to create a ProjectMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectMember we want to update
     *   }
     * })
     */
    upsert<T extends ProjectMemberUpsertArgs>(args: SelectSubset<T, ProjectMemberUpsertArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberCountArgs} args - Arguments to filter ProjectMembers to count.
     * @example
     * // Count the number of ProjectMembers
     * const count = await prisma.projectMember.count({
     *   where: {
     *     // ... the filter for the ProjectMembers we want to count
     *   }
     * })
    **/
    count<T extends ProjectMemberCountArgs>(
      args?: Subset<T, ProjectMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectMemberAggregateArgs>(args: Subset<T, ProjectMemberAggregateArgs>): Prisma.PrismaPromise<GetProjectMemberAggregateType<T>>

    /**
     * Group by ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectMemberGroupByArgs['orderBy'] }
        : { orderBy?: ProjectMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectMember model
   */
  readonly fields: ProjectMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectMember model
   */
  interface ProjectMemberFieldRefs {
    readonly id: FieldRef<"ProjectMember", 'Int'>
    readonly projectId: FieldRef<"ProjectMember", 'Int'>
    readonly userId: FieldRef<"ProjectMember", 'String'>
    readonly role: FieldRef<"ProjectMember", 'String'>
    readonly joinedAt: FieldRef<"ProjectMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectMember findUnique
   */
  export type ProjectMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findUniqueOrThrow
   */
  export type ProjectMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findFirst
   */
  export type ProjectMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findFirstOrThrow
   */
  export type ProjectMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findMany
   */
  export type ProjectMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMembers to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember create
   */
  export type ProjectMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectMember.
     */
    data: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
  }

  /**
   * ProjectMember createMany
   */
  export type ProjectMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectMember createManyAndReturn
   */
  export type ProjectMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMember update
   */
  export type ProjectMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectMember.
     */
    data: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
    /**
     * Choose, which ProjectMember to update.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember updateMany
   */
  export type ProjectMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectMembers.
     */
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMembers to update
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to update.
     */
    limit?: number
  }

  /**
   * ProjectMember updateManyAndReturn
   */
  export type ProjectMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * The data used to update ProjectMembers.
     */
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMembers to update
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMember upsert
   */
  export type ProjectMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectMember to update in case it exists.
     */
    where: ProjectMemberWhereUniqueInput
    /**
     * In case the ProjectMember found by the `where` argument doesn't exist, create a new ProjectMember with this data.
     */
    create: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
    /**
     * In case the ProjectMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
  }

  /**
   * ProjectMember delete
   */
  export type ProjectMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter which ProjectMember to delete.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember deleteMany
   */
  export type ProjectMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMembers to delete
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to delete.
     */
    limit?: number
  }

  /**
   * ProjectMember without action
   */
  export type ProjectMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
  }


  /**
   * Model TestSuites
   */

  export type AggregateTestSuites = {
    _count: TestSuitesCountAggregateOutputType | null
    _avg: TestSuitesAvgAggregateOutputType | null
    _sum: TestSuitesSumAggregateOutputType | null
    _min: TestSuitesMinAggregateOutputType | null
    _max: TestSuitesMaxAggregateOutputType | null
  }

  export type TestSuitesAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type TestSuitesSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type TestSuitesMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestSuitesMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestSuitesCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    description: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TestSuitesAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type TestSuitesSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type TestSuitesMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestSuitesMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestSuitesCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestSuitesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestSuites to aggregate.
     */
    where?: TestSuitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestSuites to fetch.
     */
    orderBy?: TestSuitesOrderByWithRelationInput | TestSuitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestSuitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestSuites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestSuites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestSuites
    **/
    _count?: true | TestSuitesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestSuitesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestSuitesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestSuitesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestSuitesMaxAggregateInputType
  }

  export type GetTestSuitesAggregateType<T extends TestSuitesAggregateArgs> = {
        [P in keyof T & keyof AggregateTestSuites]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestSuites[P]>
      : GetScalarType<T[P], AggregateTestSuites[P]>
  }




  export type TestSuitesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestSuitesWhereInput
    orderBy?: TestSuitesOrderByWithAggregationInput | TestSuitesOrderByWithAggregationInput[]
    by: TestSuitesScalarFieldEnum[] | TestSuitesScalarFieldEnum
    having?: TestSuitesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestSuitesCountAggregateInputType | true
    _avg?: TestSuitesAvgAggregateInputType
    _sum?: TestSuitesSumAggregateInputType
    _min?: TestSuitesMinAggregateInputType
    _max?: TestSuitesMaxAggregateInputType
  }

  export type TestSuitesGroupByOutputType = {
    id: number
    projectId: number
    name: string
    description: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: TestSuitesCountAggregateOutputType | null
    _avg: TestSuitesAvgAggregateOutputType | null
    _sum: TestSuitesSumAggregateOutputType | null
    _min: TestSuitesMinAggregateOutputType | null
    _max: TestSuitesMaxAggregateOutputType | null
  }

  type GetTestSuitesGroupByPayload<T extends TestSuitesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestSuitesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestSuitesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestSuitesGroupByOutputType[P]>
            : GetScalarType<T[P], TestSuitesGroupByOutputType[P]>
        }
      >
    >


  export type TestSuitesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | TestSuites$creatorArgs<ExtArgs>
    testCases?: boolean | TestSuites$testCasesArgs<ExtArgs>
    variables?: boolean | TestSuites$variablesArgs<ExtArgs>
    functions?: boolean | TestSuites$functionsArgs<ExtArgs>
    _count?: boolean | TestSuitesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testSuites"]>

  export type TestSuitesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | TestSuites$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["testSuites"]>

  export type TestSuitesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | TestSuites$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["testSuites"]>

  export type TestSuitesSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TestSuitesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "description" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["testSuites"]>
  export type TestSuitesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | TestSuites$creatorArgs<ExtArgs>
    testCases?: boolean | TestSuites$testCasesArgs<ExtArgs>
    variables?: boolean | TestSuites$variablesArgs<ExtArgs>
    functions?: boolean | TestSuites$functionsArgs<ExtArgs>
    _count?: boolean | TestSuitesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TestSuitesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | TestSuites$creatorArgs<ExtArgs>
  }
  export type TestSuitesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | TestSuites$creatorArgs<ExtArgs>
  }

  export type $TestSuitesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestSuites"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs> | null
      testCases: Prisma.$TestCasePayload<ExtArgs>[]
      variables: Prisma.$TestSuiteVariablePayload<ExtArgs>[]
      functions: Prisma.$TestSuiteFunctionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      name: string
      description: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testSuites"]>
    composites: {}
  }

  type TestSuitesGetPayload<S extends boolean | null | undefined | TestSuitesDefaultArgs> = $Result.GetResult<Prisma.$TestSuitesPayload, S>

  type TestSuitesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestSuitesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestSuitesCountAggregateInputType | true
    }

  export interface TestSuitesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestSuites'], meta: { name: 'TestSuites' } }
    /**
     * Find zero or one TestSuites that matches the filter.
     * @param {TestSuitesFindUniqueArgs} args - Arguments to find a TestSuites
     * @example
     * // Get one TestSuites
     * const testSuites = await prisma.testSuites.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestSuitesFindUniqueArgs>(args: SelectSubset<T, TestSuitesFindUniqueArgs<ExtArgs>>): Prisma__TestSuitesClient<$Result.GetResult<Prisma.$TestSuitesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestSuites that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestSuitesFindUniqueOrThrowArgs} args - Arguments to find a TestSuites
     * @example
     * // Get one TestSuites
     * const testSuites = await prisma.testSuites.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestSuitesFindUniqueOrThrowArgs>(args: SelectSubset<T, TestSuitesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestSuitesClient<$Result.GetResult<Prisma.$TestSuitesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestSuites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestSuitesFindFirstArgs} args - Arguments to find a TestSuites
     * @example
     * // Get one TestSuites
     * const testSuites = await prisma.testSuites.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestSuitesFindFirstArgs>(args?: SelectSubset<T, TestSuitesFindFirstArgs<ExtArgs>>): Prisma__TestSuitesClient<$Result.GetResult<Prisma.$TestSuitesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestSuites that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestSuitesFindFirstOrThrowArgs} args - Arguments to find a TestSuites
     * @example
     * // Get one TestSuites
     * const testSuites = await prisma.testSuites.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestSuitesFindFirstOrThrowArgs>(args?: SelectSubset<T, TestSuitesFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestSuitesClient<$Result.GetResult<Prisma.$TestSuitesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestSuites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestSuitesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestSuites
     * const testSuites = await prisma.testSuites.findMany()
     * 
     * // Get first 10 TestSuites
     * const testSuites = await prisma.testSuites.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testSuitesWithIdOnly = await prisma.testSuites.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestSuitesFindManyArgs>(args?: SelectSubset<T, TestSuitesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestSuitesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestSuites.
     * @param {TestSuitesCreateArgs} args - Arguments to create a TestSuites.
     * @example
     * // Create one TestSuites
     * const TestSuites = await prisma.testSuites.create({
     *   data: {
     *     // ... data to create a TestSuites
     *   }
     * })
     * 
     */
    create<T extends TestSuitesCreateArgs>(args: SelectSubset<T, TestSuitesCreateArgs<ExtArgs>>): Prisma__TestSuitesClient<$Result.GetResult<Prisma.$TestSuitesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestSuites.
     * @param {TestSuitesCreateManyArgs} args - Arguments to create many TestSuites.
     * @example
     * // Create many TestSuites
     * const testSuites = await prisma.testSuites.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestSuitesCreateManyArgs>(args?: SelectSubset<T, TestSuitesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestSuites and returns the data saved in the database.
     * @param {TestSuitesCreateManyAndReturnArgs} args - Arguments to create many TestSuites.
     * @example
     * // Create many TestSuites
     * const testSuites = await prisma.testSuites.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestSuites and only return the `id`
     * const testSuitesWithIdOnly = await prisma.testSuites.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestSuitesCreateManyAndReturnArgs>(args?: SelectSubset<T, TestSuitesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestSuitesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TestSuites.
     * @param {TestSuitesDeleteArgs} args - Arguments to delete one TestSuites.
     * @example
     * // Delete one TestSuites
     * const TestSuites = await prisma.testSuites.delete({
     *   where: {
     *     // ... filter to delete one TestSuites
     *   }
     * })
     * 
     */
    delete<T extends TestSuitesDeleteArgs>(args: SelectSubset<T, TestSuitesDeleteArgs<ExtArgs>>): Prisma__TestSuitesClient<$Result.GetResult<Prisma.$TestSuitesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestSuites.
     * @param {TestSuitesUpdateArgs} args - Arguments to update one TestSuites.
     * @example
     * // Update one TestSuites
     * const testSuites = await prisma.testSuites.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestSuitesUpdateArgs>(args: SelectSubset<T, TestSuitesUpdateArgs<ExtArgs>>): Prisma__TestSuitesClient<$Result.GetResult<Prisma.$TestSuitesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestSuites.
     * @param {TestSuitesDeleteManyArgs} args - Arguments to filter TestSuites to delete.
     * @example
     * // Delete a few TestSuites
     * const { count } = await prisma.testSuites.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestSuitesDeleteManyArgs>(args?: SelectSubset<T, TestSuitesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestSuites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestSuitesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestSuites
     * const testSuites = await prisma.testSuites.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestSuitesUpdateManyArgs>(args: SelectSubset<T, TestSuitesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestSuites and returns the data updated in the database.
     * @param {TestSuitesUpdateManyAndReturnArgs} args - Arguments to update many TestSuites.
     * @example
     * // Update many TestSuites
     * const testSuites = await prisma.testSuites.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TestSuites and only return the `id`
     * const testSuitesWithIdOnly = await prisma.testSuites.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestSuitesUpdateManyAndReturnArgs>(args: SelectSubset<T, TestSuitesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestSuitesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TestSuites.
     * @param {TestSuitesUpsertArgs} args - Arguments to update or create a TestSuites.
     * @example
     * // Update or create a TestSuites
     * const testSuites = await prisma.testSuites.upsert({
     *   create: {
     *     // ... data to create a TestSuites
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestSuites we want to update
     *   }
     * })
     */
    upsert<T extends TestSuitesUpsertArgs>(args: SelectSubset<T, TestSuitesUpsertArgs<ExtArgs>>): Prisma__TestSuitesClient<$Result.GetResult<Prisma.$TestSuitesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestSuites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestSuitesCountArgs} args - Arguments to filter TestSuites to count.
     * @example
     * // Count the number of TestSuites
     * const count = await prisma.testSuites.count({
     *   where: {
     *     // ... the filter for the TestSuites we want to count
     *   }
     * })
    **/
    count<T extends TestSuitesCountArgs>(
      args?: Subset<T, TestSuitesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestSuitesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestSuites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestSuitesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestSuitesAggregateArgs>(args: Subset<T, TestSuitesAggregateArgs>): Prisma.PrismaPromise<GetTestSuitesAggregateType<T>>

    /**
     * Group by TestSuites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestSuitesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestSuitesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestSuitesGroupByArgs['orderBy'] }
        : { orderBy?: TestSuitesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestSuitesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestSuitesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestSuites model
   */
  readonly fields: TestSuitesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestSuites.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestSuitesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends TestSuites$creatorArgs<ExtArgs> = {}>(args?: Subset<T, TestSuites$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    testCases<T extends TestSuites$testCasesArgs<ExtArgs> = {}>(args?: Subset<T, TestSuites$testCasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    variables<T extends TestSuites$variablesArgs<ExtArgs> = {}>(args?: Subset<T, TestSuites$variablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestSuiteVariablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    functions<T extends TestSuites$functionsArgs<ExtArgs> = {}>(args?: Subset<T, TestSuites$functionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestSuiteFunctionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestSuites model
   */
  interface TestSuitesFieldRefs {
    readonly id: FieldRef<"TestSuites", 'Int'>
    readonly projectId: FieldRef<"TestSuites", 'Int'>
    readonly name: FieldRef<"TestSuites", 'String'>
    readonly description: FieldRef<"TestSuites", 'String'>
    readonly createdBy: FieldRef<"TestSuites", 'String'>
    readonly createdAt: FieldRef<"TestSuites", 'DateTime'>
    readonly updatedAt: FieldRef<"TestSuites", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TestSuites findUnique
   */
  export type TestSuitesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuites
     */
    select?: TestSuitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuites
     */
    omit?: TestSuitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuitesInclude<ExtArgs> | null
    /**
     * Filter, which TestSuites to fetch.
     */
    where: TestSuitesWhereUniqueInput
  }

  /**
   * TestSuites findUniqueOrThrow
   */
  export type TestSuitesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuites
     */
    select?: TestSuitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuites
     */
    omit?: TestSuitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuitesInclude<ExtArgs> | null
    /**
     * Filter, which TestSuites to fetch.
     */
    where: TestSuitesWhereUniqueInput
  }

  /**
   * TestSuites findFirst
   */
  export type TestSuitesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuites
     */
    select?: TestSuitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuites
     */
    omit?: TestSuitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuitesInclude<ExtArgs> | null
    /**
     * Filter, which TestSuites to fetch.
     */
    where?: TestSuitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestSuites to fetch.
     */
    orderBy?: TestSuitesOrderByWithRelationInput | TestSuitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestSuites.
     */
    cursor?: TestSuitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestSuites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestSuites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestSuites.
     */
    distinct?: TestSuitesScalarFieldEnum | TestSuitesScalarFieldEnum[]
  }

  /**
   * TestSuites findFirstOrThrow
   */
  export type TestSuitesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuites
     */
    select?: TestSuitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuites
     */
    omit?: TestSuitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuitesInclude<ExtArgs> | null
    /**
     * Filter, which TestSuites to fetch.
     */
    where?: TestSuitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestSuites to fetch.
     */
    orderBy?: TestSuitesOrderByWithRelationInput | TestSuitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestSuites.
     */
    cursor?: TestSuitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestSuites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestSuites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestSuites.
     */
    distinct?: TestSuitesScalarFieldEnum | TestSuitesScalarFieldEnum[]
  }

  /**
   * TestSuites findMany
   */
  export type TestSuitesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuites
     */
    select?: TestSuitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuites
     */
    omit?: TestSuitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuitesInclude<ExtArgs> | null
    /**
     * Filter, which TestSuites to fetch.
     */
    where?: TestSuitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestSuites to fetch.
     */
    orderBy?: TestSuitesOrderByWithRelationInput | TestSuitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestSuites.
     */
    cursor?: TestSuitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestSuites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestSuites.
     */
    skip?: number
    distinct?: TestSuitesScalarFieldEnum | TestSuitesScalarFieldEnum[]
  }

  /**
   * TestSuites create
   */
  export type TestSuitesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuites
     */
    select?: TestSuitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuites
     */
    omit?: TestSuitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuitesInclude<ExtArgs> | null
    /**
     * The data needed to create a TestSuites.
     */
    data: XOR<TestSuitesCreateInput, TestSuitesUncheckedCreateInput>
  }

  /**
   * TestSuites createMany
   */
  export type TestSuitesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestSuites.
     */
    data: TestSuitesCreateManyInput | TestSuitesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestSuites createManyAndReturn
   */
  export type TestSuitesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuites
     */
    select?: TestSuitesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuites
     */
    omit?: TestSuitesOmit<ExtArgs> | null
    /**
     * The data used to create many TestSuites.
     */
    data: TestSuitesCreateManyInput | TestSuitesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuitesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestSuites update
   */
  export type TestSuitesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuites
     */
    select?: TestSuitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuites
     */
    omit?: TestSuitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuitesInclude<ExtArgs> | null
    /**
     * The data needed to update a TestSuites.
     */
    data: XOR<TestSuitesUpdateInput, TestSuitesUncheckedUpdateInput>
    /**
     * Choose, which TestSuites to update.
     */
    where: TestSuitesWhereUniqueInput
  }

  /**
   * TestSuites updateMany
   */
  export type TestSuitesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestSuites.
     */
    data: XOR<TestSuitesUpdateManyMutationInput, TestSuitesUncheckedUpdateManyInput>
    /**
     * Filter which TestSuites to update
     */
    where?: TestSuitesWhereInput
    /**
     * Limit how many TestSuites to update.
     */
    limit?: number
  }

  /**
   * TestSuites updateManyAndReturn
   */
  export type TestSuitesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuites
     */
    select?: TestSuitesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuites
     */
    omit?: TestSuitesOmit<ExtArgs> | null
    /**
     * The data used to update TestSuites.
     */
    data: XOR<TestSuitesUpdateManyMutationInput, TestSuitesUncheckedUpdateManyInput>
    /**
     * Filter which TestSuites to update
     */
    where?: TestSuitesWhereInput
    /**
     * Limit how many TestSuites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuitesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestSuites upsert
   */
  export type TestSuitesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuites
     */
    select?: TestSuitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuites
     */
    omit?: TestSuitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuitesInclude<ExtArgs> | null
    /**
     * The filter to search for the TestSuites to update in case it exists.
     */
    where: TestSuitesWhereUniqueInput
    /**
     * In case the TestSuites found by the `where` argument doesn't exist, create a new TestSuites with this data.
     */
    create: XOR<TestSuitesCreateInput, TestSuitesUncheckedCreateInput>
    /**
     * In case the TestSuites was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestSuitesUpdateInput, TestSuitesUncheckedUpdateInput>
  }

  /**
   * TestSuites delete
   */
  export type TestSuitesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuites
     */
    select?: TestSuitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuites
     */
    omit?: TestSuitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuitesInclude<ExtArgs> | null
    /**
     * Filter which TestSuites to delete.
     */
    where: TestSuitesWhereUniqueInput
  }

  /**
   * TestSuites deleteMany
   */
  export type TestSuitesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestSuites to delete
     */
    where?: TestSuitesWhereInput
    /**
     * Limit how many TestSuites to delete.
     */
    limit?: number
  }

  /**
   * TestSuites.creator
   */
  export type TestSuites$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TestSuites.testCases
   */
  export type TestSuites$testCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCase
     */
    omit?: TestCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    where?: TestCaseWhereInput
    orderBy?: TestCaseOrderByWithRelationInput | TestCaseOrderByWithRelationInput[]
    cursor?: TestCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestCaseScalarFieldEnum | TestCaseScalarFieldEnum[]
  }

  /**
   * TestSuites.variables
   */
  export type TestSuites$variablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteVariable
     */
    select?: TestSuiteVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteVariable
     */
    omit?: TestSuiteVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteVariableInclude<ExtArgs> | null
    where?: TestSuiteVariableWhereInput
    orderBy?: TestSuiteVariableOrderByWithRelationInput | TestSuiteVariableOrderByWithRelationInput[]
    cursor?: TestSuiteVariableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestSuiteVariableScalarFieldEnum | TestSuiteVariableScalarFieldEnum[]
  }

  /**
   * TestSuites.functions
   */
  export type TestSuites$functionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteFunction
     */
    select?: TestSuiteFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteFunction
     */
    omit?: TestSuiteFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteFunctionInclude<ExtArgs> | null
    where?: TestSuiteFunctionWhereInput
    orderBy?: TestSuiteFunctionOrderByWithRelationInput | TestSuiteFunctionOrderByWithRelationInput[]
    cursor?: TestSuiteFunctionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestSuiteFunctionScalarFieldEnum | TestSuiteFunctionScalarFieldEnum[]
  }

  /**
   * TestSuites without action
   */
  export type TestSuitesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuites
     */
    select?: TestSuitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuites
     */
    omit?: TestSuitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuitesInclude<ExtArgs> | null
  }


  /**
   * Model ProjectVariable
   */

  export type AggregateProjectVariable = {
    _count: ProjectVariableCountAggregateOutputType | null
    _avg: ProjectVariableAvgAggregateOutputType | null
    _sum: ProjectVariableSumAggregateOutputType | null
    _min: ProjectVariableMinAggregateOutputType | null
    _max: ProjectVariableMaxAggregateOutputType | null
  }

  export type ProjectVariableAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ProjectVariableSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ProjectVariableMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    value: string | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectVariableMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    value: string | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectVariableCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    value: number
    description: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectVariableAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ProjectVariableSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ProjectVariableMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    value?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectVariableMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    value?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectVariableCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    value?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectVariableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectVariable to aggregate.
     */
    where?: ProjectVariableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectVariables to fetch.
     */
    orderBy?: ProjectVariableOrderByWithRelationInput | ProjectVariableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectVariableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectVariables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectVariables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectVariables
    **/
    _count?: true | ProjectVariableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectVariableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectVariableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectVariableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectVariableMaxAggregateInputType
  }

  export type GetProjectVariableAggregateType<T extends ProjectVariableAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectVariable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectVariable[P]>
      : GetScalarType<T[P], AggregateProjectVariable[P]>
  }




  export type ProjectVariableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectVariableWhereInput
    orderBy?: ProjectVariableOrderByWithAggregationInput | ProjectVariableOrderByWithAggregationInput[]
    by: ProjectVariableScalarFieldEnum[] | ProjectVariableScalarFieldEnum
    having?: ProjectVariableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectVariableCountAggregateInputType | true
    _avg?: ProjectVariableAvgAggregateInputType
    _sum?: ProjectVariableSumAggregateInputType
    _min?: ProjectVariableMinAggregateInputType
    _max?: ProjectVariableMaxAggregateInputType
  }

  export type ProjectVariableGroupByOutputType = {
    id: number
    projectId: number
    name: string
    value: string
    description: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectVariableCountAggregateOutputType | null
    _avg: ProjectVariableAvgAggregateOutputType | null
    _sum: ProjectVariableSumAggregateOutputType | null
    _min: ProjectVariableMinAggregateOutputType | null
    _max: ProjectVariableMaxAggregateOutputType | null
  }

  type GetProjectVariableGroupByPayload<T extends ProjectVariableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectVariableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectVariableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectVariableGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectVariableGroupByOutputType[P]>
        }
      >
    >


  export type ProjectVariableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    value?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | ProjectVariable$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["projectVariable"]>

  export type ProjectVariableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    value?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | ProjectVariable$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["projectVariable"]>

  export type ProjectVariableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    value?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | ProjectVariable$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["projectVariable"]>

  export type ProjectVariableSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    value?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectVariableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "value" | "description" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["projectVariable"]>
  export type ProjectVariableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | ProjectVariable$creatorArgs<ExtArgs>
  }
  export type ProjectVariableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | ProjectVariable$creatorArgs<ExtArgs>
  }
  export type ProjectVariableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | ProjectVariable$creatorArgs<ExtArgs>
  }

  export type $ProjectVariablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectVariable"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      name: string
      value: string
      description: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projectVariable"]>
    composites: {}
  }

  type ProjectVariableGetPayload<S extends boolean | null | undefined | ProjectVariableDefaultArgs> = $Result.GetResult<Prisma.$ProjectVariablePayload, S>

  type ProjectVariableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectVariableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectVariableCountAggregateInputType | true
    }

  export interface ProjectVariableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectVariable'], meta: { name: 'ProjectVariable' } }
    /**
     * Find zero or one ProjectVariable that matches the filter.
     * @param {ProjectVariableFindUniqueArgs} args - Arguments to find a ProjectVariable
     * @example
     * // Get one ProjectVariable
     * const projectVariable = await prisma.projectVariable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectVariableFindUniqueArgs>(args: SelectSubset<T, ProjectVariableFindUniqueArgs<ExtArgs>>): Prisma__ProjectVariableClient<$Result.GetResult<Prisma.$ProjectVariablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectVariable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectVariableFindUniqueOrThrowArgs} args - Arguments to find a ProjectVariable
     * @example
     * // Get one ProjectVariable
     * const projectVariable = await prisma.projectVariable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectVariableFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectVariableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectVariableClient<$Result.GetResult<Prisma.$ProjectVariablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectVariable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectVariableFindFirstArgs} args - Arguments to find a ProjectVariable
     * @example
     * // Get one ProjectVariable
     * const projectVariable = await prisma.projectVariable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectVariableFindFirstArgs>(args?: SelectSubset<T, ProjectVariableFindFirstArgs<ExtArgs>>): Prisma__ProjectVariableClient<$Result.GetResult<Prisma.$ProjectVariablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectVariable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectVariableFindFirstOrThrowArgs} args - Arguments to find a ProjectVariable
     * @example
     * // Get one ProjectVariable
     * const projectVariable = await prisma.projectVariable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectVariableFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectVariableFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectVariableClient<$Result.GetResult<Prisma.$ProjectVariablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectVariables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectVariableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectVariables
     * const projectVariables = await prisma.projectVariable.findMany()
     * 
     * // Get first 10 ProjectVariables
     * const projectVariables = await prisma.projectVariable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectVariableWithIdOnly = await prisma.projectVariable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectVariableFindManyArgs>(args?: SelectSubset<T, ProjectVariableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectVariablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectVariable.
     * @param {ProjectVariableCreateArgs} args - Arguments to create a ProjectVariable.
     * @example
     * // Create one ProjectVariable
     * const ProjectVariable = await prisma.projectVariable.create({
     *   data: {
     *     // ... data to create a ProjectVariable
     *   }
     * })
     * 
     */
    create<T extends ProjectVariableCreateArgs>(args: SelectSubset<T, ProjectVariableCreateArgs<ExtArgs>>): Prisma__ProjectVariableClient<$Result.GetResult<Prisma.$ProjectVariablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectVariables.
     * @param {ProjectVariableCreateManyArgs} args - Arguments to create many ProjectVariables.
     * @example
     * // Create many ProjectVariables
     * const projectVariable = await prisma.projectVariable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectVariableCreateManyArgs>(args?: SelectSubset<T, ProjectVariableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectVariables and returns the data saved in the database.
     * @param {ProjectVariableCreateManyAndReturnArgs} args - Arguments to create many ProjectVariables.
     * @example
     * // Create many ProjectVariables
     * const projectVariable = await prisma.projectVariable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectVariables and only return the `id`
     * const projectVariableWithIdOnly = await prisma.projectVariable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectVariableCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectVariableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectVariablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectVariable.
     * @param {ProjectVariableDeleteArgs} args - Arguments to delete one ProjectVariable.
     * @example
     * // Delete one ProjectVariable
     * const ProjectVariable = await prisma.projectVariable.delete({
     *   where: {
     *     // ... filter to delete one ProjectVariable
     *   }
     * })
     * 
     */
    delete<T extends ProjectVariableDeleteArgs>(args: SelectSubset<T, ProjectVariableDeleteArgs<ExtArgs>>): Prisma__ProjectVariableClient<$Result.GetResult<Prisma.$ProjectVariablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectVariable.
     * @param {ProjectVariableUpdateArgs} args - Arguments to update one ProjectVariable.
     * @example
     * // Update one ProjectVariable
     * const projectVariable = await prisma.projectVariable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectVariableUpdateArgs>(args: SelectSubset<T, ProjectVariableUpdateArgs<ExtArgs>>): Prisma__ProjectVariableClient<$Result.GetResult<Prisma.$ProjectVariablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectVariables.
     * @param {ProjectVariableDeleteManyArgs} args - Arguments to filter ProjectVariables to delete.
     * @example
     * // Delete a few ProjectVariables
     * const { count } = await prisma.projectVariable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectVariableDeleteManyArgs>(args?: SelectSubset<T, ProjectVariableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectVariables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectVariableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectVariables
     * const projectVariable = await prisma.projectVariable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectVariableUpdateManyArgs>(args: SelectSubset<T, ProjectVariableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectVariables and returns the data updated in the database.
     * @param {ProjectVariableUpdateManyAndReturnArgs} args - Arguments to update many ProjectVariables.
     * @example
     * // Update many ProjectVariables
     * const projectVariable = await prisma.projectVariable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectVariables and only return the `id`
     * const projectVariableWithIdOnly = await prisma.projectVariable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectVariableUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectVariableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectVariablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectVariable.
     * @param {ProjectVariableUpsertArgs} args - Arguments to update or create a ProjectVariable.
     * @example
     * // Update or create a ProjectVariable
     * const projectVariable = await prisma.projectVariable.upsert({
     *   create: {
     *     // ... data to create a ProjectVariable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectVariable we want to update
     *   }
     * })
     */
    upsert<T extends ProjectVariableUpsertArgs>(args: SelectSubset<T, ProjectVariableUpsertArgs<ExtArgs>>): Prisma__ProjectVariableClient<$Result.GetResult<Prisma.$ProjectVariablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectVariables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectVariableCountArgs} args - Arguments to filter ProjectVariables to count.
     * @example
     * // Count the number of ProjectVariables
     * const count = await prisma.projectVariable.count({
     *   where: {
     *     // ... the filter for the ProjectVariables we want to count
     *   }
     * })
    **/
    count<T extends ProjectVariableCountArgs>(
      args?: Subset<T, ProjectVariableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectVariableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectVariable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectVariableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectVariableAggregateArgs>(args: Subset<T, ProjectVariableAggregateArgs>): Prisma.PrismaPromise<GetProjectVariableAggregateType<T>>

    /**
     * Group by ProjectVariable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectVariableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectVariableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectVariableGroupByArgs['orderBy'] }
        : { orderBy?: ProjectVariableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectVariableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectVariableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectVariable model
   */
  readonly fields: ProjectVariableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectVariable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectVariableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends ProjectVariable$creatorArgs<ExtArgs> = {}>(args?: Subset<T, ProjectVariable$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectVariable model
   */
  interface ProjectVariableFieldRefs {
    readonly id: FieldRef<"ProjectVariable", 'Int'>
    readonly projectId: FieldRef<"ProjectVariable", 'Int'>
    readonly name: FieldRef<"ProjectVariable", 'String'>
    readonly value: FieldRef<"ProjectVariable", 'String'>
    readonly description: FieldRef<"ProjectVariable", 'String'>
    readonly createdBy: FieldRef<"ProjectVariable", 'String'>
    readonly createdAt: FieldRef<"ProjectVariable", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectVariable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectVariable findUnique
   */
  export type ProjectVariableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectVariable
     */
    select?: ProjectVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectVariable
     */
    omit?: ProjectVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectVariableInclude<ExtArgs> | null
    /**
     * Filter, which ProjectVariable to fetch.
     */
    where: ProjectVariableWhereUniqueInput
  }

  /**
   * ProjectVariable findUniqueOrThrow
   */
  export type ProjectVariableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectVariable
     */
    select?: ProjectVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectVariable
     */
    omit?: ProjectVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectVariableInclude<ExtArgs> | null
    /**
     * Filter, which ProjectVariable to fetch.
     */
    where: ProjectVariableWhereUniqueInput
  }

  /**
   * ProjectVariable findFirst
   */
  export type ProjectVariableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectVariable
     */
    select?: ProjectVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectVariable
     */
    omit?: ProjectVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectVariableInclude<ExtArgs> | null
    /**
     * Filter, which ProjectVariable to fetch.
     */
    where?: ProjectVariableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectVariables to fetch.
     */
    orderBy?: ProjectVariableOrderByWithRelationInput | ProjectVariableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectVariables.
     */
    cursor?: ProjectVariableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectVariables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectVariables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectVariables.
     */
    distinct?: ProjectVariableScalarFieldEnum | ProjectVariableScalarFieldEnum[]
  }

  /**
   * ProjectVariable findFirstOrThrow
   */
  export type ProjectVariableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectVariable
     */
    select?: ProjectVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectVariable
     */
    omit?: ProjectVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectVariableInclude<ExtArgs> | null
    /**
     * Filter, which ProjectVariable to fetch.
     */
    where?: ProjectVariableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectVariables to fetch.
     */
    orderBy?: ProjectVariableOrderByWithRelationInput | ProjectVariableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectVariables.
     */
    cursor?: ProjectVariableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectVariables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectVariables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectVariables.
     */
    distinct?: ProjectVariableScalarFieldEnum | ProjectVariableScalarFieldEnum[]
  }

  /**
   * ProjectVariable findMany
   */
  export type ProjectVariableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectVariable
     */
    select?: ProjectVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectVariable
     */
    omit?: ProjectVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectVariableInclude<ExtArgs> | null
    /**
     * Filter, which ProjectVariables to fetch.
     */
    where?: ProjectVariableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectVariables to fetch.
     */
    orderBy?: ProjectVariableOrderByWithRelationInput | ProjectVariableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectVariables.
     */
    cursor?: ProjectVariableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectVariables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectVariables.
     */
    skip?: number
    distinct?: ProjectVariableScalarFieldEnum | ProjectVariableScalarFieldEnum[]
  }

  /**
   * ProjectVariable create
   */
  export type ProjectVariableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectVariable
     */
    select?: ProjectVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectVariable
     */
    omit?: ProjectVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectVariableInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectVariable.
     */
    data: XOR<ProjectVariableCreateInput, ProjectVariableUncheckedCreateInput>
  }

  /**
   * ProjectVariable createMany
   */
  export type ProjectVariableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectVariables.
     */
    data: ProjectVariableCreateManyInput | ProjectVariableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectVariable createManyAndReturn
   */
  export type ProjectVariableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectVariable
     */
    select?: ProjectVariableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectVariable
     */
    omit?: ProjectVariableOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectVariables.
     */
    data: ProjectVariableCreateManyInput | ProjectVariableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectVariableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectVariable update
   */
  export type ProjectVariableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectVariable
     */
    select?: ProjectVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectVariable
     */
    omit?: ProjectVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectVariableInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectVariable.
     */
    data: XOR<ProjectVariableUpdateInput, ProjectVariableUncheckedUpdateInput>
    /**
     * Choose, which ProjectVariable to update.
     */
    where: ProjectVariableWhereUniqueInput
  }

  /**
   * ProjectVariable updateMany
   */
  export type ProjectVariableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectVariables.
     */
    data: XOR<ProjectVariableUpdateManyMutationInput, ProjectVariableUncheckedUpdateManyInput>
    /**
     * Filter which ProjectVariables to update
     */
    where?: ProjectVariableWhereInput
    /**
     * Limit how many ProjectVariables to update.
     */
    limit?: number
  }

  /**
   * ProjectVariable updateManyAndReturn
   */
  export type ProjectVariableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectVariable
     */
    select?: ProjectVariableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectVariable
     */
    omit?: ProjectVariableOmit<ExtArgs> | null
    /**
     * The data used to update ProjectVariables.
     */
    data: XOR<ProjectVariableUpdateManyMutationInput, ProjectVariableUncheckedUpdateManyInput>
    /**
     * Filter which ProjectVariables to update
     */
    where?: ProjectVariableWhereInput
    /**
     * Limit how many ProjectVariables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectVariableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectVariable upsert
   */
  export type ProjectVariableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectVariable
     */
    select?: ProjectVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectVariable
     */
    omit?: ProjectVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectVariableInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectVariable to update in case it exists.
     */
    where: ProjectVariableWhereUniqueInput
    /**
     * In case the ProjectVariable found by the `where` argument doesn't exist, create a new ProjectVariable with this data.
     */
    create: XOR<ProjectVariableCreateInput, ProjectVariableUncheckedCreateInput>
    /**
     * In case the ProjectVariable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectVariableUpdateInput, ProjectVariableUncheckedUpdateInput>
  }

  /**
   * ProjectVariable delete
   */
  export type ProjectVariableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectVariable
     */
    select?: ProjectVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectVariable
     */
    omit?: ProjectVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectVariableInclude<ExtArgs> | null
    /**
     * Filter which ProjectVariable to delete.
     */
    where: ProjectVariableWhereUniqueInput
  }

  /**
   * ProjectVariable deleteMany
   */
  export type ProjectVariableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectVariables to delete
     */
    where?: ProjectVariableWhereInput
    /**
     * Limit how many ProjectVariables to delete.
     */
    limit?: number
  }

  /**
   * ProjectVariable.creator
   */
  export type ProjectVariable$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ProjectVariable without action
   */
  export type ProjectVariableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectVariable
     */
    select?: ProjectVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectVariable
     */
    omit?: ProjectVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectVariableInclude<ExtArgs> | null
  }


  /**
   * Model TestSuiteVariable
   */

  export type AggregateTestSuiteVariable = {
    _count: TestSuiteVariableCountAggregateOutputType | null
    _avg: TestSuiteVariableAvgAggregateOutputType | null
    _sum: TestSuiteVariableSumAggregateOutputType | null
    _min: TestSuiteVariableMinAggregateOutputType | null
    _max: TestSuiteVariableMaxAggregateOutputType | null
  }

  export type TestSuiteVariableAvgAggregateOutputType = {
    id: number | null
    testSuiteId: number | null
  }

  export type TestSuiteVariableSumAggregateOutputType = {
    id: number | null
    testSuiteId: number | null
  }

  export type TestSuiteVariableMinAggregateOutputType = {
    id: number | null
    testSuiteId: number | null
    name: string | null
    value: string | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestSuiteVariableMaxAggregateOutputType = {
    id: number | null
    testSuiteId: number | null
    name: string | null
    value: string | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestSuiteVariableCountAggregateOutputType = {
    id: number
    testSuiteId: number
    name: number
    value: number
    description: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TestSuiteVariableAvgAggregateInputType = {
    id?: true
    testSuiteId?: true
  }

  export type TestSuiteVariableSumAggregateInputType = {
    id?: true
    testSuiteId?: true
  }

  export type TestSuiteVariableMinAggregateInputType = {
    id?: true
    testSuiteId?: true
    name?: true
    value?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestSuiteVariableMaxAggregateInputType = {
    id?: true
    testSuiteId?: true
    name?: true
    value?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestSuiteVariableCountAggregateInputType = {
    id?: true
    testSuiteId?: true
    name?: true
    value?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestSuiteVariableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestSuiteVariable to aggregate.
     */
    where?: TestSuiteVariableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestSuiteVariables to fetch.
     */
    orderBy?: TestSuiteVariableOrderByWithRelationInput | TestSuiteVariableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestSuiteVariableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestSuiteVariables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestSuiteVariables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestSuiteVariables
    **/
    _count?: true | TestSuiteVariableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestSuiteVariableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestSuiteVariableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestSuiteVariableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestSuiteVariableMaxAggregateInputType
  }

  export type GetTestSuiteVariableAggregateType<T extends TestSuiteVariableAggregateArgs> = {
        [P in keyof T & keyof AggregateTestSuiteVariable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestSuiteVariable[P]>
      : GetScalarType<T[P], AggregateTestSuiteVariable[P]>
  }




  export type TestSuiteVariableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestSuiteVariableWhereInput
    orderBy?: TestSuiteVariableOrderByWithAggregationInput | TestSuiteVariableOrderByWithAggregationInput[]
    by: TestSuiteVariableScalarFieldEnum[] | TestSuiteVariableScalarFieldEnum
    having?: TestSuiteVariableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestSuiteVariableCountAggregateInputType | true
    _avg?: TestSuiteVariableAvgAggregateInputType
    _sum?: TestSuiteVariableSumAggregateInputType
    _min?: TestSuiteVariableMinAggregateInputType
    _max?: TestSuiteVariableMaxAggregateInputType
  }

  export type TestSuiteVariableGroupByOutputType = {
    id: number
    testSuiteId: number
    name: string
    value: string
    description: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: TestSuiteVariableCountAggregateOutputType | null
    _avg: TestSuiteVariableAvgAggregateOutputType | null
    _sum: TestSuiteVariableSumAggregateOutputType | null
    _min: TestSuiteVariableMinAggregateOutputType | null
    _max: TestSuiteVariableMaxAggregateOutputType | null
  }

  type GetTestSuiteVariableGroupByPayload<T extends TestSuiteVariableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestSuiteVariableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestSuiteVariableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestSuiteVariableGroupByOutputType[P]>
            : GetScalarType<T[P], TestSuiteVariableGroupByOutputType[P]>
        }
      >
    >


  export type TestSuiteVariableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testSuiteId?: boolean
    name?: boolean
    value?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testSuite?: boolean | TestSuitesDefaultArgs<ExtArgs>
    creator?: boolean | TestSuiteVariable$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["testSuiteVariable"]>

  export type TestSuiteVariableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testSuiteId?: boolean
    name?: boolean
    value?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testSuite?: boolean | TestSuitesDefaultArgs<ExtArgs>
    creator?: boolean | TestSuiteVariable$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["testSuiteVariable"]>

  export type TestSuiteVariableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testSuiteId?: boolean
    name?: boolean
    value?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testSuite?: boolean | TestSuitesDefaultArgs<ExtArgs>
    creator?: boolean | TestSuiteVariable$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["testSuiteVariable"]>

  export type TestSuiteVariableSelectScalar = {
    id?: boolean
    testSuiteId?: boolean
    name?: boolean
    value?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TestSuiteVariableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "testSuiteId" | "name" | "value" | "description" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["testSuiteVariable"]>
  export type TestSuiteVariableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testSuite?: boolean | TestSuitesDefaultArgs<ExtArgs>
    creator?: boolean | TestSuiteVariable$creatorArgs<ExtArgs>
  }
  export type TestSuiteVariableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testSuite?: boolean | TestSuitesDefaultArgs<ExtArgs>
    creator?: boolean | TestSuiteVariable$creatorArgs<ExtArgs>
  }
  export type TestSuiteVariableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testSuite?: boolean | TestSuitesDefaultArgs<ExtArgs>
    creator?: boolean | TestSuiteVariable$creatorArgs<ExtArgs>
  }

  export type $TestSuiteVariablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestSuiteVariable"
    objects: {
      testSuite: Prisma.$TestSuitesPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      testSuiteId: number
      name: string
      value: string
      description: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testSuiteVariable"]>
    composites: {}
  }

  type TestSuiteVariableGetPayload<S extends boolean | null | undefined | TestSuiteVariableDefaultArgs> = $Result.GetResult<Prisma.$TestSuiteVariablePayload, S>

  type TestSuiteVariableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestSuiteVariableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestSuiteVariableCountAggregateInputType | true
    }

  export interface TestSuiteVariableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestSuiteVariable'], meta: { name: 'TestSuiteVariable' } }
    /**
     * Find zero or one TestSuiteVariable that matches the filter.
     * @param {TestSuiteVariableFindUniqueArgs} args - Arguments to find a TestSuiteVariable
     * @example
     * // Get one TestSuiteVariable
     * const testSuiteVariable = await prisma.testSuiteVariable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestSuiteVariableFindUniqueArgs>(args: SelectSubset<T, TestSuiteVariableFindUniqueArgs<ExtArgs>>): Prisma__TestSuiteVariableClient<$Result.GetResult<Prisma.$TestSuiteVariablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestSuiteVariable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestSuiteVariableFindUniqueOrThrowArgs} args - Arguments to find a TestSuiteVariable
     * @example
     * // Get one TestSuiteVariable
     * const testSuiteVariable = await prisma.testSuiteVariable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestSuiteVariableFindUniqueOrThrowArgs>(args: SelectSubset<T, TestSuiteVariableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestSuiteVariableClient<$Result.GetResult<Prisma.$TestSuiteVariablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestSuiteVariable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestSuiteVariableFindFirstArgs} args - Arguments to find a TestSuiteVariable
     * @example
     * // Get one TestSuiteVariable
     * const testSuiteVariable = await prisma.testSuiteVariable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestSuiteVariableFindFirstArgs>(args?: SelectSubset<T, TestSuiteVariableFindFirstArgs<ExtArgs>>): Prisma__TestSuiteVariableClient<$Result.GetResult<Prisma.$TestSuiteVariablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestSuiteVariable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestSuiteVariableFindFirstOrThrowArgs} args - Arguments to find a TestSuiteVariable
     * @example
     * // Get one TestSuiteVariable
     * const testSuiteVariable = await prisma.testSuiteVariable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestSuiteVariableFindFirstOrThrowArgs>(args?: SelectSubset<T, TestSuiteVariableFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestSuiteVariableClient<$Result.GetResult<Prisma.$TestSuiteVariablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestSuiteVariables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestSuiteVariableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestSuiteVariables
     * const testSuiteVariables = await prisma.testSuiteVariable.findMany()
     * 
     * // Get first 10 TestSuiteVariables
     * const testSuiteVariables = await prisma.testSuiteVariable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testSuiteVariableWithIdOnly = await prisma.testSuiteVariable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestSuiteVariableFindManyArgs>(args?: SelectSubset<T, TestSuiteVariableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestSuiteVariablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestSuiteVariable.
     * @param {TestSuiteVariableCreateArgs} args - Arguments to create a TestSuiteVariable.
     * @example
     * // Create one TestSuiteVariable
     * const TestSuiteVariable = await prisma.testSuiteVariable.create({
     *   data: {
     *     // ... data to create a TestSuiteVariable
     *   }
     * })
     * 
     */
    create<T extends TestSuiteVariableCreateArgs>(args: SelectSubset<T, TestSuiteVariableCreateArgs<ExtArgs>>): Prisma__TestSuiteVariableClient<$Result.GetResult<Prisma.$TestSuiteVariablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestSuiteVariables.
     * @param {TestSuiteVariableCreateManyArgs} args - Arguments to create many TestSuiteVariables.
     * @example
     * // Create many TestSuiteVariables
     * const testSuiteVariable = await prisma.testSuiteVariable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestSuiteVariableCreateManyArgs>(args?: SelectSubset<T, TestSuiteVariableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestSuiteVariables and returns the data saved in the database.
     * @param {TestSuiteVariableCreateManyAndReturnArgs} args - Arguments to create many TestSuiteVariables.
     * @example
     * // Create many TestSuiteVariables
     * const testSuiteVariable = await prisma.testSuiteVariable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestSuiteVariables and only return the `id`
     * const testSuiteVariableWithIdOnly = await prisma.testSuiteVariable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestSuiteVariableCreateManyAndReturnArgs>(args?: SelectSubset<T, TestSuiteVariableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestSuiteVariablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TestSuiteVariable.
     * @param {TestSuiteVariableDeleteArgs} args - Arguments to delete one TestSuiteVariable.
     * @example
     * // Delete one TestSuiteVariable
     * const TestSuiteVariable = await prisma.testSuiteVariable.delete({
     *   where: {
     *     // ... filter to delete one TestSuiteVariable
     *   }
     * })
     * 
     */
    delete<T extends TestSuiteVariableDeleteArgs>(args: SelectSubset<T, TestSuiteVariableDeleteArgs<ExtArgs>>): Prisma__TestSuiteVariableClient<$Result.GetResult<Prisma.$TestSuiteVariablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestSuiteVariable.
     * @param {TestSuiteVariableUpdateArgs} args - Arguments to update one TestSuiteVariable.
     * @example
     * // Update one TestSuiteVariable
     * const testSuiteVariable = await prisma.testSuiteVariable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestSuiteVariableUpdateArgs>(args: SelectSubset<T, TestSuiteVariableUpdateArgs<ExtArgs>>): Prisma__TestSuiteVariableClient<$Result.GetResult<Prisma.$TestSuiteVariablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestSuiteVariables.
     * @param {TestSuiteVariableDeleteManyArgs} args - Arguments to filter TestSuiteVariables to delete.
     * @example
     * // Delete a few TestSuiteVariables
     * const { count } = await prisma.testSuiteVariable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestSuiteVariableDeleteManyArgs>(args?: SelectSubset<T, TestSuiteVariableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestSuiteVariables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestSuiteVariableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestSuiteVariables
     * const testSuiteVariable = await prisma.testSuiteVariable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestSuiteVariableUpdateManyArgs>(args: SelectSubset<T, TestSuiteVariableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestSuiteVariables and returns the data updated in the database.
     * @param {TestSuiteVariableUpdateManyAndReturnArgs} args - Arguments to update many TestSuiteVariables.
     * @example
     * // Update many TestSuiteVariables
     * const testSuiteVariable = await prisma.testSuiteVariable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TestSuiteVariables and only return the `id`
     * const testSuiteVariableWithIdOnly = await prisma.testSuiteVariable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestSuiteVariableUpdateManyAndReturnArgs>(args: SelectSubset<T, TestSuiteVariableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestSuiteVariablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TestSuiteVariable.
     * @param {TestSuiteVariableUpsertArgs} args - Arguments to update or create a TestSuiteVariable.
     * @example
     * // Update or create a TestSuiteVariable
     * const testSuiteVariable = await prisma.testSuiteVariable.upsert({
     *   create: {
     *     // ... data to create a TestSuiteVariable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestSuiteVariable we want to update
     *   }
     * })
     */
    upsert<T extends TestSuiteVariableUpsertArgs>(args: SelectSubset<T, TestSuiteVariableUpsertArgs<ExtArgs>>): Prisma__TestSuiteVariableClient<$Result.GetResult<Prisma.$TestSuiteVariablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestSuiteVariables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestSuiteVariableCountArgs} args - Arguments to filter TestSuiteVariables to count.
     * @example
     * // Count the number of TestSuiteVariables
     * const count = await prisma.testSuiteVariable.count({
     *   where: {
     *     // ... the filter for the TestSuiteVariables we want to count
     *   }
     * })
    **/
    count<T extends TestSuiteVariableCountArgs>(
      args?: Subset<T, TestSuiteVariableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestSuiteVariableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestSuiteVariable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestSuiteVariableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestSuiteVariableAggregateArgs>(args: Subset<T, TestSuiteVariableAggregateArgs>): Prisma.PrismaPromise<GetTestSuiteVariableAggregateType<T>>

    /**
     * Group by TestSuiteVariable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestSuiteVariableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestSuiteVariableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestSuiteVariableGroupByArgs['orderBy'] }
        : { orderBy?: TestSuiteVariableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestSuiteVariableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestSuiteVariableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestSuiteVariable model
   */
  readonly fields: TestSuiteVariableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestSuiteVariable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestSuiteVariableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    testSuite<T extends TestSuitesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestSuitesDefaultArgs<ExtArgs>>): Prisma__TestSuitesClient<$Result.GetResult<Prisma.$TestSuitesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends TestSuiteVariable$creatorArgs<ExtArgs> = {}>(args?: Subset<T, TestSuiteVariable$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestSuiteVariable model
   */
  interface TestSuiteVariableFieldRefs {
    readonly id: FieldRef<"TestSuiteVariable", 'Int'>
    readonly testSuiteId: FieldRef<"TestSuiteVariable", 'Int'>
    readonly name: FieldRef<"TestSuiteVariable", 'String'>
    readonly value: FieldRef<"TestSuiteVariable", 'String'>
    readonly description: FieldRef<"TestSuiteVariable", 'String'>
    readonly createdBy: FieldRef<"TestSuiteVariable", 'String'>
    readonly createdAt: FieldRef<"TestSuiteVariable", 'DateTime'>
    readonly updatedAt: FieldRef<"TestSuiteVariable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TestSuiteVariable findUnique
   */
  export type TestSuiteVariableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteVariable
     */
    select?: TestSuiteVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteVariable
     */
    omit?: TestSuiteVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteVariableInclude<ExtArgs> | null
    /**
     * Filter, which TestSuiteVariable to fetch.
     */
    where: TestSuiteVariableWhereUniqueInput
  }

  /**
   * TestSuiteVariable findUniqueOrThrow
   */
  export type TestSuiteVariableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteVariable
     */
    select?: TestSuiteVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteVariable
     */
    omit?: TestSuiteVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteVariableInclude<ExtArgs> | null
    /**
     * Filter, which TestSuiteVariable to fetch.
     */
    where: TestSuiteVariableWhereUniqueInput
  }

  /**
   * TestSuiteVariable findFirst
   */
  export type TestSuiteVariableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteVariable
     */
    select?: TestSuiteVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteVariable
     */
    omit?: TestSuiteVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteVariableInclude<ExtArgs> | null
    /**
     * Filter, which TestSuiteVariable to fetch.
     */
    where?: TestSuiteVariableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestSuiteVariables to fetch.
     */
    orderBy?: TestSuiteVariableOrderByWithRelationInput | TestSuiteVariableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestSuiteVariables.
     */
    cursor?: TestSuiteVariableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestSuiteVariables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestSuiteVariables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestSuiteVariables.
     */
    distinct?: TestSuiteVariableScalarFieldEnum | TestSuiteVariableScalarFieldEnum[]
  }

  /**
   * TestSuiteVariable findFirstOrThrow
   */
  export type TestSuiteVariableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteVariable
     */
    select?: TestSuiteVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteVariable
     */
    omit?: TestSuiteVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteVariableInclude<ExtArgs> | null
    /**
     * Filter, which TestSuiteVariable to fetch.
     */
    where?: TestSuiteVariableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestSuiteVariables to fetch.
     */
    orderBy?: TestSuiteVariableOrderByWithRelationInput | TestSuiteVariableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestSuiteVariables.
     */
    cursor?: TestSuiteVariableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestSuiteVariables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestSuiteVariables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestSuiteVariables.
     */
    distinct?: TestSuiteVariableScalarFieldEnum | TestSuiteVariableScalarFieldEnum[]
  }

  /**
   * TestSuiteVariable findMany
   */
  export type TestSuiteVariableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteVariable
     */
    select?: TestSuiteVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteVariable
     */
    omit?: TestSuiteVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteVariableInclude<ExtArgs> | null
    /**
     * Filter, which TestSuiteVariables to fetch.
     */
    where?: TestSuiteVariableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestSuiteVariables to fetch.
     */
    orderBy?: TestSuiteVariableOrderByWithRelationInput | TestSuiteVariableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestSuiteVariables.
     */
    cursor?: TestSuiteVariableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestSuiteVariables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestSuiteVariables.
     */
    skip?: number
    distinct?: TestSuiteVariableScalarFieldEnum | TestSuiteVariableScalarFieldEnum[]
  }

  /**
   * TestSuiteVariable create
   */
  export type TestSuiteVariableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteVariable
     */
    select?: TestSuiteVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteVariable
     */
    omit?: TestSuiteVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteVariableInclude<ExtArgs> | null
    /**
     * The data needed to create a TestSuiteVariable.
     */
    data: XOR<TestSuiteVariableCreateInput, TestSuiteVariableUncheckedCreateInput>
  }

  /**
   * TestSuiteVariable createMany
   */
  export type TestSuiteVariableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestSuiteVariables.
     */
    data: TestSuiteVariableCreateManyInput | TestSuiteVariableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestSuiteVariable createManyAndReturn
   */
  export type TestSuiteVariableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteVariable
     */
    select?: TestSuiteVariableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteVariable
     */
    omit?: TestSuiteVariableOmit<ExtArgs> | null
    /**
     * The data used to create many TestSuiteVariables.
     */
    data: TestSuiteVariableCreateManyInput | TestSuiteVariableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteVariableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestSuiteVariable update
   */
  export type TestSuiteVariableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteVariable
     */
    select?: TestSuiteVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteVariable
     */
    omit?: TestSuiteVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteVariableInclude<ExtArgs> | null
    /**
     * The data needed to update a TestSuiteVariable.
     */
    data: XOR<TestSuiteVariableUpdateInput, TestSuiteVariableUncheckedUpdateInput>
    /**
     * Choose, which TestSuiteVariable to update.
     */
    where: TestSuiteVariableWhereUniqueInput
  }

  /**
   * TestSuiteVariable updateMany
   */
  export type TestSuiteVariableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestSuiteVariables.
     */
    data: XOR<TestSuiteVariableUpdateManyMutationInput, TestSuiteVariableUncheckedUpdateManyInput>
    /**
     * Filter which TestSuiteVariables to update
     */
    where?: TestSuiteVariableWhereInput
    /**
     * Limit how many TestSuiteVariables to update.
     */
    limit?: number
  }

  /**
   * TestSuiteVariable updateManyAndReturn
   */
  export type TestSuiteVariableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteVariable
     */
    select?: TestSuiteVariableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteVariable
     */
    omit?: TestSuiteVariableOmit<ExtArgs> | null
    /**
     * The data used to update TestSuiteVariables.
     */
    data: XOR<TestSuiteVariableUpdateManyMutationInput, TestSuiteVariableUncheckedUpdateManyInput>
    /**
     * Filter which TestSuiteVariables to update
     */
    where?: TestSuiteVariableWhereInput
    /**
     * Limit how many TestSuiteVariables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteVariableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestSuiteVariable upsert
   */
  export type TestSuiteVariableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteVariable
     */
    select?: TestSuiteVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteVariable
     */
    omit?: TestSuiteVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteVariableInclude<ExtArgs> | null
    /**
     * The filter to search for the TestSuiteVariable to update in case it exists.
     */
    where: TestSuiteVariableWhereUniqueInput
    /**
     * In case the TestSuiteVariable found by the `where` argument doesn't exist, create a new TestSuiteVariable with this data.
     */
    create: XOR<TestSuiteVariableCreateInput, TestSuiteVariableUncheckedCreateInput>
    /**
     * In case the TestSuiteVariable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestSuiteVariableUpdateInput, TestSuiteVariableUncheckedUpdateInput>
  }

  /**
   * TestSuiteVariable delete
   */
  export type TestSuiteVariableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteVariable
     */
    select?: TestSuiteVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteVariable
     */
    omit?: TestSuiteVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteVariableInclude<ExtArgs> | null
    /**
     * Filter which TestSuiteVariable to delete.
     */
    where: TestSuiteVariableWhereUniqueInput
  }

  /**
   * TestSuiteVariable deleteMany
   */
  export type TestSuiteVariableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestSuiteVariables to delete
     */
    where?: TestSuiteVariableWhereInput
    /**
     * Limit how many TestSuiteVariables to delete.
     */
    limit?: number
  }

  /**
   * TestSuiteVariable.creator
   */
  export type TestSuiteVariable$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TestSuiteVariable without action
   */
  export type TestSuiteVariableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteVariable
     */
    select?: TestSuiteVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteVariable
     */
    omit?: TestSuiteVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteVariableInclude<ExtArgs> | null
  }


  /**
   * Model ProjectFunction
   */

  export type AggregateProjectFunction = {
    _count: ProjectFunctionCountAggregateOutputType | null
    _avg: ProjectFunctionAvgAggregateOutputType | null
    _sum: ProjectFunctionSumAggregateOutputType | null
    _min: ProjectFunctionMinAggregateOutputType | null
    _max: ProjectFunctionMaxAggregateOutputType | null
  }

  export type ProjectFunctionAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ProjectFunctionSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ProjectFunctionMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    code: string | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectFunctionMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    code: string | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectFunctionCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    code: number
    description: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectFunctionAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ProjectFunctionSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ProjectFunctionMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    code?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectFunctionMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    code?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectFunctionCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    code?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectFunctionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectFunction to aggregate.
     */
    where?: ProjectFunctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectFunctions to fetch.
     */
    orderBy?: ProjectFunctionOrderByWithRelationInput | ProjectFunctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectFunctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectFunctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectFunctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectFunctions
    **/
    _count?: true | ProjectFunctionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectFunctionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectFunctionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectFunctionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectFunctionMaxAggregateInputType
  }

  export type GetProjectFunctionAggregateType<T extends ProjectFunctionAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectFunction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectFunction[P]>
      : GetScalarType<T[P], AggregateProjectFunction[P]>
  }




  export type ProjectFunctionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectFunctionWhereInput
    orderBy?: ProjectFunctionOrderByWithAggregationInput | ProjectFunctionOrderByWithAggregationInput[]
    by: ProjectFunctionScalarFieldEnum[] | ProjectFunctionScalarFieldEnum
    having?: ProjectFunctionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectFunctionCountAggregateInputType | true
    _avg?: ProjectFunctionAvgAggregateInputType
    _sum?: ProjectFunctionSumAggregateInputType
    _min?: ProjectFunctionMinAggregateInputType
    _max?: ProjectFunctionMaxAggregateInputType
  }

  export type ProjectFunctionGroupByOutputType = {
    id: number
    projectId: number
    name: string
    code: string
    description: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectFunctionCountAggregateOutputType | null
    _avg: ProjectFunctionAvgAggregateOutputType | null
    _sum: ProjectFunctionSumAggregateOutputType | null
    _min: ProjectFunctionMinAggregateOutputType | null
    _max: ProjectFunctionMaxAggregateOutputType | null
  }

  type GetProjectFunctionGroupByPayload<T extends ProjectFunctionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectFunctionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectFunctionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectFunctionGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectFunctionGroupByOutputType[P]>
        }
      >
    >


  export type ProjectFunctionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | ProjectFunction$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["projectFunction"]>

  export type ProjectFunctionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | ProjectFunction$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["projectFunction"]>

  export type ProjectFunctionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | ProjectFunction$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["projectFunction"]>

  export type ProjectFunctionSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectFunctionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "code" | "description" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["projectFunction"]>
  export type ProjectFunctionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | ProjectFunction$creatorArgs<ExtArgs>
  }
  export type ProjectFunctionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | ProjectFunction$creatorArgs<ExtArgs>
  }
  export type ProjectFunctionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | ProjectFunction$creatorArgs<ExtArgs>
  }

  export type $ProjectFunctionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectFunction"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      name: string
      code: string
      description: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projectFunction"]>
    composites: {}
  }

  type ProjectFunctionGetPayload<S extends boolean | null | undefined | ProjectFunctionDefaultArgs> = $Result.GetResult<Prisma.$ProjectFunctionPayload, S>

  type ProjectFunctionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFunctionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectFunctionCountAggregateInputType | true
    }

  export interface ProjectFunctionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectFunction'], meta: { name: 'ProjectFunction' } }
    /**
     * Find zero or one ProjectFunction that matches the filter.
     * @param {ProjectFunctionFindUniqueArgs} args - Arguments to find a ProjectFunction
     * @example
     * // Get one ProjectFunction
     * const projectFunction = await prisma.projectFunction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFunctionFindUniqueArgs>(args: SelectSubset<T, ProjectFunctionFindUniqueArgs<ExtArgs>>): Prisma__ProjectFunctionClient<$Result.GetResult<Prisma.$ProjectFunctionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectFunction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFunctionFindUniqueOrThrowArgs} args - Arguments to find a ProjectFunction
     * @example
     * // Get one ProjectFunction
     * const projectFunction = await prisma.projectFunction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFunctionFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFunctionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectFunctionClient<$Result.GetResult<Prisma.$ProjectFunctionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectFunction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFunctionFindFirstArgs} args - Arguments to find a ProjectFunction
     * @example
     * // Get one ProjectFunction
     * const projectFunction = await prisma.projectFunction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFunctionFindFirstArgs>(args?: SelectSubset<T, ProjectFunctionFindFirstArgs<ExtArgs>>): Prisma__ProjectFunctionClient<$Result.GetResult<Prisma.$ProjectFunctionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectFunction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFunctionFindFirstOrThrowArgs} args - Arguments to find a ProjectFunction
     * @example
     * // Get one ProjectFunction
     * const projectFunction = await prisma.projectFunction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFunctionFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFunctionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectFunctionClient<$Result.GetResult<Prisma.$ProjectFunctionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectFunctions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFunctionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectFunctions
     * const projectFunctions = await prisma.projectFunction.findMany()
     * 
     * // Get first 10 ProjectFunctions
     * const projectFunctions = await prisma.projectFunction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectFunctionWithIdOnly = await prisma.projectFunction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFunctionFindManyArgs>(args?: SelectSubset<T, ProjectFunctionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectFunctionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectFunction.
     * @param {ProjectFunctionCreateArgs} args - Arguments to create a ProjectFunction.
     * @example
     * // Create one ProjectFunction
     * const ProjectFunction = await prisma.projectFunction.create({
     *   data: {
     *     // ... data to create a ProjectFunction
     *   }
     * })
     * 
     */
    create<T extends ProjectFunctionCreateArgs>(args: SelectSubset<T, ProjectFunctionCreateArgs<ExtArgs>>): Prisma__ProjectFunctionClient<$Result.GetResult<Prisma.$ProjectFunctionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectFunctions.
     * @param {ProjectFunctionCreateManyArgs} args - Arguments to create many ProjectFunctions.
     * @example
     * // Create many ProjectFunctions
     * const projectFunction = await prisma.projectFunction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectFunctionCreateManyArgs>(args?: SelectSubset<T, ProjectFunctionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectFunctions and returns the data saved in the database.
     * @param {ProjectFunctionCreateManyAndReturnArgs} args - Arguments to create many ProjectFunctions.
     * @example
     * // Create many ProjectFunctions
     * const projectFunction = await prisma.projectFunction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectFunctions and only return the `id`
     * const projectFunctionWithIdOnly = await prisma.projectFunction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectFunctionCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectFunctionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectFunctionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectFunction.
     * @param {ProjectFunctionDeleteArgs} args - Arguments to delete one ProjectFunction.
     * @example
     * // Delete one ProjectFunction
     * const ProjectFunction = await prisma.projectFunction.delete({
     *   where: {
     *     // ... filter to delete one ProjectFunction
     *   }
     * })
     * 
     */
    delete<T extends ProjectFunctionDeleteArgs>(args: SelectSubset<T, ProjectFunctionDeleteArgs<ExtArgs>>): Prisma__ProjectFunctionClient<$Result.GetResult<Prisma.$ProjectFunctionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectFunction.
     * @param {ProjectFunctionUpdateArgs} args - Arguments to update one ProjectFunction.
     * @example
     * // Update one ProjectFunction
     * const projectFunction = await prisma.projectFunction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectFunctionUpdateArgs>(args: SelectSubset<T, ProjectFunctionUpdateArgs<ExtArgs>>): Prisma__ProjectFunctionClient<$Result.GetResult<Prisma.$ProjectFunctionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectFunctions.
     * @param {ProjectFunctionDeleteManyArgs} args - Arguments to filter ProjectFunctions to delete.
     * @example
     * // Delete a few ProjectFunctions
     * const { count } = await prisma.projectFunction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectFunctionDeleteManyArgs>(args?: SelectSubset<T, ProjectFunctionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectFunctions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFunctionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectFunctions
     * const projectFunction = await prisma.projectFunction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectFunctionUpdateManyArgs>(args: SelectSubset<T, ProjectFunctionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectFunctions and returns the data updated in the database.
     * @param {ProjectFunctionUpdateManyAndReturnArgs} args - Arguments to update many ProjectFunctions.
     * @example
     * // Update many ProjectFunctions
     * const projectFunction = await prisma.projectFunction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectFunctions and only return the `id`
     * const projectFunctionWithIdOnly = await prisma.projectFunction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectFunctionUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectFunctionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectFunctionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectFunction.
     * @param {ProjectFunctionUpsertArgs} args - Arguments to update or create a ProjectFunction.
     * @example
     * // Update or create a ProjectFunction
     * const projectFunction = await prisma.projectFunction.upsert({
     *   create: {
     *     // ... data to create a ProjectFunction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectFunction we want to update
     *   }
     * })
     */
    upsert<T extends ProjectFunctionUpsertArgs>(args: SelectSubset<T, ProjectFunctionUpsertArgs<ExtArgs>>): Prisma__ProjectFunctionClient<$Result.GetResult<Prisma.$ProjectFunctionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectFunctions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFunctionCountArgs} args - Arguments to filter ProjectFunctions to count.
     * @example
     * // Count the number of ProjectFunctions
     * const count = await prisma.projectFunction.count({
     *   where: {
     *     // ... the filter for the ProjectFunctions we want to count
     *   }
     * })
    **/
    count<T extends ProjectFunctionCountArgs>(
      args?: Subset<T, ProjectFunctionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectFunctionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectFunction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFunctionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectFunctionAggregateArgs>(args: Subset<T, ProjectFunctionAggregateArgs>): Prisma.PrismaPromise<GetProjectFunctionAggregateType<T>>

    /**
     * Group by ProjectFunction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFunctionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectFunctionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectFunctionGroupByArgs['orderBy'] }
        : { orderBy?: ProjectFunctionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectFunctionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectFunctionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectFunction model
   */
  readonly fields: ProjectFunctionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectFunction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectFunctionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends ProjectFunction$creatorArgs<ExtArgs> = {}>(args?: Subset<T, ProjectFunction$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectFunction model
   */
  interface ProjectFunctionFieldRefs {
    readonly id: FieldRef<"ProjectFunction", 'Int'>
    readonly projectId: FieldRef<"ProjectFunction", 'Int'>
    readonly name: FieldRef<"ProjectFunction", 'String'>
    readonly code: FieldRef<"ProjectFunction", 'String'>
    readonly description: FieldRef<"ProjectFunction", 'String'>
    readonly createdBy: FieldRef<"ProjectFunction", 'String'>
    readonly createdAt: FieldRef<"ProjectFunction", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectFunction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectFunction findUnique
   */
  export type ProjectFunctionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFunction
     */
    select?: ProjectFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFunction
     */
    omit?: ProjectFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFunctionInclude<ExtArgs> | null
    /**
     * Filter, which ProjectFunction to fetch.
     */
    where: ProjectFunctionWhereUniqueInput
  }

  /**
   * ProjectFunction findUniqueOrThrow
   */
  export type ProjectFunctionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFunction
     */
    select?: ProjectFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFunction
     */
    omit?: ProjectFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFunctionInclude<ExtArgs> | null
    /**
     * Filter, which ProjectFunction to fetch.
     */
    where: ProjectFunctionWhereUniqueInput
  }

  /**
   * ProjectFunction findFirst
   */
  export type ProjectFunctionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFunction
     */
    select?: ProjectFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFunction
     */
    omit?: ProjectFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFunctionInclude<ExtArgs> | null
    /**
     * Filter, which ProjectFunction to fetch.
     */
    where?: ProjectFunctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectFunctions to fetch.
     */
    orderBy?: ProjectFunctionOrderByWithRelationInput | ProjectFunctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectFunctions.
     */
    cursor?: ProjectFunctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectFunctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectFunctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectFunctions.
     */
    distinct?: ProjectFunctionScalarFieldEnum | ProjectFunctionScalarFieldEnum[]
  }

  /**
   * ProjectFunction findFirstOrThrow
   */
  export type ProjectFunctionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFunction
     */
    select?: ProjectFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFunction
     */
    omit?: ProjectFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFunctionInclude<ExtArgs> | null
    /**
     * Filter, which ProjectFunction to fetch.
     */
    where?: ProjectFunctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectFunctions to fetch.
     */
    orderBy?: ProjectFunctionOrderByWithRelationInput | ProjectFunctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectFunctions.
     */
    cursor?: ProjectFunctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectFunctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectFunctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectFunctions.
     */
    distinct?: ProjectFunctionScalarFieldEnum | ProjectFunctionScalarFieldEnum[]
  }

  /**
   * ProjectFunction findMany
   */
  export type ProjectFunctionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFunction
     */
    select?: ProjectFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFunction
     */
    omit?: ProjectFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFunctionInclude<ExtArgs> | null
    /**
     * Filter, which ProjectFunctions to fetch.
     */
    where?: ProjectFunctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectFunctions to fetch.
     */
    orderBy?: ProjectFunctionOrderByWithRelationInput | ProjectFunctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectFunctions.
     */
    cursor?: ProjectFunctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectFunctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectFunctions.
     */
    skip?: number
    distinct?: ProjectFunctionScalarFieldEnum | ProjectFunctionScalarFieldEnum[]
  }

  /**
   * ProjectFunction create
   */
  export type ProjectFunctionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFunction
     */
    select?: ProjectFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFunction
     */
    omit?: ProjectFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFunctionInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectFunction.
     */
    data: XOR<ProjectFunctionCreateInput, ProjectFunctionUncheckedCreateInput>
  }

  /**
   * ProjectFunction createMany
   */
  export type ProjectFunctionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectFunctions.
     */
    data: ProjectFunctionCreateManyInput | ProjectFunctionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectFunction createManyAndReturn
   */
  export type ProjectFunctionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFunction
     */
    select?: ProjectFunctionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFunction
     */
    omit?: ProjectFunctionOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectFunctions.
     */
    data: ProjectFunctionCreateManyInput | ProjectFunctionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFunctionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectFunction update
   */
  export type ProjectFunctionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFunction
     */
    select?: ProjectFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFunction
     */
    omit?: ProjectFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFunctionInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectFunction.
     */
    data: XOR<ProjectFunctionUpdateInput, ProjectFunctionUncheckedUpdateInput>
    /**
     * Choose, which ProjectFunction to update.
     */
    where: ProjectFunctionWhereUniqueInput
  }

  /**
   * ProjectFunction updateMany
   */
  export type ProjectFunctionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectFunctions.
     */
    data: XOR<ProjectFunctionUpdateManyMutationInput, ProjectFunctionUncheckedUpdateManyInput>
    /**
     * Filter which ProjectFunctions to update
     */
    where?: ProjectFunctionWhereInput
    /**
     * Limit how many ProjectFunctions to update.
     */
    limit?: number
  }

  /**
   * ProjectFunction updateManyAndReturn
   */
  export type ProjectFunctionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFunction
     */
    select?: ProjectFunctionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFunction
     */
    omit?: ProjectFunctionOmit<ExtArgs> | null
    /**
     * The data used to update ProjectFunctions.
     */
    data: XOR<ProjectFunctionUpdateManyMutationInput, ProjectFunctionUncheckedUpdateManyInput>
    /**
     * Filter which ProjectFunctions to update
     */
    where?: ProjectFunctionWhereInput
    /**
     * Limit how many ProjectFunctions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFunctionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectFunction upsert
   */
  export type ProjectFunctionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFunction
     */
    select?: ProjectFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFunction
     */
    omit?: ProjectFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFunctionInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectFunction to update in case it exists.
     */
    where: ProjectFunctionWhereUniqueInput
    /**
     * In case the ProjectFunction found by the `where` argument doesn't exist, create a new ProjectFunction with this data.
     */
    create: XOR<ProjectFunctionCreateInput, ProjectFunctionUncheckedCreateInput>
    /**
     * In case the ProjectFunction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectFunctionUpdateInput, ProjectFunctionUncheckedUpdateInput>
  }

  /**
   * ProjectFunction delete
   */
  export type ProjectFunctionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFunction
     */
    select?: ProjectFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFunction
     */
    omit?: ProjectFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFunctionInclude<ExtArgs> | null
    /**
     * Filter which ProjectFunction to delete.
     */
    where: ProjectFunctionWhereUniqueInput
  }

  /**
   * ProjectFunction deleteMany
   */
  export type ProjectFunctionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectFunctions to delete
     */
    where?: ProjectFunctionWhereInput
    /**
     * Limit how many ProjectFunctions to delete.
     */
    limit?: number
  }

  /**
   * ProjectFunction.creator
   */
  export type ProjectFunction$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ProjectFunction without action
   */
  export type ProjectFunctionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFunction
     */
    select?: ProjectFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFunction
     */
    omit?: ProjectFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFunctionInclude<ExtArgs> | null
  }


  /**
   * Model TestSuiteFunction
   */

  export type AggregateTestSuiteFunction = {
    _count: TestSuiteFunctionCountAggregateOutputType | null
    _avg: TestSuiteFunctionAvgAggregateOutputType | null
    _sum: TestSuiteFunctionSumAggregateOutputType | null
    _min: TestSuiteFunctionMinAggregateOutputType | null
    _max: TestSuiteFunctionMaxAggregateOutputType | null
  }

  export type TestSuiteFunctionAvgAggregateOutputType = {
    id: number | null
    testSuiteId: number | null
  }

  export type TestSuiteFunctionSumAggregateOutputType = {
    id: number | null
    testSuiteId: number | null
  }

  export type TestSuiteFunctionMinAggregateOutputType = {
    id: number | null
    testSuiteId: number | null
    name: string | null
    code: string | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestSuiteFunctionMaxAggregateOutputType = {
    id: number | null
    testSuiteId: number | null
    name: string | null
    code: string | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestSuiteFunctionCountAggregateOutputType = {
    id: number
    testSuiteId: number
    name: number
    code: number
    description: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TestSuiteFunctionAvgAggregateInputType = {
    id?: true
    testSuiteId?: true
  }

  export type TestSuiteFunctionSumAggregateInputType = {
    id?: true
    testSuiteId?: true
  }

  export type TestSuiteFunctionMinAggregateInputType = {
    id?: true
    testSuiteId?: true
    name?: true
    code?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestSuiteFunctionMaxAggregateInputType = {
    id?: true
    testSuiteId?: true
    name?: true
    code?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestSuiteFunctionCountAggregateInputType = {
    id?: true
    testSuiteId?: true
    name?: true
    code?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestSuiteFunctionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestSuiteFunction to aggregate.
     */
    where?: TestSuiteFunctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestSuiteFunctions to fetch.
     */
    orderBy?: TestSuiteFunctionOrderByWithRelationInput | TestSuiteFunctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestSuiteFunctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestSuiteFunctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestSuiteFunctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestSuiteFunctions
    **/
    _count?: true | TestSuiteFunctionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestSuiteFunctionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestSuiteFunctionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestSuiteFunctionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestSuiteFunctionMaxAggregateInputType
  }

  export type GetTestSuiteFunctionAggregateType<T extends TestSuiteFunctionAggregateArgs> = {
        [P in keyof T & keyof AggregateTestSuiteFunction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestSuiteFunction[P]>
      : GetScalarType<T[P], AggregateTestSuiteFunction[P]>
  }




  export type TestSuiteFunctionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestSuiteFunctionWhereInput
    orderBy?: TestSuiteFunctionOrderByWithAggregationInput | TestSuiteFunctionOrderByWithAggregationInput[]
    by: TestSuiteFunctionScalarFieldEnum[] | TestSuiteFunctionScalarFieldEnum
    having?: TestSuiteFunctionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestSuiteFunctionCountAggregateInputType | true
    _avg?: TestSuiteFunctionAvgAggregateInputType
    _sum?: TestSuiteFunctionSumAggregateInputType
    _min?: TestSuiteFunctionMinAggregateInputType
    _max?: TestSuiteFunctionMaxAggregateInputType
  }

  export type TestSuiteFunctionGroupByOutputType = {
    id: number
    testSuiteId: number
    name: string
    code: string
    description: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: TestSuiteFunctionCountAggregateOutputType | null
    _avg: TestSuiteFunctionAvgAggregateOutputType | null
    _sum: TestSuiteFunctionSumAggregateOutputType | null
    _min: TestSuiteFunctionMinAggregateOutputType | null
    _max: TestSuiteFunctionMaxAggregateOutputType | null
  }

  type GetTestSuiteFunctionGroupByPayload<T extends TestSuiteFunctionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestSuiteFunctionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestSuiteFunctionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestSuiteFunctionGroupByOutputType[P]>
            : GetScalarType<T[P], TestSuiteFunctionGroupByOutputType[P]>
        }
      >
    >


  export type TestSuiteFunctionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testSuiteId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testSuite?: boolean | TestSuitesDefaultArgs<ExtArgs>
    creator?: boolean | TestSuiteFunction$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["testSuiteFunction"]>

  export type TestSuiteFunctionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testSuiteId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testSuite?: boolean | TestSuitesDefaultArgs<ExtArgs>
    creator?: boolean | TestSuiteFunction$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["testSuiteFunction"]>

  export type TestSuiteFunctionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testSuiteId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testSuite?: boolean | TestSuitesDefaultArgs<ExtArgs>
    creator?: boolean | TestSuiteFunction$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["testSuiteFunction"]>

  export type TestSuiteFunctionSelectScalar = {
    id?: boolean
    testSuiteId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TestSuiteFunctionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "testSuiteId" | "name" | "code" | "description" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["testSuiteFunction"]>
  export type TestSuiteFunctionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testSuite?: boolean | TestSuitesDefaultArgs<ExtArgs>
    creator?: boolean | TestSuiteFunction$creatorArgs<ExtArgs>
  }
  export type TestSuiteFunctionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testSuite?: boolean | TestSuitesDefaultArgs<ExtArgs>
    creator?: boolean | TestSuiteFunction$creatorArgs<ExtArgs>
  }
  export type TestSuiteFunctionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testSuite?: boolean | TestSuitesDefaultArgs<ExtArgs>
    creator?: boolean | TestSuiteFunction$creatorArgs<ExtArgs>
  }

  export type $TestSuiteFunctionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestSuiteFunction"
    objects: {
      testSuite: Prisma.$TestSuitesPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      testSuiteId: number
      name: string
      code: string
      description: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testSuiteFunction"]>
    composites: {}
  }

  type TestSuiteFunctionGetPayload<S extends boolean | null | undefined | TestSuiteFunctionDefaultArgs> = $Result.GetResult<Prisma.$TestSuiteFunctionPayload, S>

  type TestSuiteFunctionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestSuiteFunctionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestSuiteFunctionCountAggregateInputType | true
    }

  export interface TestSuiteFunctionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestSuiteFunction'], meta: { name: 'TestSuiteFunction' } }
    /**
     * Find zero or one TestSuiteFunction that matches the filter.
     * @param {TestSuiteFunctionFindUniqueArgs} args - Arguments to find a TestSuiteFunction
     * @example
     * // Get one TestSuiteFunction
     * const testSuiteFunction = await prisma.testSuiteFunction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestSuiteFunctionFindUniqueArgs>(args: SelectSubset<T, TestSuiteFunctionFindUniqueArgs<ExtArgs>>): Prisma__TestSuiteFunctionClient<$Result.GetResult<Prisma.$TestSuiteFunctionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestSuiteFunction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestSuiteFunctionFindUniqueOrThrowArgs} args - Arguments to find a TestSuiteFunction
     * @example
     * // Get one TestSuiteFunction
     * const testSuiteFunction = await prisma.testSuiteFunction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestSuiteFunctionFindUniqueOrThrowArgs>(args: SelectSubset<T, TestSuiteFunctionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestSuiteFunctionClient<$Result.GetResult<Prisma.$TestSuiteFunctionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestSuiteFunction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestSuiteFunctionFindFirstArgs} args - Arguments to find a TestSuiteFunction
     * @example
     * // Get one TestSuiteFunction
     * const testSuiteFunction = await prisma.testSuiteFunction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestSuiteFunctionFindFirstArgs>(args?: SelectSubset<T, TestSuiteFunctionFindFirstArgs<ExtArgs>>): Prisma__TestSuiteFunctionClient<$Result.GetResult<Prisma.$TestSuiteFunctionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestSuiteFunction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestSuiteFunctionFindFirstOrThrowArgs} args - Arguments to find a TestSuiteFunction
     * @example
     * // Get one TestSuiteFunction
     * const testSuiteFunction = await prisma.testSuiteFunction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestSuiteFunctionFindFirstOrThrowArgs>(args?: SelectSubset<T, TestSuiteFunctionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestSuiteFunctionClient<$Result.GetResult<Prisma.$TestSuiteFunctionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestSuiteFunctions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestSuiteFunctionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestSuiteFunctions
     * const testSuiteFunctions = await prisma.testSuiteFunction.findMany()
     * 
     * // Get first 10 TestSuiteFunctions
     * const testSuiteFunctions = await prisma.testSuiteFunction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testSuiteFunctionWithIdOnly = await prisma.testSuiteFunction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestSuiteFunctionFindManyArgs>(args?: SelectSubset<T, TestSuiteFunctionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestSuiteFunctionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestSuiteFunction.
     * @param {TestSuiteFunctionCreateArgs} args - Arguments to create a TestSuiteFunction.
     * @example
     * // Create one TestSuiteFunction
     * const TestSuiteFunction = await prisma.testSuiteFunction.create({
     *   data: {
     *     // ... data to create a TestSuiteFunction
     *   }
     * })
     * 
     */
    create<T extends TestSuiteFunctionCreateArgs>(args: SelectSubset<T, TestSuiteFunctionCreateArgs<ExtArgs>>): Prisma__TestSuiteFunctionClient<$Result.GetResult<Prisma.$TestSuiteFunctionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestSuiteFunctions.
     * @param {TestSuiteFunctionCreateManyArgs} args - Arguments to create many TestSuiteFunctions.
     * @example
     * // Create many TestSuiteFunctions
     * const testSuiteFunction = await prisma.testSuiteFunction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestSuiteFunctionCreateManyArgs>(args?: SelectSubset<T, TestSuiteFunctionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestSuiteFunctions and returns the data saved in the database.
     * @param {TestSuiteFunctionCreateManyAndReturnArgs} args - Arguments to create many TestSuiteFunctions.
     * @example
     * // Create many TestSuiteFunctions
     * const testSuiteFunction = await prisma.testSuiteFunction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestSuiteFunctions and only return the `id`
     * const testSuiteFunctionWithIdOnly = await prisma.testSuiteFunction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestSuiteFunctionCreateManyAndReturnArgs>(args?: SelectSubset<T, TestSuiteFunctionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestSuiteFunctionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TestSuiteFunction.
     * @param {TestSuiteFunctionDeleteArgs} args - Arguments to delete one TestSuiteFunction.
     * @example
     * // Delete one TestSuiteFunction
     * const TestSuiteFunction = await prisma.testSuiteFunction.delete({
     *   where: {
     *     // ... filter to delete one TestSuiteFunction
     *   }
     * })
     * 
     */
    delete<T extends TestSuiteFunctionDeleteArgs>(args: SelectSubset<T, TestSuiteFunctionDeleteArgs<ExtArgs>>): Prisma__TestSuiteFunctionClient<$Result.GetResult<Prisma.$TestSuiteFunctionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestSuiteFunction.
     * @param {TestSuiteFunctionUpdateArgs} args - Arguments to update one TestSuiteFunction.
     * @example
     * // Update one TestSuiteFunction
     * const testSuiteFunction = await prisma.testSuiteFunction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestSuiteFunctionUpdateArgs>(args: SelectSubset<T, TestSuiteFunctionUpdateArgs<ExtArgs>>): Prisma__TestSuiteFunctionClient<$Result.GetResult<Prisma.$TestSuiteFunctionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestSuiteFunctions.
     * @param {TestSuiteFunctionDeleteManyArgs} args - Arguments to filter TestSuiteFunctions to delete.
     * @example
     * // Delete a few TestSuiteFunctions
     * const { count } = await prisma.testSuiteFunction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestSuiteFunctionDeleteManyArgs>(args?: SelectSubset<T, TestSuiteFunctionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestSuiteFunctions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestSuiteFunctionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestSuiteFunctions
     * const testSuiteFunction = await prisma.testSuiteFunction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestSuiteFunctionUpdateManyArgs>(args: SelectSubset<T, TestSuiteFunctionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestSuiteFunctions and returns the data updated in the database.
     * @param {TestSuiteFunctionUpdateManyAndReturnArgs} args - Arguments to update many TestSuiteFunctions.
     * @example
     * // Update many TestSuiteFunctions
     * const testSuiteFunction = await prisma.testSuiteFunction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TestSuiteFunctions and only return the `id`
     * const testSuiteFunctionWithIdOnly = await prisma.testSuiteFunction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestSuiteFunctionUpdateManyAndReturnArgs>(args: SelectSubset<T, TestSuiteFunctionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestSuiteFunctionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TestSuiteFunction.
     * @param {TestSuiteFunctionUpsertArgs} args - Arguments to update or create a TestSuiteFunction.
     * @example
     * // Update or create a TestSuiteFunction
     * const testSuiteFunction = await prisma.testSuiteFunction.upsert({
     *   create: {
     *     // ... data to create a TestSuiteFunction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestSuiteFunction we want to update
     *   }
     * })
     */
    upsert<T extends TestSuiteFunctionUpsertArgs>(args: SelectSubset<T, TestSuiteFunctionUpsertArgs<ExtArgs>>): Prisma__TestSuiteFunctionClient<$Result.GetResult<Prisma.$TestSuiteFunctionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestSuiteFunctions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestSuiteFunctionCountArgs} args - Arguments to filter TestSuiteFunctions to count.
     * @example
     * // Count the number of TestSuiteFunctions
     * const count = await prisma.testSuiteFunction.count({
     *   where: {
     *     // ... the filter for the TestSuiteFunctions we want to count
     *   }
     * })
    **/
    count<T extends TestSuiteFunctionCountArgs>(
      args?: Subset<T, TestSuiteFunctionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestSuiteFunctionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestSuiteFunction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestSuiteFunctionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestSuiteFunctionAggregateArgs>(args: Subset<T, TestSuiteFunctionAggregateArgs>): Prisma.PrismaPromise<GetTestSuiteFunctionAggregateType<T>>

    /**
     * Group by TestSuiteFunction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestSuiteFunctionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestSuiteFunctionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestSuiteFunctionGroupByArgs['orderBy'] }
        : { orderBy?: TestSuiteFunctionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestSuiteFunctionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestSuiteFunctionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestSuiteFunction model
   */
  readonly fields: TestSuiteFunctionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestSuiteFunction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestSuiteFunctionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    testSuite<T extends TestSuitesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestSuitesDefaultArgs<ExtArgs>>): Prisma__TestSuitesClient<$Result.GetResult<Prisma.$TestSuitesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends TestSuiteFunction$creatorArgs<ExtArgs> = {}>(args?: Subset<T, TestSuiteFunction$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestSuiteFunction model
   */
  interface TestSuiteFunctionFieldRefs {
    readonly id: FieldRef<"TestSuiteFunction", 'Int'>
    readonly testSuiteId: FieldRef<"TestSuiteFunction", 'Int'>
    readonly name: FieldRef<"TestSuiteFunction", 'String'>
    readonly code: FieldRef<"TestSuiteFunction", 'String'>
    readonly description: FieldRef<"TestSuiteFunction", 'String'>
    readonly createdBy: FieldRef<"TestSuiteFunction", 'String'>
    readonly createdAt: FieldRef<"TestSuiteFunction", 'DateTime'>
    readonly updatedAt: FieldRef<"TestSuiteFunction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TestSuiteFunction findUnique
   */
  export type TestSuiteFunctionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteFunction
     */
    select?: TestSuiteFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteFunction
     */
    omit?: TestSuiteFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteFunctionInclude<ExtArgs> | null
    /**
     * Filter, which TestSuiteFunction to fetch.
     */
    where: TestSuiteFunctionWhereUniqueInput
  }

  /**
   * TestSuiteFunction findUniqueOrThrow
   */
  export type TestSuiteFunctionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteFunction
     */
    select?: TestSuiteFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteFunction
     */
    omit?: TestSuiteFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteFunctionInclude<ExtArgs> | null
    /**
     * Filter, which TestSuiteFunction to fetch.
     */
    where: TestSuiteFunctionWhereUniqueInput
  }

  /**
   * TestSuiteFunction findFirst
   */
  export type TestSuiteFunctionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteFunction
     */
    select?: TestSuiteFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteFunction
     */
    omit?: TestSuiteFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteFunctionInclude<ExtArgs> | null
    /**
     * Filter, which TestSuiteFunction to fetch.
     */
    where?: TestSuiteFunctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestSuiteFunctions to fetch.
     */
    orderBy?: TestSuiteFunctionOrderByWithRelationInput | TestSuiteFunctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestSuiteFunctions.
     */
    cursor?: TestSuiteFunctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestSuiteFunctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestSuiteFunctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestSuiteFunctions.
     */
    distinct?: TestSuiteFunctionScalarFieldEnum | TestSuiteFunctionScalarFieldEnum[]
  }

  /**
   * TestSuiteFunction findFirstOrThrow
   */
  export type TestSuiteFunctionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteFunction
     */
    select?: TestSuiteFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteFunction
     */
    omit?: TestSuiteFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteFunctionInclude<ExtArgs> | null
    /**
     * Filter, which TestSuiteFunction to fetch.
     */
    where?: TestSuiteFunctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestSuiteFunctions to fetch.
     */
    orderBy?: TestSuiteFunctionOrderByWithRelationInput | TestSuiteFunctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestSuiteFunctions.
     */
    cursor?: TestSuiteFunctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestSuiteFunctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestSuiteFunctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestSuiteFunctions.
     */
    distinct?: TestSuiteFunctionScalarFieldEnum | TestSuiteFunctionScalarFieldEnum[]
  }

  /**
   * TestSuiteFunction findMany
   */
  export type TestSuiteFunctionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteFunction
     */
    select?: TestSuiteFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteFunction
     */
    omit?: TestSuiteFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteFunctionInclude<ExtArgs> | null
    /**
     * Filter, which TestSuiteFunctions to fetch.
     */
    where?: TestSuiteFunctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestSuiteFunctions to fetch.
     */
    orderBy?: TestSuiteFunctionOrderByWithRelationInput | TestSuiteFunctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestSuiteFunctions.
     */
    cursor?: TestSuiteFunctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestSuiteFunctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestSuiteFunctions.
     */
    skip?: number
    distinct?: TestSuiteFunctionScalarFieldEnum | TestSuiteFunctionScalarFieldEnum[]
  }

  /**
   * TestSuiteFunction create
   */
  export type TestSuiteFunctionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteFunction
     */
    select?: TestSuiteFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteFunction
     */
    omit?: TestSuiteFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteFunctionInclude<ExtArgs> | null
    /**
     * The data needed to create a TestSuiteFunction.
     */
    data: XOR<TestSuiteFunctionCreateInput, TestSuiteFunctionUncheckedCreateInput>
  }

  /**
   * TestSuiteFunction createMany
   */
  export type TestSuiteFunctionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestSuiteFunctions.
     */
    data: TestSuiteFunctionCreateManyInput | TestSuiteFunctionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestSuiteFunction createManyAndReturn
   */
  export type TestSuiteFunctionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteFunction
     */
    select?: TestSuiteFunctionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteFunction
     */
    omit?: TestSuiteFunctionOmit<ExtArgs> | null
    /**
     * The data used to create many TestSuiteFunctions.
     */
    data: TestSuiteFunctionCreateManyInput | TestSuiteFunctionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteFunctionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestSuiteFunction update
   */
  export type TestSuiteFunctionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteFunction
     */
    select?: TestSuiteFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteFunction
     */
    omit?: TestSuiteFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteFunctionInclude<ExtArgs> | null
    /**
     * The data needed to update a TestSuiteFunction.
     */
    data: XOR<TestSuiteFunctionUpdateInput, TestSuiteFunctionUncheckedUpdateInput>
    /**
     * Choose, which TestSuiteFunction to update.
     */
    where: TestSuiteFunctionWhereUniqueInput
  }

  /**
   * TestSuiteFunction updateMany
   */
  export type TestSuiteFunctionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestSuiteFunctions.
     */
    data: XOR<TestSuiteFunctionUpdateManyMutationInput, TestSuiteFunctionUncheckedUpdateManyInput>
    /**
     * Filter which TestSuiteFunctions to update
     */
    where?: TestSuiteFunctionWhereInput
    /**
     * Limit how many TestSuiteFunctions to update.
     */
    limit?: number
  }

  /**
   * TestSuiteFunction updateManyAndReturn
   */
  export type TestSuiteFunctionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteFunction
     */
    select?: TestSuiteFunctionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteFunction
     */
    omit?: TestSuiteFunctionOmit<ExtArgs> | null
    /**
     * The data used to update TestSuiteFunctions.
     */
    data: XOR<TestSuiteFunctionUpdateManyMutationInput, TestSuiteFunctionUncheckedUpdateManyInput>
    /**
     * Filter which TestSuiteFunctions to update
     */
    where?: TestSuiteFunctionWhereInput
    /**
     * Limit how many TestSuiteFunctions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteFunctionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestSuiteFunction upsert
   */
  export type TestSuiteFunctionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteFunction
     */
    select?: TestSuiteFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteFunction
     */
    omit?: TestSuiteFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteFunctionInclude<ExtArgs> | null
    /**
     * The filter to search for the TestSuiteFunction to update in case it exists.
     */
    where: TestSuiteFunctionWhereUniqueInput
    /**
     * In case the TestSuiteFunction found by the `where` argument doesn't exist, create a new TestSuiteFunction with this data.
     */
    create: XOR<TestSuiteFunctionCreateInput, TestSuiteFunctionUncheckedCreateInput>
    /**
     * In case the TestSuiteFunction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestSuiteFunctionUpdateInput, TestSuiteFunctionUncheckedUpdateInput>
  }

  /**
   * TestSuiteFunction delete
   */
  export type TestSuiteFunctionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteFunction
     */
    select?: TestSuiteFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteFunction
     */
    omit?: TestSuiteFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteFunctionInclude<ExtArgs> | null
    /**
     * Filter which TestSuiteFunction to delete.
     */
    where: TestSuiteFunctionWhereUniqueInput
  }

  /**
   * TestSuiteFunction deleteMany
   */
  export type TestSuiteFunctionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestSuiteFunctions to delete
     */
    where?: TestSuiteFunctionWhereInput
    /**
     * Limit how many TestSuiteFunctions to delete.
     */
    limit?: number
  }

  /**
   * TestSuiteFunction.creator
   */
  export type TestSuiteFunction$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TestSuiteFunction without action
   */
  export type TestSuiteFunctionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuiteFunction
     */
    select?: TestSuiteFunctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuiteFunction
     */
    omit?: TestSuiteFunctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuiteFunctionInclude<ExtArgs> | null
  }


  /**
   * Model Page
   */

  export type AggregatePage = {
    _count: PageCountAggregateOutputType | null
    _avg: PageAvgAggregateOutputType | null
    _sum: PageSumAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  export type PageAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type PageSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type PageMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    url: string | null
    description: string | null
    isProtected: boolean | null
    authFunction: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    url: string | null
    description: string | null
    isProtected: boolean | null
    authFunction: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    url: number
    description: number
    isProtected: number
    authFunction: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PageAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type PageSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type PageMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    url?: true
    description?: true
    isProtected?: true
    authFunction?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    url?: true
    description?: true
    isProtected?: true
    authFunction?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    url?: true
    description?: true
    isProtected?: true
    authFunction?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Page to aggregate.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pages
    **/
    _count?: true | PageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PageMaxAggregateInputType
  }

  export type GetPageAggregateType<T extends PageAggregateArgs> = {
        [P in keyof T & keyof AggregatePage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePage[P]>
      : GetScalarType<T[P], AggregatePage[P]>
  }




  export type PageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
    orderBy?: PageOrderByWithAggregationInput | PageOrderByWithAggregationInput[]
    by: PageScalarFieldEnum[] | PageScalarFieldEnum
    having?: PageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageCountAggregateInputType | true
    _avg?: PageAvgAggregateInputType
    _sum?: PageSumAggregateInputType
    _min?: PageMinAggregateInputType
    _max?: PageMaxAggregateInputType
  }

  export type PageGroupByOutputType = {
    id: number
    projectId: number
    name: string
    url: string
    description: string | null
    isProtected: boolean
    authFunction: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: PageCountAggregateOutputType | null
    _avg: PageAvgAggregateOutputType | null
    _sum: PageSumAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  type GetPageGroupByPayload<T extends PageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageGroupByOutputType[P]>
            : GetScalarType<T[P], PageGroupByOutputType[P]>
        }
      >
    >


  export type PageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    url?: boolean
    description?: boolean
    isProtected?: boolean
    authFunction?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | Page$creatorArgs<ExtArgs>
    elements?: boolean | Page$elementsArgs<ExtArgs>
    _count?: boolean | PageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["page"]>

  export type PageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    url?: boolean
    description?: boolean
    isProtected?: boolean
    authFunction?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | Page$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["page"]>

  export type PageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    url?: boolean
    description?: boolean
    isProtected?: boolean
    authFunction?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | Page$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["page"]>

  export type PageSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    url?: boolean
    description?: boolean
    isProtected?: boolean
    authFunction?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "url" | "description" | "isProtected" | "authFunction" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["page"]>
  export type PageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | Page$creatorArgs<ExtArgs>
    elements?: boolean | Page$elementsArgs<ExtArgs>
    _count?: boolean | PageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | Page$creatorArgs<ExtArgs>
  }
  export type PageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | Page$creatorArgs<ExtArgs>
  }

  export type $PagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Page"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs> | null
      elements: Prisma.$PageElementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      name: string
      url: string
      description: string | null
      isProtected: boolean
      authFunction: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["page"]>
    composites: {}
  }

  type PageGetPayload<S extends boolean | null | undefined | PageDefaultArgs> = $Result.GetResult<Prisma.$PagePayload, S>

  type PageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PageCountAggregateInputType | true
    }

  export interface PageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Page'], meta: { name: 'Page' } }
    /**
     * Find zero or one Page that matches the filter.
     * @param {PageFindUniqueArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageFindUniqueArgs>(args: SelectSubset<T, PageFindUniqueArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Page that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PageFindUniqueOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageFindUniqueOrThrowArgs>(args: SelectSubset<T, PageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Page that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageFindFirstArgs>(args?: SelectSubset<T, PageFindFirstArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Page that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageFindFirstOrThrowArgs>(args?: SelectSubset<T, PageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pages
     * const pages = await prisma.page.findMany()
     * 
     * // Get first 10 Pages
     * const pages = await prisma.page.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pageWithIdOnly = await prisma.page.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PageFindManyArgs>(args?: SelectSubset<T, PageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Page.
     * @param {PageCreateArgs} args - Arguments to create a Page.
     * @example
     * // Create one Page
     * const Page = await prisma.page.create({
     *   data: {
     *     // ... data to create a Page
     *   }
     * })
     * 
     */
    create<T extends PageCreateArgs>(args: SelectSubset<T, PageCreateArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pages.
     * @param {PageCreateManyArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const page = await prisma.page.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PageCreateManyArgs>(args?: SelectSubset<T, PageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pages and returns the data saved in the database.
     * @param {PageCreateManyAndReturnArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const page = await prisma.page.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pages and only return the `id`
     * const pageWithIdOnly = await prisma.page.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PageCreateManyAndReturnArgs>(args?: SelectSubset<T, PageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Page.
     * @param {PageDeleteArgs} args - Arguments to delete one Page.
     * @example
     * // Delete one Page
     * const Page = await prisma.page.delete({
     *   where: {
     *     // ... filter to delete one Page
     *   }
     * })
     * 
     */
    delete<T extends PageDeleteArgs>(args: SelectSubset<T, PageDeleteArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Page.
     * @param {PageUpdateArgs} args - Arguments to update one Page.
     * @example
     * // Update one Page
     * const page = await prisma.page.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PageUpdateArgs>(args: SelectSubset<T, PageUpdateArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pages.
     * @param {PageDeleteManyArgs} args - Arguments to filter Pages to delete.
     * @example
     * // Delete a few Pages
     * const { count } = await prisma.page.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PageDeleteManyArgs>(args?: SelectSubset<T, PageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pages
     * const page = await prisma.page.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PageUpdateManyArgs>(args: SelectSubset<T, PageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages and returns the data updated in the database.
     * @param {PageUpdateManyAndReturnArgs} args - Arguments to update many Pages.
     * @example
     * // Update many Pages
     * const page = await prisma.page.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pages and only return the `id`
     * const pageWithIdOnly = await prisma.page.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PageUpdateManyAndReturnArgs>(args: SelectSubset<T, PageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Page.
     * @param {PageUpsertArgs} args - Arguments to update or create a Page.
     * @example
     * // Update or create a Page
     * const page = await prisma.page.upsert({
     *   create: {
     *     // ... data to create a Page
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Page we want to update
     *   }
     * })
     */
    upsert<T extends PageUpsertArgs>(args: SelectSubset<T, PageUpsertArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageCountArgs} args - Arguments to filter Pages to count.
     * @example
     * // Count the number of Pages
     * const count = await prisma.page.count({
     *   where: {
     *     // ... the filter for the Pages we want to count
     *   }
     * })
    **/
    count<T extends PageCountArgs>(
      args?: Subset<T, PageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PageAggregateArgs>(args: Subset<T, PageAggregateArgs>): Prisma.PrismaPromise<GetPageAggregateType<T>>

    /**
     * Group by Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageGroupByArgs['orderBy'] }
        : { orderBy?: PageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Page model
   */
  readonly fields: PageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Page.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends Page$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Page$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    elements<T extends Page$elementsArgs<ExtArgs> = {}>(args?: Subset<T, Page$elementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Page model
   */
  interface PageFieldRefs {
    readonly id: FieldRef<"Page", 'Int'>
    readonly projectId: FieldRef<"Page", 'Int'>
    readonly name: FieldRef<"Page", 'String'>
    readonly url: FieldRef<"Page", 'String'>
    readonly description: FieldRef<"Page", 'String'>
    readonly isProtected: FieldRef<"Page", 'Boolean'>
    readonly authFunction: FieldRef<"Page", 'String'>
    readonly createdBy: FieldRef<"Page", 'String'>
    readonly createdAt: FieldRef<"Page", 'DateTime'>
    readonly updatedAt: FieldRef<"Page", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Page findUnique
   */
  export type PageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findUniqueOrThrow
   */
  export type PageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findFirst
   */
  export type PageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findFirstOrThrow
   */
  export type PageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findMany
   */
  export type PageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Pages to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page create
   */
  export type PageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The data needed to create a Page.
     */
    data: XOR<PageCreateInput, PageUncheckedCreateInput>
  }

  /**
   * Page createMany
   */
  export type PageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Page createManyAndReturn
   */
  export type PageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Page update
   */
  export type PageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The data needed to update a Page.
     */
    data: XOR<PageUpdateInput, PageUncheckedUpdateInput>
    /**
     * Choose, which Page to update.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page updateMany
   */
  export type PageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pages.
     */
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyInput>
    /**
     * Filter which Pages to update
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to update.
     */
    limit?: number
  }

  /**
   * Page updateManyAndReturn
   */
  export type PageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The data used to update Pages.
     */
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyInput>
    /**
     * Filter which Pages to update
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Page upsert
   */
  export type PageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The filter to search for the Page to update in case it exists.
     */
    where: PageWhereUniqueInput
    /**
     * In case the Page found by the `where` argument doesn't exist, create a new Page with this data.
     */
    create: XOR<PageCreateInput, PageUncheckedCreateInput>
    /**
     * In case the Page was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageUpdateInput, PageUncheckedUpdateInput>
  }

  /**
   * Page delete
   */
  export type PageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter which Page to delete.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page deleteMany
   */
  export type PageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pages to delete
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to delete.
     */
    limit?: number
  }

  /**
   * Page.creator
   */
  export type Page$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Page.elements
   */
  export type Page$elementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageElement
     */
    select?: PageElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageElement
     */
    omit?: PageElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageElementInclude<ExtArgs> | null
    where?: PageElementWhereInput
    orderBy?: PageElementOrderByWithRelationInput | PageElementOrderByWithRelationInput[]
    cursor?: PageElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageElementScalarFieldEnum | PageElementScalarFieldEnum[]
  }

  /**
   * Page without action
   */
  export type PageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
  }


  /**
   * Model PageElement
   */

  export type AggregatePageElement = {
    _count: PageElementCountAggregateOutputType | null
    _avg: PageElementAvgAggregateOutputType | null
    _sum: PageElementSumAggregateOutputType | null
    _min: PageElementMinAggregateOutputType | null
    _max: PageElementMaxAggregateOutputType | null
  }

  export type PageElementAvgAggregateOutputType = {
    id: number | null
    pageId: number | null
  }

  export type PageElementSumAggregateOutputType = {
    id: number | null
    pageId: number | null
  }

  export type PageElementMinAggregateOutputType = {
    id: number | null
    pageId: number | null
    elementName: string | null
    selector: string | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageElementMaxAggregateOutputType = {
    id: number | null
    pageId: number | null
    elementName: string | null
    selector: string | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageElementCountAggregateOutputType = {
    id: number
    pageId: number
    elementName: number
    selector: number
    description: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PageElementAvgAggregateInputType = {
    id?: true
    pageId?: true
  }

  export type PageElementSumAggregateInputType = {
    id?: true
    pageId?: true
  }

  export type PageElementMinAggregateInputType = {
    id?: true
    pageId?: true
    elementName?: true
    selector?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageElementMaxAggregateInputType = {
    id?: true
    pageId?: true
    elementName?: true
    selector?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageElementCountAggregateInputType = {
    id?: true
    pageId?: true
    elementName?: true
    selector?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PageElementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PageElement to aggregate.
     */
    where?: PageElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageElements to fetch.
     */
    orderBy?: PageElementOrderByWithRelationInput | PageElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PageElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PageElements
    **/
    _count?: true | PageElementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PageElementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PageElementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PageElementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PageElementMaxAggregateInputType
  }

  export type GetPageElementAggregateType<T extends PageElementAggregateArgs> = {
        [P in keyof T & keyof AggregatePageElement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePageElement[P]>
      : GetScalarType<T[P], AggregatePageElement[P]>
  }




  export type PageElementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageElementWhereInput
    orderBy?: PageElementOrderByWithAggregationInput | PageElementOrderByWithAggregationInput[]
    by: PageElementScalarFieldEnum[] | PageElementScalarFieldEnum
    having?: PageElementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageElementCountAggregateInputType | true
    _avg?: PageElementAvgAggregateInputType
    _sum?: PageElementSumAggregateInputType
    _min?: PageElementMinAggregateInputType
    _max?: PageElementMaxAggregateInputType
  }

  export type PageElementGroupByOutputType = {
    id: number
    pageId: number
    elementName: string
    selector: string
    description: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: PageElementCountAggregateOutputType | null
    _avg: PageElementAvgAggregateOutputType | null
    _sum: PageElementSumAggregateOutputType | null
    _min: PageElementMinAggregateOutputType | null
    _max: PageElementMaxAggregateOutputType | null
  }

  type GetPageElementGroupByPayload<T extends PageElementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageElementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PageElementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageElementGroupByOutputType[P]>
            : GetScalarType<T[P], PageElementGroupByOutputType[P]>
        }
      >
    >


  export type PageElementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    elementName?: boolean
    selector?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    page?: boolean | PageDefaultArgs<ExtArgs>
    creator?: boolean | PageElement$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["pageElement"]>

  export type PageElementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    elementName?: boolean
    selector?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    page?: boolean | PageDefaultArgs<ExtArgs>
    creator?: boolean | PageElement$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["pageElement"]>

  export type PageElementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    elementName?: boolean
    selector?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    page?: boolean | PageDefaultArgs<ExtArgs>
    creator?: boolean | PageElement$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["pageElement"]>

  export type PageElementSelectScalar = {
    id?: boolean
    pageId?: boolean
    elementName?: boolean
    selector?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PageElementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pageId" | "elementName" | "selector" | "description" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["pageElement"]>
  export type PageElementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page?: boolean | PageDefaultArgs<ExtArgs>
    creator?: boolean | PageElement$creatorArgs<ExtArgs>
  }
  export type PageElementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page?: boolean | PageDefaultArgs<ExtArgs>
    creator?: boolean | PageElement$creatorArgs<ExtArgs>
  }
  export type PageElementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page?: boolean | PageDefaultArgs<ExtArgs>
    creator?: boolean | PageElement$creatorArgs<ExtArgs>
  }

  export type $PageElementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PageElement"
    objects: {
      page: Prisma.$PagePayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pageId: number
      elementName: string
      selector: string
      description: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pageElement"]>
    composites: {}
  }

  type PageElementGetPayload<S extends boolean | null | undefined | PageElementDefaultArgs> = $Result.GetResult<Prisma.$PageElementPayload, S>

  type PageElementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PageElementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PageElementCountAggregateInputType | true
    }

  export interface PageElementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PageElement'], meta: { name: 'PageElement' } }
    /**
     * Find zero or one PageElement that matches the filter.
     * @param {PageElementFindUniqueArgs} args - Arguments to find a PageElement
     * @example
     * // Get one PageElement
     * const pageElement = await prisma.pageElement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageElementFindUniqueArgs>(args: SelectSubset<T, PageElementFindUniqueArgs<ExtArgs>>): Prisma__PageElementClient<$Result.GetResult<Prisma.$PageElementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PageElement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PageElementFindUniqueOrThrowArgs} args - Arguments to find a PageElement
     * @example
     * // Get one PageElement
     * const pageElement = await prisma.pageElement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageElementFindUniqueOrThrowArgs>(args: SelectSubset<T, PageElementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PageElementClient<$Result.GetResult<Prisma.$PageElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PageElement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageElementFindFirstArgs} args - Arguments to find a PageElement
     * @example
     * // Get one PageElement
     * const pageElement = await prisma.pageElement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageElementFindFirstArgs>(args?: SelectSubset<T, PageElementFindFirstArgs<ExtArgs>>): Prisma__PageElementClient<$Result.GetResult<Prisma.$PageElementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PageElement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageElementFindFirstOrThrowArgs} args - Arguments to find a PageElement
     * @example
     * // Get one PageElement
     * const pageElement = await prisma.pageElement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageElementFindFirstOrThrowArgs>(args?: SelectSubset<T, PageElementFindFirstOrThrowArgs<ExtArgs>>): Prisma__PageElementClient<$Result.GetResult<Prisma.$PageElementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PageElements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageElementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PageElements
     * const pageElements = await prisma.pageElement.findMany()
     * 
     * // Get first 10 PageElements
     * const pageElements = await prisma.pageElement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pageElementWithIdOnly = await prisma.pageElement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PageElementFindManyArgs>(args?: SelectSubset<T, PageElementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PageElement.
     * @param {PageElementCreateArgs} args - Arguments to create a PageElement.
     * @example
     * // Create one PageElement
     * const PageElement = await prisma.pageElement.create({
     *   data: {
     *     // ... data to create a PageElement
     *   }
     * })
     * 
     */
    create<T extends PageElementCreateArgs>(args: SelectSubset<T, PageElementCreateArgs<ExtArgs>>): Prisma__PageElementClient<$Result.GetResult<Prisma.$PageElementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PageElements.
     * @param {PageElementCreateManyArgs} args - Arguments to create many PageElements.
     * @example
     * // Create many PageElements
     * const pageElement = await prisma.pageElement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PageElementCreateManyArgs>(args?: SelectSubset<T, PageElementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PageElements and returns the data saved in the database.
     * @param {PageElementCreateManyAndReturnArgs} args - Arguments to create many PageElements.
     * @example
     * // Create many PageElements
     * const pageElement = await prisma.pageElement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PageElements and only return the `id`
     * const pageElementWithIdOnly = await prisma.pageElement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PageElementCreateManyAndReturnArgs>(args?: SelectSubset<T, PageElementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageElementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PageElement.
     * @param {PageElementDeleteArgs} args - Arguments to delete one PageElement.
     * @example
     * // Delete one PageElement
     * const PageElement = await prisma.pageElement.delete({
     *   where: {
     *     // ... filter to delete one PageElement
     *   }
     * })
     * 
     */
    delete<T extends PageElementDeleteArgs>(args: SelectSubset<T, PageElementDeleteArgs<ExtArgs>>): Prisma__PageElementClient<$Result.GetResult<Prisma.$PageElementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PageElement.
     * @param {PageElementUpdateArgs} args - Arguments to update one PageElement.
     * @example
     * // Update one PageElement
     * const pageElement = await prisma.pageElement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PageElementUpdateArgs>(args: SelectSubset<T, PageElementUpdateArgs<ExtArgs>>): Prisma__PageElementClient<$Result.GetResult<Prisma.$PageElementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PageElements.
     * @param {PageElementDeleteManyArgs} args - Arguments to filter PageElements to delete.
     * @example
     * // Delete a few PageElements
     * const { count } = await prisma.pageElement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PageElementDeleteManyArgs>(args?: SelectSubset<T, PageElementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PageElements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageElementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PageElements
     * const pageElement = await prisma.pageElement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PageElementUpdateManyArgs>(args: SelectSubset<T, PageElementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PageElements and returns the data updated in the database.
     * @param {PageElementUpdateManyAndReturnArgs} args - Arguments to update many PageElements.
     * @example
     * // Update many PageElements
     * const pageElement = await prisma.pageElement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PageElements and only return the `id`
     * const pageElementWithIdOnly = await prisma.pageElement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PageElementUpdateManyAndReturnArgs>(args: SelectSubset<T, PageElementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageElementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PageElement.
     * @param {PageElementUpsertArgs} args - Arguments to update or create a PageElement.
     * @example
     * // Update or create a PageElement
     * const pageElement = await prisma.pageElement.upsert({
     *   create: {
     *     // ... data to create a PageElement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PageElement we want to update
     *   }
     * })
     */
    upsert<T extends PageElementUpsertArgs>(args: SelectSubset<T, PageElementUpsertArgs<ExtArgs>>): Prisma__PageElementClient<$Result.GetResult<Prisma.$PageElementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PageElements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageElementCountArgs} args - Arguments to filter PageElements to count.
     * @example
     * // Count the number of PageElements
     * const count = await prisma.pageElement.count({
     *   where: {
     *     // ... the filter for the PageElements we want to count
     *   }
     * })
    **/
    count<T extends PageElementCountArgs>(
      args?: Subset<T, PageElementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageElementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PageElement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageElementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PageElementAggregateArgs>(args: Subset<T, PageElementAggregateArgs>): Prisma.PrismaPromise<GetPageElementAggregateType<T>>

    /**
     * Group by PageElement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageElementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PageElementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageElementGroupByArgs['orderBy'] }
        : { orderBy?: PageElementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PageElementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageElementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PageElement model
   */
  readonly fields: PageElementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PageElement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageElementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    page<T extends PageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PageDefaultArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends PageElement$creatorArgs<ExtArgs> = {}>(args?: Subset<T, PageElement$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PageElement model
   */
  interface PageElementFieldRefs {
    readonly id: FieldRef<"PageElement", 'Int'>
    readonly pageId: FieldRef<"PageElement", 'Int'>
    readonly elementName: FieldRef<"PageElement", 'String'>
    readonly selector: FieldRef<"PageElement", 'String'>
    readonly description: FieldRef<"PageElement", 'String'>
    readonly createdBy: FieldRef<"PageElement", 'String'>
    readonly createdAt: FieldRef<"PageElement", 'DateTime'>
    readonly updatedAt: FieldRef<"PageElement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PageElement findUnique
   */
  export type PageElementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageElement
     */
    select?: PageElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageElement
     */
    omit?: PageElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageElementInclude<ExtArgs> | null
    /**
     * Filter, which PageElement to fetch.
     */
    where: PageElementWhereUniqueInput
  }

  /**
   * PageElement findUniqueOrThrow
   */
  export type PageElementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageElement
     */
    select?: PageElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageElement
     */
    omit?: PageElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageElementInclude<ExtArgs> | null
    /**
     * Filter, which PageElement to fetch.
     */
    where: PageElementWhereUniqueInput
  }

  /**
   * PageElement findFirst
   */
  export type PageElementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageElement
     */
    select?: PageElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageElement
     */
    omit?: PageElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageElementInclude<ExtArgs> | null
    /**
     * Filter, which PageElement to fetch.
     */
    where?: PageElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageElements to fetch.
     */
    orderBy?: PageElementOrderByWithRelationInput | PageElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PageElements.
     */
    cursor?: PageElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PageElements.
     */
    distinct?: PageElementScalarFieldEnum | PageElementScalarFieldEnum[]
  }

  /**
   * PageElement findFirstOrThrow
   */
  export type PageElementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageElement
     */
    select?: PageElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageElement
     */
    omit?: PageElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageElementInclude<ExtArgs> | null
    /**
     * Filter, which PageElement to fetch.
     */
    where?: PageElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageElements to fetch.
     */
    orderBy?: PageElementOrderByWithRelationInput | PageElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PageElements.
     */
    cursor?: PageElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PageElements.
     */
    distinct?: PageElementScalarFieldEnum | PageElementScalarFieldEnum[]
  }

  /**
   * PageElement findMany
   */
  export type PageElementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageElement
     */
    select?: PageElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageElement
     */
    omit?: PageElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageElementInclude<ExtArgs> | null
    /**
     * Filter, which PageElements to fetch.
     */
    where?: PageElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageElements to fetch.
     */
    orderBy?: PageElementOrderByWithRelationInput | PageElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PageElements.
     */
    cursor?: PageElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageElements.
     */
    skip?: number
    distinct?: PageElementScalarFieldEnum | PageElementScalarFieldEnum[]
  }

  /**
   * PageElement create
   */
  export type PageElementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageElement
     */
    select?: PageElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageElement
     */
    omit?: PageElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageElementInclude<ExtArgs> | null
    /**
     * The data needed to create a PageElement.
     */
    data: XOR<PageElementCreateInput, PageElementUncheckedCreateInput>
  }

  /**
   * PageElement createMany
   */
  export type PageElementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PageElements.
     */
    data: PageElementCreateManyInput | PageElementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PageElement createManyAndReturn
   */
  export type PageElementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageElement
     */
    select?: PageElementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PageElement
     */
    omit?: PageElementOmit<ExtArgs> | null
    /**
     * The data used to create many PageElements.
     */
    data: PageElementCreateManyInput | PageElementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageElementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PageElement update
   */
  export type PageElementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageElement
     */
    select?: PageElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageElement
     */
    omit?: PageElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageElementInclude<ExtArgs> | null
    /**
     * The data needed to update a PageElement.
     */
    data: XOR<PageElementUpdateInput, PageElementUncheckedUpdateInput>
    /**
     * Choose, which PageElement to update.
     */
    where: PageElementWhereUniqueInput
  }

  /**
   * PageElement updateMany
   */
  export type PageElementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PageElements.
     */
    data: XOR<PageElementUpdateManyMutationInput, PageElementUncheckedUpdateManyInput>
    /**
     * Filter which PageElements to update
     */
    where?: PageElementWhereInput
    /**
     * Limit how many PageElements to update.
     */
    limit?: number
  }

  /**
   * PageElement updateManyAndReturn
   */
  export type PageElementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageElement
     */
    select?: PageElementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PageElement
     */
    omit?: PageElementOmit<ExtArgs> | null
    /**
     * The data used to update PageElements.
     */
    data: XOR<PageElementUpdateManyMutationInput, PageElementUncheckedUpdateManyInput>
    /**
     * Filter which PageElements to update
     */
    where?: PageElementWhereInput
    /**
     * Limit how many PageElements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageElementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PageElement upsert
   */
  export type PageElementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageElement
     */
    select?: PageElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageElement
     */
    omit?: PageElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageElementInclude<ExtArgs> | null
    /**
     * The filter to search for the PageElement to update in case it exists.
     */
    where: PageElementWhereUniqueInput
    /**
     * In case the PageElement found by the `where` argument doesn't exist, create a new PageElement with this data.
     */
    create: XOR<PageElementCreateInput, PageElementUncheckedCreateInput>
    /**
     * In case the PageElement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageElementUpdateInput, PageElementUncheckedUpdateInput>
  }

  /**
   * PageElement delete
   */
  export type PageElementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageElement
     */
    select?: PageElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageElement
     */
    omit?: PageElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageElementInclude<ExtArgs> | null
    /**
     * Filter which PageElement to delete.
     */
    where: PageElementWhereUniqueInput
  }

  /**
   * PageElement deleteMany
   */
  export type PageElementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PageElements to delete
     */
    where?: PageElementWhereInput
    /**
     * Limit how many PageElements to delete.
     */
    limit?: number
  }

  /**
   * PageElement.creator
   */
  export type PageElement$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PageElement without action
   */
  export type PageElementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageElement
     */
    select?: PageElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageElement
     */
    omit?: PageElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageElementInclude<ExtArgs> | null
  }


  /**
   * Model TestCase
   */

  export type AggregateTestCase = {
    _count: TestCaseCountAggregateOutputType | null
    _avg: TestCaseAvgAggregateOutputType | null
    _sum: TestCaseSumAggregateOutputType | null
    _min: TestCaseMinAggregateOutputType | null
    _max: TestCaseMaxAggregateOutputType | null
  }

  export type TestCaseAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    testSuiteId: number | null
  }

  export type TestCaseSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    testSuiteId: number | null
  }

  export type TestCaseMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    testSuiteId: number | null
    name: string | null
    description: string | null
    code: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestCaseMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    testSuiteId: number | null
    name: string | null
    description: string | null
    code: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestCaseCountAggregateOutputType = {
    id: number
    projectId: number
    testSuiteId: number
    name: number
    description: number
    code: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TestCaseAvgAggregateInputType = {
    id?: true
    projectId?: true
    testSuiteId?: true
  }

  export type TestCaseSumAggregateInputType = {
    id?: true
    projectId?: true
    testSuiteId?: true
  }

  export type TestCaseMinAggregateInputType = {
    id?: true
    projectId?: true
    testSuiteId?: true
    name?: true
    description?: true
    code?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestCaseMaxAggregateInputType = {
    id?: true
    projectId?: true
    testSuiteId?: true
    name?: true
    description?: true
    code?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestCaseCountAggregateInputType = {
    id?: true
    projectId?: true
    testSuiteId?: true
    name?: true
    description?: true
    code?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestCaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestCase to aggregate.
     */
    where?: TestCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestCases to fetch.
     */
    orderBy?: TestCaseOrderByWithRelationInput | TestCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestCases
    **/
    _count?: true | TestCaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestCaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestCaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestCaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestCaseMaxAggregateInputType
  }

  export type GetTestCaseAggregateType<T extends TestCaseAggregateArgs> = {
        [P in keyof T & keyof AggregateTestCase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestCase[P]>
      : GetScalarType<T[P], AggregateTestCase[P]>
  }




  export type TestCaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestCaseWhereInput
    orderBy?: TestCaseOrderByWithAggregationInput | TestCaseOrderByWithAggregationInput[]
    by: TestCaseScalarFieldEnum[] | TestCaseScalarFieldEnum
    having?: TestCaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestCaseCountAggregateInputType | true
    _avg?: TestCaseAvgAggregateInputType
    _sum?: TestCaseSumAggregateInputType
    _min?: TestCaseMinAggregateInputType
    _max?: TestCaseMaxAggregateInputType
  }

  export type TestCaseGroupByOutputType = {
    id: number
    projectId: number
    testSuiteId: number | null
    name: string
    description: string | null
    code: string
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: TestCaseCountAggregateOutputType | null
    _avg: TestCaseAvgAggregateOutputType | null
    _sum: TestCaseSumAggregateOutputType | null
    _min: TestCaseMinAggregateOutputType | null
    _max: TestCaseMaxAggregateOutputType | null
  }

  type GetTestCaseGroupByPayload<T extends TestCaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestCaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestCaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestCaseGroupByOutputType[P]>
            : GetScalarType<T[P], TestCaseGroupByOutputType[P]>
        }
      >
    >


  export type TestCaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    testSuiteId?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testSuite?: boolean | TestCase$testSuiteArgs<ExtArgs>
    creator?: boolean | TestCase$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["testCase"]>

  export type TestCaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    testSuiteId?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testSuite?: boolean | TestCase$testSuiteArgs<ExtArgs>
    creator?: boolean | TestCase$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["testCase"]>

  export type TestCaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    testSuiteId?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testSuite?: boolean | TestCase$testSuiteArgs<ExtArgs>
    creator?: boolean | TestCase$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["testCase"]>

  export type TestCaseSelectScalar = {
    id?: boolean
    projectId?: boolean
    testSuiteId?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TestCaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "testSuiteId" | "name" | "description" | "code" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["testCase"]>
  export type TestCaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testSuite?: boolean | TestCase$testSuiteArgs<ExtArgs>
    creator?: boolean | TestCase$creatorArgs<ExtArgs>
  }
  export type TestCaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testSuite?: boolean | TestCase$testSuiteArgs<ExtArgs>
    creator?: boolean | TestCase$creatorArgs<ExtArgs>
  }
  export type TestCaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testSuite?: boolean | TestCase$testSuiteArgs<ExtArgs>
    creator?: boolean | TestCase$creatorArgs<ExtArgs>
  }

  export type $TestCasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestCase"
    objects: {
      testSuite: Prisma.$TestSuitesPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      testSuiteId: number | null
      name: string
      description: string | null
      code: string
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testCase"]>
    composites: {}
  }

  type TestCaseGetPayload<S extends boolean | null | undefined | TestCaseDefaultArgs> = $Result.GetResult<Prisma.$TestCasePayload, S>

  type TestCaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestCaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestCaseCountAggregateInputType | true
    }

  export interface TestCaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestCase'], meta: { name: 'TestCase' } }
    /**
     * Find zero or one TestCase that matches the filter.
     * @param {TestCaseFindUniqueArgs} args - Arguments to find a TestCase
     * @example
     * // Get one TestCase
     * const testCase = await prisma.testCase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestCaseFindUniqueArgs>(args: SelectSubset<T, TestCaseFindUniqueArgs<ExtArgs>>): Prisma__TestCaseClient<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestCase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestCaseFindUniqueOrThrowArgs} args - Arguments to find a TestCase
     * @example
     * // Get one TestCase
     * const testCase = await prisma.testCase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestCaseFindUniqueOrThrowArgs>(args: SelectSubset<T, TestCaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestCaseClient<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestCase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCaseFindFirstArgs} args - Arguments to find a TestCase
     * @example
     * // Get one TestCase
     * const testCase = await prisma.testCase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestCaseFindFirstArgs>(args?: SelectSubset<T, TestCaseFindFirstArgs<ExtArgs>>): Prisma__TestCaseClient<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestCase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCaseFindFirstOrThrowArgs} args - Arguments to find a TestCase
     * @example
     * // Get one TestCase
     * const testCase = await prisma.testCase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestCaseFindFirstOrThrowArgs>(args?: SelectSubset<T, TestCaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestCaseClient<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestCases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestCases
     * const testCases = await prisma.testCase.findMany()
     * 
     * // Get first 10 TestCases
     * const testCases = await prisma.testCase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testCaseWithIdOnly = await prisma.testCase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestCaseFindManyArgs>(args?: SelectSubset<T, TestCaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestCase.
     * @param {TestCaseCreateArgs} args - Arguments to create a TestCase.
     * @example
     * // Create one TestCase
     * const TestCase = await prisma.testCase.create({
     *   data: {
     *     // ... data to create a TestCase
     *   }
     * })
     * 
     */
    create<T extends TestCaseCreateArgs>(args: SelectSubset<T, TestCaseCreateArgs<ExtArgs>>): Prisma__TestCaseClient<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestCases.
     * @param {TestCaseCreateManyArgs} args - Arguments to create many TestCases.
     * @example
     * // Create many TestCases
     * const testCase = await prisma.testCase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestCaseCreateManyArgs>(args?: SelectSubset<T, TestCaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestCases and returns the data saved in the database.
     * @param {TestCaseCreateManyAndReturnArgs} args - Arguments to create many TestCases.
     * @example
     * // Create many TestCases
     * const testCase = await prisma.testCase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestCases and only return the `id`
     * const testCaseWithIdOnly = await prisma.testCase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestCaseCreateManyAndReturnArgs>(args?: SelectSubset<T, TestCaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TestCase.
     * @param {TestCaseDeleteArgs} args - Arguments to delete one TestCase.
     * @example
     * // Delete one TestCase
     * const TestCase = await prisma.testCase.delete({
     *   where: {
     *     // ... filter to delete one TestCase
     *   }
     * })
     * 
     */
    delete<T extends TestCaseDeleteArgs>(args: SelectSubset<T, TestCaseDeleteArgs<ExtArgs>>): Prisma__TestCaseClient<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestCase.
     * @param {TestCaseUpdateArgs} args - Arguments to update one TestCase.
     * @example
     * // Update one TestCase
     * const testCase = await prisma.testCase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestCaseUpdateArgs>(args: SelectSubset<T, TestCaseUpdateArgs<ExtArgs>>): Prisma__TestCaseClient<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestCases.
     * @param {TestCaseDeleteManyArgs} args - Arguments to filter TestCases to delete.
     * @example
     * // Delete a few TestCases
     * const { count } = await prisma.testCase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestCaseDeleteManyArgs>(args?: SelectSubset<T, TestCaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestCases
     * const testCase = await prisma.testCase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestCaseUpdateManyArgs>(args: SelectSubset<T, TestCaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestCases and returns the data updated in the database.
     * @param {TestCaseUpdateManyAndReturnArgs} args - Arguments to update many TestCases.
     * @example
     * // Update many TestCases
     * const testCase = await prisma.testCase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TestCases and only return the `id`
     * const testCaseWithIdOnly = await prisma.testCase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestCaseUpdateManyAndReturnArgs>(args: SelectSubset<T, TestCaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TestCase.
     * @param {TestCaseUpsertArgs} args - Arguments to update or create a TestCase.
     * @example
     * // Update or create a TestCase
     * const testCase = await prisma.testCase.upsert({
     *   create: {
     *     // ... data to create a TestCase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestCase we want to update
     *   }
     * })
     */
    upsert<T extends TestCaseUpsertArgs>(args: SelectSubset<T, TestCaseUpsertArgs<ExtArgs>>): Prisma__TestCaseClient<$Result.GetResult<Prisma.$TestCasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCaseCountArgs} args - Arguments to filter TestCases to count.
     * @example
     * // Count the number of TestCases
     * const count = await prisma.testCase.count({
     *   where: {
     *     // ... the filter for the TestCases we want to count
     *   }
     * })
    **/
    count<T extends TestCaseCountArgs>(
      args?: Subset<T, TestCaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestCaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestCaseAggregateArgs>(args: Subset<T, TestCaseAggregateArgs>): Prisma.PrismaPromise<GetTestCaseAggregateType<T>>

    /**
     * Group by TestCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestCaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestCaseGroupByArgs['orderBy'] }
        : { orderBy?: TestCaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestCaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestCaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestCase model
   */
  readonly fields: TestCaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestCase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestCaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    testSuite<T extends TestCase$testSuiteArgs<ExtArgs> = {}>(args?: Subset<T, TestCase$testSuiteArgs<ExtArgs>>): Prisma__TestSuitesClient<$Result.GetResult<Prisma.$TestSuitesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creator<T extends TestCase$creatorArgs<ExtArgs> = {}>(args?: Subset<T, TestCase$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestCase model
   */
  interface TestCaseFieldRefs {
    readonly id: FieldRef<"TestCase", 'Int'>
    readonly projectId: FieldRef<"TestCase", 'Int'>
    readonly testSuiteId: FieldRef<"TestCase", 'Int'>
    readonly name: FieldRef<"TestCase", 'String'>
    readonly description: FieldRef<"TestCase", 'String'>
    readonly code: FieldRef<"TestCase", 'String'>
    readonly createdBy: FieldRef<"TestCase", 'String'>
    readonly createdAt: FieldRef<"TestCase", 'DateTime'>
    readonly updatedAt: FieldRef<"TestCase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TestCase findUnique
   */
  export type TestCaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCase
     */
    omit?: TestCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    /**
     * Filter, which TestCase to fetch.
     */
    where: TestCaseWhereUniqueInput
  }

  /**
   * TestCase findUniqueOrThrow
   */
  export type TestCaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCase
     */
    omit?: TestCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    /**
     * Filter, which TestCase to fetch.
     */
    where: TestCaseWhereUniqueInput
  }

  /**
   * TestCase findFirst
   */
  export type TestCaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCase
     */
    omit?: TestCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    /**
     * Filter, which TestCase to fetch.
     */
    where?: TestCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestCases to fetch.
     */
    orderBy?: TestCaseOrderByWithRelationInput | TestCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestCases.
     */
    cursor?: TestCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestCases.
     */
    distinct?: TestCaseScalarFieldEnum | TestCaseScalarFieldEnum[]
  }

  /**
   * TestCase findFirstOrThrow
   */
  export type TestCaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCase
     */
    omit?: TestCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    /**
     * Filter, which TestCase to fetch.
     */
    where?: TestCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestCases to fetch.
     */
    orderBy?: TestCaseOrderByWithRelationInput | TestCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestCases.
     */
    cursor?: TestCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestCases.
     */
    distinct?: TestCaseScalarFieldEnum | TestCaseScalarFieldEnum[]
  }

  /**
   * TestCase findMany
   */
  export type TestCaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCase
     */
    omit?: TestCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    /**
     * Filter, which TestCases to fetch.
     */
    where?: TestCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestCases to fetch.
     */
    orderBy?: TestCaseOrderByWithRelationInput | TestCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestCases.
     */
    cursor?: TestCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestCases.
     */
    skip?: number
    distinct?: TestCaseScalarFieldEnum | TestCaseScalarFieldEnum[]
  }

  /**
   * TestCase create
   */
  export type TestCaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCase
     */
    omit?: TestCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    /**
     * The data needed to create a TestCase.
     */
    data: XOR<TestCaseCreateInput, TestCaseUncheckedCreateInput>
  }

  /**
   * TestCase createMany
   */
  export type TestCaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestCases.
     */
    data: TestCaseCreateManyInput | TestCaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestCase createManyAndReturn
   */
  export type TestCaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestCase
     */
    omit?: TestCaseOmit<ExtArgs> | null
    /**
     * The data used to create many TestCases.
     */
    data: TestCaseCreateManyInput | TestCaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestCase update
   */
  export type TestCaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCase
     */
    omit?: TestCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    /**
     * The data needed to update a TestCase.
     */
    data: XOR<TestCaseUpdateInput, TestCaseUncheckedUpdateInput>
    /**
     * Choose, which TestCase to update.
     */
    where: TestCaseWhereUniqueInput
  }

  /**
   * TestCase updateMany
   */
  export type TestCaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestCases.
     */
    data: XOR<TestCaseUpdateManyMutationInput, TestCaseUncheckedUpdateManyInput>
    /**
     * Filter which TestCases to update
     */
    where?: TestCaseWhereInput
    /**
     * Limit how many TestCases to update.
     */
    limit?: number
  }

  /**
   * TestCase updateManyAndReturn
   */
  export type TestCaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestCase
     */
    omit?: TestCaseOmit<ExtArgs> | null
    /**
     * The data used to update TestCases.
     */
    data: XOR<TestCaseUpdateManyMutationInput, TestCaseUncheckedUpdateManyInput>
    /**
     * Filter which TestCases to update
     */
    where?: TestCaseWhereInput
    /**
     * Limit how many TestCases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestCase upsert
   */
  export type TestCaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCase
     */
    omit?: TestCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    /**
     * The filter to search for the TestCase to update in case it exists.
     */
    where: TestCaseWhereUniqueInput
    /**
     * In case the TestCase found by the `where` argument doesn't exist, create a new TestCase with this data.
     */
    create: XOR<TestCaseCreateInput, TestCaseUncheckedCreateInput>
    /**
     * In case the TestCase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestCaseUpdateInput, TestCaseUncheckedUpdateInput>
  }

  /**
   * TestCase delete
   */
  export type TestCaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCase
     */
    omit?: TestCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
    /**
     * Filter which TestCase to delete.
     */
    where: TestCaseWhereUniqueInput
  }

  /**
   * TestCase deleteMany
   */
  export type TestCaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestCases to delete
     */
    where?: TestCaseWhereInput
    /**
     * Limit how many TestCases to delete.
     */
    limit?: number
  }

  /**
   * TestCase.testSuite
   */
  export type TestCase$testSuiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestSuites
     */
    select?: TestSuitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestSuites
     */
    omit?: TestSuitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestSuitesInclude<ExtArgs> | null
    where?: TestSuitesWhereInput
  }

  /**
   * TestCase.creator
   */
  export type TestCase$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TestCase without action
   */
  export type TestCaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCase
     */
    select?: TestCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestCase
     */
    omit?: TestCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestCaseInclude<ExtArgs> | null
  }


  /**
   * Model ProjectInvitation
   */

  export type AggregateProjectInvitation = {
    _count: ProjectInvitationCountAggregateOutputType | null
    _avg: ProjectInvitationAvgAggregateOutputType | null
    _sum: ProjectInvitationSumAggregateOutputType | null
    _min: ProjectInvitationMinAggregateOutputType | null
    _max: ProjectInvitationMaxAggregateOutputType | null
  }

  export type ProjectInvitationAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ProjectInvitationSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ProjectInvitationMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: string | null
    invitedBy: string | null
    status: $Enums.ProjectInvitationStatus | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectInvitationMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: string | null
    invitedBy: string | null
    status: $Enums.ProjectInvitationStatus | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectInvitationCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    invitedBy: number
    status: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectInvitationAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ProjectInvitationSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ProjectInvitationMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    invitedBy?: true
    status?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectInvitationMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    invitedBy?: true
    status?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectInvitationCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    invitedBy?: true
    status?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectInvitation to aggregate.
     */
    where?: ProjectInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectInvitations to fetch.
     */
    orderBy?: ProjectInvitationOrderByWithRelationInput | ProjectInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectInvitations
    **/
    _count?: true | ProjectInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectInvitationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectInvitationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectInvitationMaxAggregateInputType
  }

  export type GetProjectInvitationAggregateType<T extends ProjectInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectInvitation[P]>
      : GetScalarType<T[P], AggregateProjectInvitation[P]>
  }




  export type ProjectInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectInvitationWhereInput
    orderBy?: ProjectInvitationOrderByWithAggregationInput | ProjectInvitationOrderByWithAggregationInput[]
    by: ProjectInvitationScalarFieldEnum[] | ProjectInvitationScalarFieldEnum
    having?: ProjectInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectInvitationCountAggregateInputType | true
    _avg?: ProjectInvitationAvgAggregateInputType
    _sum?: ProjectInvitationSumAggregateInputType
    _min?: ProjectInvitationMinAggregateInputType
    _max?: ProjectInvitationMaxAggregateInputType
  }

  export type ProjectInvitationGroupByOutputType = {
    id: number
    projectId: number
    userId: string
    invitedBy: string
    status: $Enums.ProjectInvitationStatus
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: ProjectInvitationCountAggregateOutputType | null
    _avg: ProjectInvitationAvgAggregateOutputType | null
    _sum: ProjectInvitationSumAggregateOutputType | null
    _min: ProjectInvitationMinAggregateOutputType | null
    _max: ProjectInvitationMaxAggregateOutputType | null
  }

  type GetProjectInvitationGroupByPayload<T extends ProjectInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectInvitationGroupByOutputType[P]>
        }
      >
    >


  export type ProjectInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    invitedBy?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectInvitation"]>

  export type ProjectInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    invitedBy?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectInvitation"]>

  export type ProjectInvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    invitedBy?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectInvitation"]>

  export type ProjectInvitationSelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    invitedBy?: boolean
    status?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectInvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "userId" | "invitedBy" | "status" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["projectInvitation"]>
  export type ProjectInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectInvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectInvitation"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      inviter: Prisma.$UserPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      userId: string
      invitedBy: string
      status: $Enums.ProjectInvitationStatus
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projectInvitation"]>
    composites: {}
  }

  type ProjectInvitationGetPayload<S extends boolean | null | undefined | ProjectInvitationDefaultArgs> = $Result.GetResult<Prisma.$ProjectInvitationPayload, S>

  type ProjectInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectInvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectInvitationCountAggregateInputType | true
    }

  export interface ProjectInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectInvitation'], meta: { name: 'ProjectInvitation' } }
    /**
     * Find zero or one ProjectInvitation that matches the filter.
     * @param {ProjectInvitationFindUniqueArgs} args - Arguments to find a ProjectInvitation
     * @example
     * // Get one ProjectInvitation
     * const projectInvitation = await prisma.projectInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectInvitationFindUniqueArgs>(args: SelectSubset<T, ProjectInvitationFindUniqueArgs<ExtArgs>>): Prisma__ProjectInvitationClient<$Result.GetResult<Prisma.$ProjectInvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectInvitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectInvitationFindUniqueOrThrowArgs} args - Arguments to find a ProjectInvitation
     * @example
     * // Get one ProjectInvitation
     * const projectInvitation = await prisma.projectInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectInvitationClient<$Result.GetResult<Prisma.$ProjectInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInvitationFindFirstArgs} args - Arguments to find a ProjectInvitation
     * @example
     * // Get one ProjectInvitation
     * const projectInvitation = await prisma.projectInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectInvitationFindFirstArgs>(args?: SelectSubset<T, ProjectInvitationFindFirstArgs<ExtArgs>>): Prisma__ProjectInvitationClient<$Result.GetResult<Prisma.$ProjectInvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInvitationFindFirstOrThrowArgs} args - Arguments to find a ProjectInvitation
     * @example
     * // Get one ProjectInvitation
     * const projectInvitation = await prisma.projectInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectInvitationClient<$Result.GetResult<Prisma.$ProjectInvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectInvitations
     * const projectInvitations = await prisma.projectInvitation.findMany()
     * 
     * // Get first 10 ProjectInvitations
     * const projectInvitations = await prisma.projectInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectInvitationWithIdOnly = await prisma.projectInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectInvitationFindManyArgs>(args?: SelectSubset<T, ProjectInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectInvitation.
     * @param {ProjectInvitationCreateArgs} args - Arguments to create a ProjectInvitation.
     * @example
     * // Create one ProjectInvitation
     * const ProjectInvitation = await prisma.projectInvitation.create({
     *   data: {
     *     // ... data to create a ProjectInvitation
     *   }
     * })
     * 
     */
    create<T extends ProjectInvitationCreateArgs>(args: SelectSubset<T, ProjectInvitationCreateArgs<ExtArgs>>): Prisma__ProjectInvitationClient<$Result.GetResult<Prisma.$ProjectInvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectInvitations.
     * @param {ProjectInvitationCreateManyArgs} args - Arguments to create many ProjectInvitations.
     * @example
     * // Create many ProjectInvitations
     * const projectInvitation = await prisma.projectInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectInvitationCreateManyArgs>(args?: SelectSubset<T, ProjectInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectInvitations and returns the data saved in the database.
     * @param {ProjectInvitationCreateManyAndReturnArgs} args - Arguments to create many ProjectInvitations.
     * @example
     * // Create many ProjectInvitations
     * const projectInvitation = await prisma.projectInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectInvitations and only return the `id`
     * const projectInvitationWithIdOnly = await prisma.projectInvitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectInvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectInvitation.
     * @param {ProjectInvitationDeleteArgs} args - Arguments to delete one ProjectInvitation.
     * @example
     * // Delete one ProjectInvitation
     * const ProjectInvitation = await prisma.projectInvitation.delete({
     *   where: {
     *     // ... filter to delete one ProjectInvitation
     *   }
     * })
     * 
     */
    delete<T extends ProjectInvitationDeleteArgs>(args: SelectSubset<T, ProjectInvitationDeleteArgs<ExtArgs>>): Prisma__ProjectInvitationClient<$Result.GetResult<Prisma.$ProjectInvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectInvitation.
     * @param {ProjectInvitationUpdateArgs} args - Arguments to update one ProjectInvitation.
     * @example
     * // Update one ProjectInvitation
     * const projectInvitation = await prisma.projectInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectInvitationUpdateArgs>(args: SelectSubset<T, ProjectInvitationUpdateArgs<ExtArgs>>): Prisma__ProjectInvitationClient<$Result.GetResult<Prisma.$ProjectInvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectInvitations.
     * @param {ProjectInvitationDeleteManyArgs} args - Arguments to filter ProjectInvitations to delete.
     * @example
     * // Delete a few ProjectInvitations
     * const { count } = await prisma.projectInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectInvitationDeleteManyArgs>(args?: SelectSubset<T, ProjectInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectInvitations
     * const projectInvitation = await prisma.projectInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectInvitationUpdateManyArgs>(args: SelectSubset<T, ProjectInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectInvitations and returns the data updated in the database.
     * @param {ProjectInvitationUpdateManyAndReturnArgs} args - Arguments to update many ProjectInvitations.
     * @example
     * // Update many ProjectInvitations
     * const projectInvitation = await prisma.projectInvitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectInvitations and only return the `id`
     * const projectInvitationWithIdOnly = await prisma.projectInvitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectInvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectInvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectInvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectInvitation.
     * @param {ProjectInvitationUpsertArgs} args - Arguments to update or create a ProjectInvitation.
     * @example
     * // Update or create a ProjectInvitation
     * const projectInvitation = await prisma.projectInvitation.upsert({
     *   create: {
     *     // ... data to create a ProjectInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectInvitation we want to update
     *   }
     * })
     */
    upsert<T extends ProjectInvitationUpsertArgs>(args: SelectSubset<T, ProjectInvitationUpsertArgs<ExtArgs>>): Prisma__ProjectInvitationClient<$Result.GetResult<Prisma.$ProjectInvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInvitationCountArgs} args - Arguments to filter ProjectInvitations to count.
     * @example
     * // Count the number of ProjectInvitations
     * const count = await prisma.projectInvitation.count({
     *   where: {
     *     // ... the filter for the ProjectInvitations we want to count
     *   }
     * })
    **/
    count<T extends ProjectInvitationCountArgs>(
      args?: Subset<T, ProjectInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectInvitationAggregateArgs>(args: Subset<T, ProjectInvitationAggregateArgs>): Prisma.PrismaPromise<GetProjectInvitationAggregateType<T>>

    /**
     * Group by ProjectInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectInvitationGroupByArgs['orderBy'] }
        : { orderBy?: ProjectInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectInvitation model
   */
  readonly fields: ProjectInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inviter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectInvitation model
   */
  interface ProjectInvitationFieldRefs {
    readonly id: FieldRef<"ProjectInvitation", 'Int'>
    readonly projectId: FieldRef<"ProjectInvitation", 'Int'>
    readonly userId: FieldRef<"ProjectInvitation", 'String'>
    readonly invitedBy: FieldRef<"ProjectInvitation", 'String'>
    readonly status: FieldRef<"ProjectInvitation", 'ProjectInvitationStatus'>
    readonly expiresAt: FieldRef<"ProjectInvitation", 'DateTime'>
    readonly createdAt: FieldRef<"ProjectInvitation", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectInvitation findUnique
   */
  export type ProjectInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvitation
     */
    select?: ProjectInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvitation
     */
    omit?: ProjectInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvitationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectInvitation to fetch.
     */
    where: ProjectInvitationWhereUniqueInput
  }

  /**
   * ProjectInvitation findUniqueOrThrow
   */
  export type ProjectInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvitation
     */
    select?: ProjectInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvitation
     */
    omit?: ProjectInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvitationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectInvitation to fetch.
     */
    where: ProjectInvitationWhereUniqueInput
  }

  /**
   * ProjectInvitation findFirst
   */
  export type ProjectInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvitation
     */
    select?: ProjectInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvitation
     */
    omit?: ProjectInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvitationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectInvitation to fetch.
     */
    where?: ProjectInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectInvitations to fetch.
     */
    orderBy?: ProjectInvitationOrderByWithRelationInput | ProjectInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectInvitations.
     */
    cursor?: ProjectInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectInvitations.
     */
    distinct?: ProjectInvitationScalarFieldEnum | ProjectInvitationScalarFieldEnum[]
  }

  /**
   * ProjectInvitation findFirstOrThrow
   */
  export type ProjectInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvitation
     */
    select?: ProjectInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvitation
     */
    omit?: ProjectInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvitationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectInvitation to fetch.
     */
    where?: ProjectInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectInvitations to fetch.
     */
    orderBy?: ProjectInvitationOrderByWithRelationInput | ProjectInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectInvitations.
     */
    cursor?: ProjectInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectInvitations.
     */
    distinct?: ProjectInvitationScalarFieldEnum | ProjectInvitationScalarFieldEnum[]
  }

  /**
   * ProjectInvitation findMany
   */
  export type ProjectInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvitation
     */
    select?: ProjectInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvitation
     */
    omit?: ProjectInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvitationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectInvitations to fetch.
     */
    where?: ProjectInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectInvitations to fetch.
     */
    orderBy?: ProjectInvitationOrderByWithRelationInput | ProjectInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectInvitations.
     */
    cursor?: ProjectInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectInvitations.
     */
    skip?: number
    distinct?: ProjectInvitationScalarFieldEnum | ProjectInvitationScalarFieldEnum[]
  }

  /**
   * ProjectInvitation create
   */
  export type ProjectInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvitation
     */
    select?: ProjectInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvitation
     */
    omit?: ProjectInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectInvitation.
     */
    data: XOR<ProjectInvitationCreateInput, ProjectInvitationUncheckedCreateInput>
  }

  /**
   * ProjectInvitation createMany
   */
  export type ProjectInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectInvitations.
     */
    data: ProjectInvitationCreateManyInput | ProjectInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectInvitation createManyAndReturn
   */
  export type ProjectInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvitation
     */
    select?: ProjectInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvitation
     */
    omit?: ProjectInvitationOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectInvitations.
     */
    data: ProjectInvitationCreateManyInput | ProjectInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectInvitation update
   */
  export type ProjectInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvitation
     */
    select?: ProjectInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvitation
     */
    omit?: ProjectInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectInvitation.
     */
    data: XOR<ProjectInvitationUpdateInput, ProjectInvitationUncheckedUpdateInput>
    /**
     * Choose, which ProjectInvitation to update.
     */
    where: ProjectInvitationWhereUniqueInput
  }

  /**
   * ProjectInvitation updateMany
   */
  export type ProjectInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectInvitations.
     */
    data: XOR<ProjectInvitationUpdateManyMutationInput, ProjectInvitationUncheckedUpdateManyInput>
    /**
     * Filter which ProjectInvitations to update
     */
    where?: ProjectInvitationWhereInput
    /**
     * Limit how many ProjectInvitations to update.
     */
    limit?: number
  }

  /**
   * ProjectInvitation updateManyAndReturn
   */
  export type ProjectInvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvitation
     */
    select?: ProjectInvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvitation
     */
    omit?: ProjectInvitationOmit<ExtArgs> | null
    /**
     * The data used to update ProjectInvitations.
     */
    data: XOR<ProjectInvitationUpdateManyMutationInput, ProjectInvitationUncheckedUpdateManyInput>
    /**
     * Filter which ProjectInvitations to update
     */
    where?: ProjectInvitationWhereInput
    /**
     * Limit how many ProjectInvitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectInvitation upsert
   */
  export type ProjectInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvitation
     */
    select?: ProjectInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvitation
     */
    omit?: ProjectInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectInvitation to update in case it exists.
     */
    where: ProjectInvitationWhereUniqueInput
    /**
     * In case the ProjectInvitation found by the `where` argument doesn't exist, create a new ProjectInvitation with this data.
     */
    create: XOR<ProjectInvitationCreateInput, ProjectInvitationUncheckedCreateInput>
    /**
     * In case the ProjectInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectInvitationUpdateInput, ProjectInvitationUncheckedUpdateInput>
  }

  /**
   * ProjectInvitation delete
   */
  export type ProjectInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvitation
     */
    select?: ProjectInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvitation
     */
    omit?: ProjectInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvitationInclude<ExtArgs> | null
    /**
     * Filter which ProjectInvitation to delete.
     */
    where: ProjectInvitationWhereUniqueInput
  }

  /**
   * ProjectInvitation deleteMany
   */
  export type ProjectInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectInvitations to delete
     */
    where?: ProjectInvitationWhereInput
    /**
     * Limit how many ProjectInvitations to delete.
     */
    limit?: number
  }

  /**
   * ProjectInvitation without action
   */
  export type ProjectInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvitation
     */
    select?: ProjectInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvitation
     */
    omit?: ProjectInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvitationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    expiresAt: 'expiresAt',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    baseUrl: 'baseUrl',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectMemberScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type ProjectMemberScalarFieldEnum = (typeof ProjectMemberScalarFieldEnum)[keyof typeof ProjectMemberScalarFieldEnum]


  export const TestSuitesScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    description: 'description',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TestSuitesScalarFieldEnum = (typeof TestSuitesScalarFieldEnum)[keyof typeof TestSuitesScalarFieldEnum]


  export const ProjectVariableScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    value: 'value',
    description: 'description',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectVariableScalarFieldEnum = (typeof ProjectVariableScalarFieldEnum)[keyof typeof ProjectVariableScalarFieldEnum]


  export const TestSuiteVariableScalarFieldEnum: {
    id: 'id',
    testSuiteId: 'testSuiteId',
    name: 'name',
    value: 'value',
    description: 'description',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TestSuiteVariableScalarFieldEnum = (typeof TestSuiteVariableScalarFieldEnum)[keyof typeof TestSuiteVariableScalarFieldEnum]


  export const ProjectFunctionScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    code: 'code',
    description: 'description',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectFunctionScalarFieldEnum = (typeof ProjectFunctionScalarFieldEnum)[keyof typeof ProjectFunctionScalarFieldEnum]


  export const TestSuiteFunctionScalarFieldEnum: {
    id: 'id',
    testSuiteId: 'testSuiteId',
    name: 'name',
    code: 'code',
    description: 'description',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TestSuiteFunctionScalarFieldEnum = (typeof TestSuiteFunctionScalarFieldEnum)[keyof typeof TestSuiteFunctionScalarFieldEnum]


  export const PageScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    url: 'url',
    description: 'description',
    isProtected: 'isProtected',
    authFunction: 'authFunction',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PageScalarFieldEnum = (typeof PageScalarFieldEnum)[keyof typeof PageScalarFieldEnum]


  export const PageElementScalarFieldEnum: {
    id: 'id',
    pageId: 'pageId',
    elementName: 'elementName',
    selector: 'selector',
    description: 'description',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PageElementScalarFieldEnum = (typeof PageElementScalarFieldEnum)[keyof typeof PageElementScalarFieldEnum]


  export const TestCaseScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    testSuiteId: 'testSuiteId',
    name: 'name',
    description: 'description',
    code: 'code',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TestCaseScalarFieldEnum = (typeof TestCaseScalarFieldEnum)[keyof typeof TestCaseScalarFieldEnum]


  export const ProjectInvitationScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    invitedBy: 'invitedBy',
    status: 'status',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectInvitationScalarFieldEnum = (typeof ProjectInvitationScalarFieldEnum)[keyof typeof ProjectInvitationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ProjectInvitationStatus'
   */
  export type EnumProjectInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectInvitationStatus'>
    


  /**
   * Reference to a field of type 'ProjectInvitationStatus[]'
   */
  export type ListEnumProjectInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectInvitationStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    createdProjects?: ProjectListRelationFilter
    projectMemberships?: ProjectMemberListRelationFilter
    createdPages?: PageListRelationFilter
    createdPageElements?: PageElementListRelationFilter
    createdTestCases?: TestCaseListRelationFilter
    sentInvitations?: ProjectInvitationListRelationFilter
    receivedInvitations?: ProjectInvitationListRelationFilter
    projectVariables?: ProjectVariableListRelationFilter
    testSuiteVariables?: TestSuiteVariableListRelationFilter
    projectFunctions?: ProjectFunctionListRelationFilter
    testSuiteFunctions?: TestSuiteFunctionListRelationFilter
    testSuites?: TestSuitesListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    createdProjects?: ProjectOrderByRelationAggregateInput
    projectMemberships?: ProjectMemberOrderByRelationAggregateInput
    createdPages?: PageOrderByRelationAggregateInput
    createdPageElements?: PageElementOrderByRelationAggregateInput
    createdTestCases?: TestCaseOrderByRelationAggregateInput
    sentInvitations?: ProjectInvitationOrderByRelationAggregateInput
    receivedInvitations?: ProjectInvitationOrderByRelationAggregateInput
    projectVariables?: ProjectVariableOrderByRelationAggregateInput
    testSuiteVariables?: TestSuiteVariableOrderByRelationAggregateInput
    projectFunctions?: ProjectFunctionOrderByRelationAggregateInput
    testSuiteFunctions?: TestSuiteFunctionOrderByRelationAggregateInput
    testSuites?: TestSuitesOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    createdProjects?: ProjectListRelationFilter
    projectMemberships?: ProjectMemberListRelationFilter
    createdPages?: PageListRelationFilter
    createdPageElements?: PageElementListRelationFilter
    createdTestCases?: TestCaseListRelationFilter
    sentInvitations?: ProjectInvitationListRelationFilter
    receivedInvitations?: ProjectInvitationListRelationFilter
    projectVariables?: ProjectVariableListRelationFilter
    testSuiteVariables?: TestSuiteVariableListRelationFilter
    projectFunctions?: ProjectFunctionListRelationFilter
    testSuiteFunctions?: TestSuiteFunctionListRelationFilter
    testSuites?: TestSuitesListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    token?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userId?: StringWithAggregatesFilter<"Session"> | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: IntFilter<"Project"> | number
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    baseUrl?: StringNullableFilter<"Project"> | string | null
    createdBy?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    members?: ProjectMemberListRelationFilter
    pages?: PageListRelationFilter
    invitations?: ProjectInvitationListRelationFilter
    testSuites?: TestSuitesListRelationFilter
    globalVariables?: ProjectVariableListRelationFilter
    globalFunctions?: ProjectFunctionListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    baseUrl?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    members?: ProjectMemberOrderByRelationAggregateInput
    pages?: PageOrderByRelationAggregateInput
    invitations?: ProjectInvitationOrderByRelationAggregateInput
    testSuites?: TestSuitesOrderByRelationAggregateInput
    globalVariables?: ProjectVariableOrderByRelationAggregateInput
    globalFunctions?: ProjectFunctionOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    baseUrl?: StringNullableFilter<"Project"> | string | null
    createdBy?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    members?: ProjectMemberListRelationFilter
    pages?: PageListRelationFilter
    invitations?: ProjectInvitationListRelationFilter
    testSuites?: TestSuitesListRelationFilter
    globalVariables?: ProjectVariableListRelationFilter
    globalFunctions?: ProjectFunctionListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    baseUrl?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Project"> | number
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    baseUrl?: StringNullableWithAggregatesFilter<"Project"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Project"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type ProjectMemberWhereInput = {
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    id?: IntFilter<"ProjectMember"> | number
    projectId?: IntFilter<"ProjectMember"> | number
    userId?: StringFilter<"ProjectMember"> | string
    role?: StringFilter<"ProjectMember"> | string
    joinedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProjectMemberOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProjectMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId_userId?: ProjectMemberProjectIdUserIdCompoundUniqueInput
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    projectId?: IntFilter<"ProjectMember"> | number
    userId?: StringFilter<"ProjectMember"> | string
    role?: StringFilter<"ProjectMember"> | string
    joinedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "projectId_userId">

  export type ProjectMemberOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    _count?: ProjectMemberCountOrderByAggregateInput
    _avg?: ProjectMemberAvgOrderByAggregateInput
    _max?: ProjectMemberMaxOrderByAggregateInput
    _min?: ProjectMemberMinOrderByAggregateInput
    _sum?: ProjectMemberSumOrderByAggregateInput
  }

  export type ProjectMemberScalarWhereWithAggregatesInput = {
    AND?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    OR?: ProjectMemberScalarWhereWithAggregatesInput[]
    NOT?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectMember"> | number
    projectId?: IntWithAggregatesFilter<"ProjectMember"> | number
    userId?: StringWithAggregatesFilter<"ProjectMember"> | string
    role?: StringWithAggregatesFilter<"ProjectMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"ProjectMember"> | Date | string
  }

  export type TestSuitesWhereInput = {
    AND?: TestSuitesWhereInput | TestSuitesWhereInput[]
    OR?: TestSuitesWhereInput[]
    NOT?: TestSuitesWhereInput | TestSuitesWhereInput[]
    id?: IntFilter<"TestSuites"> | number
    projectId?: IntFilter<"TestSuites"> | number
    name?: StringFilter<"TestSuites"> | string
    description?: StringNullableFilter<"TestSuites"> | string | null
    createdBy?: StringNullableFilter<"TestSuites"> | string | null
    createdAt?: DateTimeFilter<"TestSuites"> | Date | string
    updatedAt?: DateTimeFilter<"TestSuites"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    testCases?: TestCaseListRelationFilter
    variables?: TestSuiteVariableListRelationFilter
    functions?: TestSuiteFunctionListRelationFilter
  }

  export type TestSuitesOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    testCases?: TestCaseOrderByRelationAggregateInput
    variables?: TestSuiteVariableOrderByRelationAggregateInput
    functions?: TestSuiteFunctionOrderByRelationAggregateInput
  }

  export type TestSuitesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TestSuitesWhereInput | TestSuitesWhereInput[]
    OR?: TestSuitesWhereInput[]
    NOT?: TestSuitesWhereInput | TestSuitesWhereInput[]
    projectId?: IntFilter<"TestSuites"> | number
    name?: StringFilter<"TestSuites"> | string
    description?: StringNullableFilter<"TestSuites"> | string | null
    createdBy?: StringNullableFilter<"TestSuites"> | string | null
    createdAt?: DateTimeFilter<"TestSuites"> | Date | string
    updatedAt?: DateTimeFilter<"TestSuites"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    testCases?: TestCaseListRelationFilter
    variables?: TestSuiteVariableListRelationFilter
    functions?: TestSuiteFunctionListRelationFilter
  }, "id">

  export type TestSuitesOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestSuitesCountOrderByAggregateInput
    _avg?: TestSuitesAvgOrderByAggregateInput
    _max?: TestSuitesMaxOrderByAggregateInput
    _min?: TestSuitesMinOrderByAggregateInput
    _sum?: TestSuitesSumOrderByAggregateInput
  }

  export type TestSuitesScalarWhereWithAggregatesInput = {
    AND?: TestSuitesScalarWhereWithAggregatesInput | TestSuitesScalarWhereWithAggregatesInput[]
    OR?: TestSuitesScalarWhereWithAggregatesInput[]
    NOT?: TestSuitesScalarWhereWithAggregatesInput | TestSuitesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TestSuites"> | number
    projectId?: IntWithAggregatesFilter<"TestSuites"> | number
    name?: StringWithAggregatesFilter<"TestSuites"> | string
    description?: StringNullableWithAggregatesFilter<"TestSuites"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"TestSuites"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TestSuites"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestSuites"> | Date | string
  }

  export type ProjectVariableWhereInput = {
    AND?: ProjectVariableWhereInput | ProjectVariableWhereInput[]
    OR?: ProjectVariableWhereInput[]
    NOT?: ProjectVariableWhereInput | ProjectVariableWhereInput[]
    id?: IntFilter<"ProjectVariable"> | number
    projectId?: IntFilter<"ProjectVariable"> | number
    name?: StringFilter<"ProjectVariable"> | string
    value?: StringFilter<"ProjectVariable"> | string
    description?: StringNullableFilter<"ProjectVariable"> | string | null
    createdBy?: StringNullableFilter<"ProjectVariable"> | string | null
    createdAt?: DateTimeFilter<"ProjectVariable"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectVariable"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ProjectVariableOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type ProjectVariableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId_name?: ProjectVariableProjectIdNameCompoundUniqueInput
    AND?: ProjectVariableWhereInput | ProjectVariableWhereInput[]
    OR?: ProjectVariableWhereInput[]
    NOT?: ProjectVariableWhereInput | ProjectVariableWhereInput[]
    projectId?: IntFilter<"ProjectVariable"> | number
    name?: StringFilter<"ProjectVariable"> | string
    value?: StringFilter<"ProjectVariable"> | string
    description?: StringNullableFilter<"ProjectVariable"> | string | null
    createdBy?: StringNullableFilter<"ProjectVariable"> | string | null
    createdAt?: DateTimeFilter<"ProjectVariable"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectVariable"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "projectId_name">

  export type ProjectVariableOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectVariableCountOrderByAggregateInput
    _avg?: ProjectVariableAvgOrderByAggregateInput
    _max?: ProjectVariableMaxOrderByAggregateInput
    _min?: ProjectVariableMinOrderByAggregateInput
    _sum?: ProjectVariableSumOrderByAggregateInput
  }

  export type ProjectVariableScalarWhereWithAggregatesInput = {
    AND?: ProjectVariableScalarWhereWithAggregatesInput | ProjectVariableScalarWhereWithAggregatesInput[]
    OR?: ProjectVariableScalarWhereWithAggregatesInput[]
    NOT?: ProjectVariableScalarWhereWithAggregatesInput | ProjectVariableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectVariable"> | number
    projectId?: IntWithAggregatesFilter<"ProjectVariable"> | number
    name?: StringWithAggregatesFilter<"ProjectVariable"> | string
    value?: StringWithAggregatesFilter<"ProjectVariable"> | string
    description?: StringNullableWithAggregatesFilter<"ProjectVariable"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"ProjectVariable"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProjectVariable"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectVariable"> | Date | string
  }

  export type TestSuiteVariableWhereInput = {
    AND?: TestSuiteVariableWhereInput | TestSuiteVariableWhereInput[]
    OR?: TestSuiteVariableWhereInput[]
    NOT?: TestSuiteVariableWhereInput | TestSuiteVariableWhereInput[]
    id?: IntFilter<"TestSuiteVariable"> | number
    testSuiteId?: IntFilter<"TestSuiteVariable"> | number
    name?: StringFilter<"TestSuiteVariable"> | string
    value?: StringFilter<"TestSuiteVariable"> | string
    description?: StringNullableFilter<"TestSuiteVariable"> | string | null
    createdBy?: StringNullableFilter<"TestSuiteVariable"> | string | null
    createdAt?: DateTimeFilter<"TestSuiteVariable"> | Date | string
    updatedAt?: DateTimeFilter<"TestSuiteVariable"> | Date | string
    testSuite?: XOR<TestSuitesScalarRelationFilter, TestSuitesWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TestSuiteVariableOrderByWithRelationInput = {
    id?: SortOrder
    testSuiteId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    testSuite?: TestSuitesOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type TestSuiteVariableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    testSuiteId_name?: TestSuiteVariableTestSuiteIdNameCompoundUniqueInput
    AND?: TestSuiteVariableWhereInput | TestSuiteVariableWhereInput[]
    OR?: TestSuiteVariableWhereInput[]
    NOT?: TestSuiteVariableWhereInput | TestSuiteVariableWhereInput[]
    testSuiteId?: IntFilter<"TestSuiteVariable"> | number
    name?: StringFilter<"TestSuiteVariable"> | string
    value?: StringFilter<"TestSuiteVariable"> | string
    description?: StringNullableFilter<"TestSuiteVariable"> | string | null
    createdBy?: StringNullableFilter<"TestSuiteVariable"> | string | null
    createdAt?: DateTimeFilter<"TestSuiteVariable"> | Date | string
    updatedAt?: DateTimeFilter<"TestSuiteVariable"> | Date | string
    testSuite?: XOR<TestSuitesScalarRelationFilter, TestSuitesWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "testSuiteId_name">

  export type TestSuiteVariableOrderByWithAggregationInput = {
    id?: SortOrder
    testSuiteId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestSuiteVariableCountOrderByAggregateInput
    _avg?: TestSuiteVariableAvgOrderByAggregateInput
    _max?: TestSuiteVariableMaxOrderByAggregateInput
    _min?: TestSuiteVariableMinOrderByAggregateInput
    _sum?: TestSuiteVariableSumOrderByAggregateInput
  }

  export type TestSuiteVariableScalarWhereWithAggregatesInput = {
    AND?: TestSuiteVariableScalarWhereWithAggregatesInput | TestSuiteVariableScalarWhereWithAggregatesInput[]
    OR?: TestSuiteVariableScalarWhereWithAggregatesInput[]
    NOT?: TestSuiteVariableScalarWhereWithAggregatesInput | TestSuiteVariableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TestSuiteVariable"> | number
    testSuiteId?: IntWithAggregatesFilter<"TestSuiteVariable"> | number
    name?: StringWithAggregatesFilter<"TestSuiteVariable"> | string
    value?: StringWithAggregatesFilter<"TestSuiteVariable"> | string
    description?: StringNullableWithAggregatesFilter<"TestSuiteVariable"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"TestSuiteVariable"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TestSuiteVariable"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestSuiteVariable"> | Date | string
  }

  export type ProjectFunctionWhereInput = {
    AND?: ProjectFunctionWhereInput | ProjectFunctionWhereInput[]
    OR?: ProjectFunctionWhereInput[]
    NOT?: ProjectFunctionWhereInput | ProjectFunctionWhereInput[]
    id?: IntFilter<"ProjectFunction"> | number
    projectId?: IntFilter<"ProjectFunction"> | number
    name?: StringFilter<"ProjectFunction"> | string
    code?: StringFilter<"ProjectFunction"> | string
    description?: StringNullableFilter<"ProjectFunction"> | string | null
    createdBy?: StringNullableFilter<"ProjectFunction"> | string | null
    createdAt?: DateTimeFilter<"ProjectFunction"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectFunction"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ProjectFunctionOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type ProjectFunctionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId_name?: ProjectFunctionProjectIdNameCompoundUniqueInput
    AND?: ProjectFunctionWhereInput | ProjectFunctionWhereInput[]
    OR?: ProjectFunctionWhereInput[]
    NOT?: ProjectFunctionWhereInput | ProjectFunctionWhereInput[]
    projectId?: IntFilter<"ProjectFunction"> | number
    name?: StringFilter<"ProjectFunction"> | string
    code?: StringFilter<"ProjectFunction"> | string
    description?: StringNullableFilter<"ProjectFunction"> | string | null
    createdBy?: StringNullableFilter<"ProjectFunction"> | string | null
    createdAt?: DateTimeFilter<"ProjectFunction"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectFunction"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "projectId_name">

  export type ProjectFunctionOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectFunctionCountOrderByAggregateInput
    _avg?: ProjectFunctionAvgOrderByAggregateInput
    _max?: ProjectFunctionMaxOrderByAggregateInput
    _min?: ProjectFunctionMinOrderByAggregateInput
    _sum?: ProjectFunctionSumOrderByAggregateInput
  }

  export type ProjectFunctionScalarWhereWithAggregatesInput = {
    AND?: ProjectFunctionScalarWhereWithAggregatesInput | ProjectFunctionScalarWhereWithAggregatesInput[]
    OR?: ProjectFunctionScalarWhereWithAggregatesInput[]
    NOT?: ProjectFunctionScalarWhereWithAggregatesInput | ProjectFunctionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectFunction"> | number
    projectId?: IntWithAggregatesFilter<"ProjectFunction"> | number
    name?: StringWithAggregatesFilter<"ProjectFunction"> | string
    code?: StringWithAggregatesFilter<"ProjectFunction"> | string
    description?: StringNullableWithAggregatesFilter<"ProjectFunction"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"ProjectFunction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProjectFunction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectFunction"> | Date | string
  }

  export type TestSuiteFunctionWhereInput = {
    AND?: TestSuiteFunctionWhereInput | TestSuiteFunctionWhereInput[]
    OR?: TestSuiteFunctionWhereInput[]
    NOT?: TestSuiteFunctionWhereInput | TestSuiteFunctionWhereInput[]
    id?: IntFilter<"TestSuiteFunction"> | number
    testSuiteId?: IntFilter<"TestSuiteFunction"> | number
    name?: StringFilter<"TestSuiteFunction"> | string
    code?: StringFilter<"TestSuiteFunction"> | string
    description?: StringNullableFilter<"TestSuiteFunction"> | string | null
    createdBy?: StringNullableFilter<"TestSuiteFunction"> | string | null
    createdAt?: DateTimeFilter<"TestSuiteFunction"> | Date | string
    updatedAt?: DateTimeFilter<"TestSuiteFunction"> | Date | string
    testSuite?: XOR<TestSuitesScalarRelationFilter, TestSuitesWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TestSuiteFunctionOrderByWithRelationInput = {
    id?: SortOrder
    testSuiteId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    testSuite?: TestSuitesOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type TestSuiteFunctionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    testSuiteId_name?: TestSuiteFunctionTestSuiteIdNameCompoundUniqueInput
    AND?: TestSuiteFunctionWhereInput | TestSuiteFunctionWhereInput[]
    OR?: TestSuiteFunctionWhereInput[]
    NOT?: TestSuiteFunctionWhereInput | TestSuiteFunctionWhereInput[]
    testSuiteId?: IntFilter<"TestSuiteFunction"> | number
    name?: StringFilter<"TestSuiteFunction"> | string
    code?: StringFilter<"TestSuiteFunction"> | string
    description?: StringNullableFilter<"TestSuiteFunction"> | string | null
    createdBy?: StringNullableFilter<"TestSuiteFunction"> | string | null
    createdAt?: DateTimeFilter<"TestSuiteFunction"> | Date | string
    updatedAt?: DateTimeFilter<"TestSuiteFunction"> | Date | string
    testSuite?: XOR<TestSuitesScalarRelationFilter, TestSuitesWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "testSuiteId_name">

  export type TestSuiteFunctionOrderByWithAggregationInput = {
    id?: SortOrder
    testSuiteId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestSuiteFunctionCountOrderByAggregateInput
    _avg?: TestSuiteFunctionAvgOrderByAggregateInput
    _max?: TestSuiteFunctionMaxOrderByAggregateInput
    _min?: TestSuiteFunctionMinOrderByAggregateInput
    _sum?: TestSuiteFunctionSumOrderByAggregateInput
  }

  export type TestSuiteFunctionScalarWhereWithAggregatesInput = {
    AND?: TestSuiteFunctionScalarWhereWithAggregatesInput | TestSuiteFunctionScalarWhereWithAggregatesInput[]
    OR?: TestSuiteFunctionScalarWhereWithAggregatesInput[]
    NOT?: TestSuiteFunctionScalarWhereWithAggregatesInput | TestSuiteFunctionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TestSuiteFunction"> | number
    testSuiteId?: IntWithAggregatesFilter<"TestSuiteFunction"> | number
    name?: StringWithAggregatesFilter<"TestSuiteFunction"> | string
    code?: StringWithAggregatesFilter<"TestSuiteFunction"> | string
    description?: StringNullableWithAggregatesFilter<"TestSuiteFunction"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"TestSuiteFunction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TestSuiteFunction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestSuiteFunction"> | Date | string
  }

  export type PageWhereInput = {
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    id?: IntFilter<"Page"> | number
    projectId?: IntFilter<"Page"> | number
    name?: StringFilter<"Page"> | string
    url?: StringFilter<"Page"> | string
    description?: StringNullableFilter<"Page"> | string | null
    isProtected?: BoolFilter<"Page"> | boolean
    authFunction?: StringNullableFilter<"Page"> | string | null
    createdBy?: StringNullableFilter<"Page"> | string | null
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    elements?: PageElementListRelationFilter
  }

  export type PageOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    description?: SortOrderInput | SortOrder
    isProtected?: SortOrder
    authFunction?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    elements?: PageElementOrderByRelationAggregateInput
  }

  export type PageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    projectId?: IntFilter<"Page"> | number
    name?: StringFilter<"Page"> | string
    url?: StringFilter<"Page"> | string
    description?: StringNullableFilter<"Page"> | string | null
    isProtected?: BoolFilter<"Page"> | boolean
    authFunction?: StringNullableFilter<"Page"> | string | null
    createdBy?: StringNullableFilter<"Page"> | string | null
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    elements?: PageElementListRelationFilter
  }, "id">

  export type PageOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    description?: SortOrderInput | SortOrder
    isProtected?: SortOrder
    authFunction?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PageCountOrderByAggregateInput
    _avg?: PageAvgOrderByAggregateInput
    _max?: PageMaxOrderByAggregateInput
    _min?: PageMinOrderByAggregateInput
    _sum?: PageSumOrderByAggregateInput
  }

  export type PageScalarWhereWithAggregatesInput = {
    AND?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    OR?: PageScalarWhereWithAggregatesInput[]
    NOT?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Page"> | number
    projectId?: IntWithAggregatesFilter<"Page"> | number
    name?: StringWithAggregatesFilter<"Page"> | string
    url?: StringWithAggregatesFilter<"Page"> | string
    description?: StringNullableWithAggregatesFilter<"Page"> | string | null
    isProtected?: BoolWithAggregatesFilter<"Page"> | boolean
    authFunction?: StringNullableWithAggregatesFilter<"Page"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Page"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Page"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Page"> | Date | string
  }

  export type PageElementWhereInput = {
    AND?: PageElementWhereInput | PageElementWhereInput[]
    OR?: PageElementWhereInput[]
    NOT?: PageElementWhereInput | PageElementWhereInput[]
    id?: IntFilter<"PageElement"> | number
    pageId?: IntFilter<"PageElement"> | number
    elementName?: StringFilter<"PageElement"> | string
    selector?: StringFilter<"PageElement"> | string
    description?: StringNullableFilter<"PageElement"> | string | null
    createdBy?: StringNullableFilter<"PageElement"> | string | null
    createdAt?: DateTimeFilter<"PageElement"> | Date | string
    updatedAt?: DateTimeFilter<"PageElement"> | Date | string
    page?: XOR<PageScalarRelationFilter, PageWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PageElementOrderByWithRelationInput = {
    id?: SortOrder
    pageId?: SortOrder
    elementName?: SortOrder
    selector?: SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    page?: PageOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type PageElementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PageElementWhereInput | PageElementWhereInput[]
    OR?: PageElementWhereInput[]
    NOT?: PageElementWhereInput | PageElementWhereInput[]
    pageId?: IntFilter<"PageElement"> | number
    elementName?: StringFilter<"PageElement"> | string
    selector?: StringFilter<"PageElement"> | string
    description?: StringNullableFilter<"PageElement"> | string | null
    createdBy?: StringNullableFilter<"PageElement"> | string | null
    createdAt?: DateTimeFilter<"PageElement"> | Date | string
    updatedAt?: DateTimeFilter<"PageElement"> | Date | string
    page?: XOR<PageScalarRelationFilter, PageWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type PageElementOrderByWithAggregationInput = {
    id?: SortOrder
    pageId?: SortOrder
    elementName?: SortOrder
    selector?: SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PageElementCountOrderByAggregateInput
    _avg?: PageElementAvgOrderByAggregateInput
    _max?: PageElementMaxOrderByAggregateInput
    _min?: PageElementMinOrderByAggregateInput
    _sum?: PageElementSumOrderByAggregateInput
  }

  export type PageElementScalarWhereWithAggregatesInput = {
    AND?: PageElementScalarWhereWithAggregatesInput | PageElementScalarWhereWithAggregatesInput[]
    OR?: PageElementScalarWhereWithAggregatesInput[]
    NOT?: PageElementScalarWhereWithAggregatesInput | PageElementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PageElement"> | number
    pageId?: IntWithAggregatesFilter<"PageElement"> | number
    elementName?: StringWithAggregatesFilter<"PageElement"> | string
    selector?: StringWithAggregatesFilter<"PageElement"> | string
    description?: StringNullableWithAggregatesFilter<"PageElement"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"PageElement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PageElement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PageElement"> | Date | string
  }

  export type TestCaseWhereInput = {
    AND?: TestCaseWhereInput | TestCaseWhereInput[]
    OR?: TestCaseWhereInput[]
    NOT?: TestCaseWhereInput | TestCaseWhereInput[]
    id?: IntFilter<"TestCase"> | number
    projectId?: IntFilter<"TestCase"> | number
    testSuiteId?: IntNullableFilter<"TestCase"> | number | null
    name?: StringFilter<"TestCase"> | string
    description?: StringNullableFilter<"TestCase"> | string | null
    code?: StringFilter<"TestCase"> | string
    createdBy?: StringNullableFilter<"TestCase"> | string | null
    createdAt?: DateTimeFilter<"TestCase"> | Date | string
    updatedAt?: DateTimeFilter<"TestCase"> | Date | string
    testSuite?: XOR<TestSuitesNullableScalarRelationFilter, TestSuitesWhereInput> | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TestCaseOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    testSuiteId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    code?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    testSuite?: TestSuitesOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type TestCaseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TestCaseWhereInput | TestCaseWhereInput[]
    OR?: TestCaseWhereInput[]
    NOT?: TestCaseWhereInput | TestCaseWhereInput[]
    projectId?: IntFilter<"TestCase"> | number
    testSuiteId?: IntNullableFilter<"TestCase"> | number | null
    name?: StringFilter<"TestCase"> | string
    description?: StringNullableFilter<"TestCase"> | string | null
    code?: StringFilter<"TestCase"> | string
    createdBy?: StringNullableFilter<"TestCase"> | string | null
    createdAt?: DateTimeFilter<"TestCase"> | Date | string
    updatedAt?: DateTimeFilter<"TestCase"> | Date | string
    testSuite?: XOR<TestSuitesNullableScalarRelationFilter, TestSuitesWhereInput> | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type TestCaseOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    testSuiteId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    code?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestCaseCountOrderByAggregateInput
    _avg?: TestCaseAvgOrderByAggregateInput
    _max?: TestCaseMaxOrderByAggregateInput
    _min?: TestCaseMinOrderByAggregateInput
    _sum?: TestCaseSumOrderByAggregateInput
  }

  export type TestCaseScalarWhereWithAggregatesInput = {
    AND?: TestCaseScalarWhereWithAggregatesInput | TestCaseScalarWhereWithAggregatesInput[]
    OR?: TestCaseScalarWhereWithAggregatesInput[]
    NOT?: TestCaseScalarWhereWithAggregatesInput | TestCaseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TestCase"> | number
    projectId?: IntWithAggregatesFilter<"TestCase"> | number
    testSuiteId?: IntNullableWithAggregatesFilter<"TestCase"> | number | null
    name?: StringWithAggregatesFilter<"TestCase"> | string
    description?: StringNullableWithAggregatesFilter<"TestCase"> | string | null
    code?: StringWithAggregatesFilter<"TestCase"> | string
    createdBy?: StringNullableWithAggregatesFilter<"TestCase"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TestCase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestCase"> | Date | string
  }

  export type ProjectInvitationWhereInput = {
    AND?: ProjectInvitationWhereInput | ProjectInvitationWhereInput[]
    OR?: ProjectInvitationWhereInput[]
    NOT?: ProjectInvitationWhereInput | ProjectInvitationWhereInput[]
    id?: IntFilter<"ProjectInvitation"> | number
    projectId?: IntFilter<"ProjectInvitation"> | number
    userId?: StringFilter<"ProjectInvitation"> | string
    invitedBy?: StringFilter<"ProjectInvitation"> | string
    status?: EnumProjectInvitationStatusFilter<"ProjectInvitation"> | $Enums.ProjectInvitationStatus
    expiresAt?: DateTimeFilter<"ProjectInvitation"> | Date | string
    createdAt?: DateTimeFilter<"ProjectInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectInvitation"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    inviter?: XOR<UserScalarRelationFilter, UserWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProjectInvitationOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    invitedBy?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    inviter?: UserOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProjectInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectInvitationWhereInput | ProjectInvitationWhereInput[]
    OR?: ProjectInvitationWhereInput[]
    NOT?: ProjectInvitationWhereInput | ProjectInvitationWhereInput[]
    projectId?: IntFilter<"ProjectInvitation"> | number
    userId?: StringFilter<"ProjectInvitation"> | string
    invitedBy?: StringFilter<"ProjectInvitation"> | string
    status?: EnumProjectInvitationStatusFilter<"ProjectInvitation"> | $Enums.ProjectInvitationStatus
    expiresAt?: DateTimeFilter<"ProjectInvitation"> | Date | string
    createdAt?: DateTimeFilter<"ProjectInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectInvitation"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    inviter?: XOR<UserScalarRelationFilter, UserWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ProjectInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    invitedBy?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectInvitationCountOrderByAggregateInput
    _avg?: ProjectInvitationAvgOrderByAggregateInput
    _max?: ProjectInvitationMaxOrderByAggregateInput
    _min?: ProjectInvitationMinOrderByAggregateInput
    _sum?: ProjectInvitationSumOrderByAggregateInput
  }

  export type ProjectInvitationScalarWhereWithAggregatesInput = {
    AND?: ProjectInvitationScalarWhereWithAggregatesInput | ProjectInvitationScalarWhereWithAggregatesInput[]
    OR?: ProjectInvitationScalarWhereWithAggregatesInput[]
    NOT?: ProjectInvitationScalarWhereWithAggregatesInput | ProjectInvitationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectInvitation"> | number
    projectId?: IntWithAggregatesFilter<"ProjectInvitation"> | number
    userId?: StringWithAggregatesFilter<"ProjectInvitation"> | string
    invitedBy?: StringWithAggregatesFilter<"ProjectInvitation"> | string
    status?: EnumProjectInvitationStatusWithAggregatesFilter<"ProjectInvitation"> | $Enums.ProjectInvitationStatus
    expiresAt?: DateTimeWithAggregatesFilter<"ProjectInvitation"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ProjectInvitation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectInvitation"> | Date | string
  }

  export type UserCreateInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementUncheckedCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableUncheckedCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUncheckedUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUncheckedUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUncheckedUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountCreateInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUncheckedCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationCreateManyInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectCreateInput = {
    name: string
    description?: string | null
    baseUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutCreatedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    pages?: PageCreateNestedManyWithoutProjectInput
    invitations?: ProjectInvitationCreateNestedManyWithoutProjectInput
    testSuites?: TestSuitesCreateNestedManyWithoutProjectInput
    globalVariables?: ProjectVariableCreateNestedManyWithoutProjectInput
    globalFunctions?: ProjectFunctionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    baseUrl?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    pages?: PageUncheckedCreateNestedManyWithoutProjectInput
    invitations?: ProjectInvitationUncheckedCreateNestedManyWithoutProjectInput
    testSuites?: TestSuitesUncheckedCreateNestedManyWithoutProjectInput
    globalVariables?: ProjectVariableUncheckedCreateNestedManyWithoutProjectInput
    globalFunctions?: ProjectFunctionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutCreatedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    pages?: PageUpdateManyWithoutProjectNestedInput
    invitations?: ProjectInvitationUpdateManyWithoutProjectNestedInput
    testSuites?: TestSuitesUpdateManyWithoutProjectNestedInput
    globalVariables?: ProjectVariableUpdateManyWithoutProjectNestedInput
    globalFunctions?: ProjectFunctionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    pages?: PageUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: ProjectInvitationUncheckedUpdateManyWithoutProjectNestedInput
    testSuites?: TestSuitesUncheckedUpdateManyWithoutProjectNestedInput
    globalVariables?: ProjectVariableUncheckedUpdateManyWithoutProjectNestedInput
    globalFunctions?: ProjectFunctionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    baseUrl?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateInput = {
    role: string
    joinedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutProjectMembershipsInput
  }

  export type ProjectMemberUncheckedCreateInput = {
    id?: number
    projectId: number
    userId: string
    role: string
    joinedAt?: Date | string
  }

  export type ProjectMemberUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutProjectMembershipsNestedInput
  }

  export type ProjectMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateManyInput = {
    id?: number
    projectId: number
    userId: string
    role: string
    joinedAt?: Date | string
  }

  export type ProjectMemberUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestSuitesCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTestSuitesInput
    creator?: UserCreateNestedOneWithoutTestSuitesInput
    testCases?: TestCaseCreateNestedManyWithoutTestSuiteInput
    variables?: TestSuiteVariableCreateNestedManyWithoutTestSuiteInput
    functions?: TestSuiteFunctionCreateNestedManyWithoutTestSuiteInput
  }

  export type TestSuitesUncheckedCreateInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testCases?: TestCaseUncheckedCreateNestedManyWithoutTestSuiteInput
    variables?: TestSuiteVariableUncheckedCreateNestedManyWithoutTestSuiteInput
    functions?: TestSuiteFunctionUncheckedCreateNestedManyWithoutTestSuiteInput
  }

  export type TestSuitesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTestSuitesNestedInput
    creator?: UserUpdateOneWithoutTestSuitesNestedInput
    testCases?: TestCaseUpdateManyWithoutTestSuiteNestedInput
    variables?: TestSuiteVariableUpdateManyWithoutTestSuiteNestedInput
    functions?: TestSuiteFunctionUpdateManyWithoutTestSuiteNestedInput
  }

  export type TestSuitesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testCases?: TestCaseUncheckedUpdateManyWithoutTestSuiteNestedInput
    variables?: TestSuiteVariableUncheckedUpdateManyWithoutTestSuiteNestedInput
    functions?: TestSuiteFunctionUncheckedUpdateManyWithoutTestSuiteNestedInput
  }

  export type TestSuitesCreateManyInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestSuitesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestSuitesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectVariableCreateInput = {
    name: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutGlobalVariablesInput
    creator?: UserCreateNestedOneWithoutProjectVariablesInput
  }

  export type ProjectVariableUncheckedCreateInput = {
    id?: number
    projectId: number
    name: string
    value: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectVariableUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutGlobalVariablesNestedInput
    creator?: UserUpdateOneWithoutProjectVariablesNestedInput
  }

  export type ProjectVariableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectVariableCreateManyInput = {
    id?: number
    projectId: number
    name: string
    value: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectVariableUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectVariableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestSuiteVariableCreateInput = {
    name: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testSuite: TestSuitesCreateNestedOneWithoutVariablesInput
    creator?: UserCreateNestedOneWithoutTestSuiteVariablesInput
  }

  export type TestSuiteVariableUncheckedCreateInput = {
    id?: number
    testSuiteId: number
    name: string
    value: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestSuiteVariableUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testSuite?: TestSuitesUpdateOneRequiredWithoutVariablesNestedInput
    creator?: UserUpdateOneWithoutTestSuiteVariablesNestedInput
  }

  export type TestSuiteVariableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    testSuiteId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestSuiteVariableCreateManyInput = {
    id?: number
    testSuiteId: number
    name: string
    value: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestSuiteVariableUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestSuiteVariableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    testSuiteId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFunctionCreateInput = {
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutGlobalFunctionsInput
    creator?: UserCreateNestedOneWithoutProjectFunctionsInput
  }

  export type ProjectFunctionUncheckedCreateInput = {
    id?: number
    projectId: number
    name: string
    code: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectFunctionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutGlobalFunctionsNestedInput
    creator?: UserUpdateOneWithoutProjectFunctionsNestedInput
  }

  export type ProjectFunctionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFunctionCreateManyInput = {
    id?: number
    projectId: number
    name: string
    code: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectFunctionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFunctionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestSuiteFunctionCreateInput = {
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testSuite: TestSuitesCreateNestedOneWithoutFunctionsInput
    creator?: UserCreateNestedOneWithoutTestSuiteFunctionsInput
  }

  export type TestSuiteFunctionUncheckedCreateInput = {
    id?: number
    testSuiteId: number
    name: string
    code: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestSuiteFunctionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testSuite?: TestSuitesUpdateOneRequiredWithoutFunctionsNestedInput
    creator?: UserUpdateOneWithoutTestSuiteFunctionsNestedInput
  }

  export type TestSuiteFunctionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    testSuiteId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestSuiteFunctionCreateManyInput = {
    id?: number
    testSuiteId: number
    name: string
    code: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestSuiteFunctionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestSuiteFunctionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    testSuiteId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageCreateInput = {
    name: string
    url: string
    description?: string | null
    isProtected?: boolean
    authFunction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPagesInput
    creator?: UserCreateNestedOneWithoutCreatedPagesInput
    elements?: PageElementCreateNestedManyWithoutPageInput
  }

  export type PageUncheckedCreateInput = {
    id?: number
    projectId: number
    name: string
    url: string
    description?: string | null
    isProtected?: boolean
    authFunction?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    elements?: PageElementUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProtected?: BoolFieldUpdateOperationsInput | boolean
    authFunction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPagesNestedInput
    creator?: UserUpdateOneWithoutCreatedPagesNestedInput
    elements?: PageElementUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProtected?: BoolFieldUpdateOperationsInput | boolean
    authFunction?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elements?: PageElementUncheckedUpdateManyWithoutPageNestedInput
  }

  export type PageCreateManyInput = {
    id?: number
    projectId: number
    name: string
    url: string
    description?: string | null
    isProtected?: boolean
    authFunction?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProtected?: BoolFieldUpdateOperationsInput | boolean
    authFunction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProtected?: BoolFieldUpdateOperationsInput | boolean
    authFunction?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageElementCreateInput = {
    elementName: string
    selector: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    page: PageCreateNestedOneWithoutElementsInput
    creator?: UserCreateNestedOneWithoutCreatedPageElementsInput
  }

  export type PageElementUncheckedCreateInput = {
    id?: number
    pageId: number
    elementName: string
    selector: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageElementUpdateInput = {
    elementName?: StringFieldUpdateOperationsInput | string
    selector?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    page?: PageUpdateOneRequiredWithoutElementsNestedInput
    creator?: UserUpdateOneWithoutCreatedPageElementsNestedInput
  }

  export type PageElementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pageId?: IntFieldUpdateOperationsInput | number
    elementName?: StringFieldUpdateOperationsInput | string
    selector?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageElementCreateManyInput = {
    id?: number
    pageId: number
    elementName: string
    selector: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageElementUpdateManyMutationInput = {
    elementName?: StringFieldUpdateOperationsInput | string
    selector?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageElementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pageId?: IntFieldUpdateOperationsInput | number
    elementName?: StringFieldUpdateOperationsInput | string
    selector?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestCaseCreateInput = {
    projectId: number
    name: string
    description?: string | null
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    testSuite?: TestSuitesCreateNestedOneWithoutTestCasesInput
    creator?: UserCreateNestedOneWithoutCreatedTestCasesInput
  }

  export type TestCaseUncheckedCreateInput = {
    id?: number
    projectId: number
    testSuiteId?: number | null
    name: string
    description?: string | null
    code: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestCaseUpdateInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testSuite?: TestSuitesUpdateOneWithoutTestCasesNestedInput
    creator?: UserUpdateOneWithoutCreatedTestCasesNestedInput
  }

  export type TestCaseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    testSuiteId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestCaseCreateManyInput = {
    id?: number
    projectId: number
    testSuiteId?: number | null
    name: string
    description?: string | null
    code: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestCaseUpdateManyMutationInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestCaseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    testSuiteId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInvitationCreateInput = {
    status?: $Enums.ProjectInvitationStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutInvitationsInput
    inviter: UserCreateNestedOneWithoutSentInvitationsInput
    user: UserCreateNestedOneWithoutReceivedInvitationsInput
  }

  export type ProjectInvitationUncheckedCreateInput = {
    id?: number
    projectId: number
    userId: string
    invitedBy: string
    status?: $Enums.ProjectInvitationStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectInvitationUpdateInput = {
    status?: EnumProjectInvitationStatusFieldUpdateOperationsInput | $Enums.ProjectInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutInvitationsNestedInput
    inviter?: UserUpdateOneRequiredWithoutSentInvitationsNestedInput
    user?: UserUpdateOneRequiredWithoutReceivedInvitationsNestedInput
  }

  export type ProjectInvitationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectInvitationStatusFieldUpdateOperationsInput | $Enums.ProjectInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInvitationCreateManyInput = {
    id?: number
    projectId: number
    userId: string
    invitedBy: string
    status?: $Enums.ProjectInvitationStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectInvitationUpdateManyMutationInput = {
    status?: EnumProjectInvitationStatusFieldUpdateOperationsInput | $Enums.ProjectInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInvitationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectInvitationStatusFieldUpdateOperationsInput | $Enums.ProjectInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type ProjectMemberListRelationFilter = {
    every?: ProjectMemberWhereInput
    some?: ProjectMemberWhereInput
    none?: ProjectMemberWhereInput
  }

  export type PageListRelationFilter = {
    every?: PageWhereInput
    some?: PageWhereInput
    none?: PageWhereInput
  }

  export type PageElementListRelationFilter = {
    every?: PageElementWhereInput
    some?: PageElementWhereInput
    none?: PageElementWhereInput
  }

  export type TestCaseListRelationFilter = {
    every?: TestCaseWhereInput
    some?: TestCaseWhereInput
    none?: TestCaseWhereInput
  }

  export type ProjectInvitationListRelationFilter = {
    every?: ProjectInvitationWhereInput
    some?: ProjectInvitationWhereInput
    none?: ProjectInvitationWhereInput
  }

  export type ProjectVariableListRelationFilter = {
    every?: ProjectVariableWhereInput
    some?: ProjectVariableWhereInput
    none?: ProjectVariableWhereInput
  }

  export type TestSuiteVariableListRelationFilter = {
    every?: TestSuiteVariableWhereInput
    some?: TestSuiteVariableWhereInput
    none?: TestSuiteVariableWhereInput
  }

  export type ProjectFunctionListRelationFilter = {
    every?: ProjectFunctionWhereInput
    some?: ProjectFunctionWhereInput
    none?: ProjectFunctionWhereInput
  }

  export type TestSuiteFunctionListRelationFilter = {
    every?: TestSuiteFunctionWhereInput
    some?: TestSuiteFunctionWhereInput
    none?: TestSuiteFunctionWhereInput
  }

  export type TestSuitesListRelationFilter = {
    every?: TestSuitesWhereInput
    some?: TestSuitesWhereInput
    none?: TestSuitesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PageElementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestCaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectVariableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestSuiteVariableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectFunctionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestSuiteFunctionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestSuitesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    baseUrl?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    baseUrl?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    baseUrl?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectMemberProjectIdUserIdCompoundUniqueInput = {
    projectId: number
    userId: string
  }

  export type ProjectMemberCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type ProjectMemberAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type ProjectMemberMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type ProjectMemberSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type TestSuitesCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestSuitesAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type TestSuitesMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestSuitesMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestSuitesSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectVariableProjectIdNameCompoundUniqueInput = {
    projectId: number
    name: string
  }

  export type ProjectVariableCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectVariableAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectVariableMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectVariableMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectVariableSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type TestSuitesScalarRelationFilter = {
    is?: TestSuitesWhereInput
    isNot?: TestSuitesWhereInput
  }

  export type TestSuiteVariableTestSuiteIdNameCompoundUniqueInput = {
    testSuiteId: number
    name: string
  }

  export type TestSuiteVariableCountOrderByAggregateInput = {
    id?: SortOrder
    testSuiteId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestSuiteVariableAvgOrderByAggregateInput = {
    id?: SortOrder
    testSuiteId?: SortOrder
  }

  export type TestSuiteVariableMaxOrderByAggregateInput = {
    id?: SortOrder
    testSuiteId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestSuiteVariableMinOrderByAggregateInput = {
    id?: SortOrder
    testSuiteId?: SortOrder
    name?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestSuiteVariableSumOrderByAggregateInput = {
    id?: SortOrder
    testSuiteId?: SortOrder
  }

  export type ProjectFunctionProjectIdNameCompoundUniqueInput = {
    projectId: number
    name: string
  }

  export type ProjectFunctionCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectFunctionAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectFunctionMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectFunctionMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectFunctionSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type TestSuiteFunctionTestSuiteIdNameCompoundUniqueInput = {
    testSuiteId: number
    name: string
  }

  export type TestSuiteFunctionCountOrderByAggregateInput = {
    id?: SortOrder
    testSuiteId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestSuiteFunctionAvgOrderByAggregateInput = {
    id?: SortOrder
    testSuiteId?: SortOrder
  }

  export type TestSuiteFunctionMaxOrderByAggregateInput = {
    id?: SortOrder
    testSuiteId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestSuiteFunctionMinOrderByAggregateInput = {
    id?: SortOrder
    testSuiteId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestSuiteFunctionSumOrderByAggregateInput = {
    id?: SortOrder
    testSuiteId?: SortOrder
  }

  export type PageCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    description?: SortOrder
    isProtected?: SortOrder
    authFunction?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type PageMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    description?: SortOrder
    isProtected?: SortOrder
    authFunction?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    url?: SortOrder
    description?: SortOrder
    isProtected?: SortOrder
    authFunction?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type PageScalarRelationFilter = {
    is?: PageWhereInput
    isNot?: PageWhereInput
  }

  export type PageElementCountOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    elementName?: SortOrder
    selector?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageElementAvgOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
  }

  export type PageElementMaxOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    elementName?: SortOrder
    selector?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageElementMinOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    elementName?: SortOrder
    selector?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageElementSumOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type TestSuitesNullableScalarRelationFilter = {
    is?: TestSuitesWhereInput | null
    isNot?: TestSuitesWhereInput | null
  }

  export type TestCaseCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    testSuiteId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestCaseAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    testSuiteId?: SortOrder
  }

  export type TestCaseMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    testSuiteId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestCaseMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    testSuiteId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestCaseSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    testSuiteId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumProjectInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectInvitationStatus | EnumProjectInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectInvitationStatus[] | ListEnumProjectInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectInvitationStatus[] | ListEnumProjectInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectInvitationStatusFilter<$PrismaModel> | $Enums.ProjectInvitationStatus
  }

  export type ProjectInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    invitedBy?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectInvitationAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    invitedBy?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    invitedBy?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectInvitationSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type EnumProjectInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectInvitationStatus | EnumProjectInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectInvitationStatus[] | ListEnumProjectInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectInvitationStatus[] | ListEnumProjectInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectInvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectInvitationStatusFilter<$PrismaModel>
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput> | ProjectCreateWithoutCreatorInput[] | ProjectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatorInput | ProjectCreateOrConnectWithoutCreatorInput[]
    createMany?: ProjectCreateManyCreatorInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type PageCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PageCreateWithoutCreatorInput, PageUncheckedCreateWithoutCreatorInput> | PageCreateWithoutCreatorInput[] | PageUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PageCreateOrConnectWithoutCreatorInput | PageCreateOrConnectWithoutCreatorInput[]
    createMany?: PageCreateManyCreatorInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type PageElementCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PageElementCreateWithoutCreatorInput, PageElementUncheckedCreateWithoutCreatorInput> | PageElementCreateWithoutCreatorInput[] | PageElementUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PageElementCreateOrConnectWithoutCreatorInput | PageElementCreateOrConnectWithoutCreatorInput[]
    createMany?: PageElementCreateManyCreatorInputEnvelope
    connect?: PageElementWhereUniqueInput | PageElementWhereUniqueInput[]
  }

  export type TestCaseCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TestCaseCreateWithoutCreatorInput, TestCaseUncheckedCreateWithoutCreatorInput> | TestCaseCreateWithoutCreatorInput[] | TestCaseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TestCaseCreateOrConnectWithoutCreatorInput | TestCaseCreateOrConnectWithoutCreatorInput[]
    createMany?: TestCaseCreateManyCreatorInputEnvelope
    connect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
  }

  export type ProjectInvitationCreateNestedManyWithoutInviterInput = {
    create?: XOR<ProjectInvitationCreateWithoutInviterInput, ProjectInvitationUncheckedCreateWithoutInviterInput> | ProjectInvitationCreateWithoutInviterInput[] | ProjectInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: ProjectInvitationCreateOrConnectWithoutInviterInput | ProjectInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: ProjectInvitationCreateManyInviterInputEnvelope
    connect?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
  }

  export type ProjectInvitationCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectInvitationCreateWithoutUserInput, ProjectInvitationUncheckedCreateWithoutUserInput> | ProjectInvitationCreateWithoutUserInput[] | ProjectInvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectInvitationCreateOrConnectWithoutUserInput | ProjectInvitationCreateOrConnectWithoutUserInput[]
    createMany?: ProjectInvitationCreateManyUserInputEnvelope
    connect?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
  }

  export type ProjectVariableCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProjectVariableCreateWithoutCreatorInput, ProjectVariableUncheckedCreateWithoutCreatorInput> | ProjectVariableCreateWithoutCreatorInput[] | ProjectVariableUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectVariableCreateOrConnectWithoutCreatorInput | ProjectVariableCreateOrConnectWithoutCreatorInput[]
    createMany?: ProjectVariableCreateManyCreatorInputEnvelope
    connect?: ProjectVariableWhereUniqueInput | ProjectVariableWhereUniqueInput[]
  }

  export type TestSuiteVariableCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TestSuiteVariableCreateWithoutCreatorInput, TestSuiteVariableUncheckedCreateWithoutCreatorInput> | TestSuiteVariableCreateWithoutCreatorInput[] | TestSuiteVariableUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TestSuiteVariableCreateOrConnectWithoutCreatorInput | TestSuiteVariableCreateOrConnectWithoutCreatorInput[]
    createMany?: TestSuiteVariableCreateManyCreatorInputEnvelope
    connect?: TestSuiteVariableWhereUniqueInput | TestSuiteVariableWhereUniqueInput[]
  }

  export type ProjectFunctionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProjectFunctionCreateWithoutCreatorInput, ProjectFunctionUncheckedCreateWithoutCreatorInput> | ProjectFunctionCreateWithoutCreatorInput[] | ProjectFunctionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectFunctionCreateOrConnectWithoutCreatorInput | ProjectFunctionCreateOrConnectWithoutCreatorInput[]
    createMany?: ProjectFunctionCreateManyCreatorInputEnvelope
    connect?: ProjectFunctionWhereUniqueInput | ProjectFunctionWhereUniqueInput[]
  }

  export type TestSuiteFunctionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TestSuiteFunctionCreateWithoutCreatorInput, TestSuiteFunctionUncheckedCreateWithoutCreatorInput> | TestSuiteFunctionCreateWithoutCreatorInput[] | TestSuiteFunctionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TestSuiteFunctionCreateOrConnectWithoutCreatorInput | TestSuiteFunctionCreateOrConnectWithoutCreatorInput[]
    createMany?: TestSuiteFunctionCreateManyCreatorInputEnvelope
    connect?: TestSuiteFunctionWhereUniqueInput | TestSuiteFunctionWhereUniqueInput[]
  }

  export type TestSuitesCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TestSuitesCreateWithoutCreatorInput, TestSuitesUncheckedCreateWithoutCreatorInput> | TestSuitesCreateWithoutCreatorInput[] | TestSuitesUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TestSuitesCreateOrConnectWithoutCreatorInput | TestSuitesCreateOrConnectWithoutCreatorInput[]
    createMany?: TestSuitesCreateManyCreatorInputEnvelope
    connect?: TestSuitesWhereUniqueInput | TestSuitesWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput> | ProjectCreateWithoutCreatorInput[] | ProjectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatorInput | ProjectCreateOrConnectWithoutCreatorInput[]
    createMany?: ProjectCreateManyCreatorInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type PageUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PageCreateWithoutCreatorInput, PageUncheckedCreateWithoutCreatorInput> | PageCreateWithoutCreatorInput[] | PageUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PageCreateOrConnectWithoutCreatorInput | PageCreateOrConnectWithoutCreatorInput[]
    createMany?: PageCreateManyCreatorInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type PageElementUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PageElementCreateWithoutCreatorInput, PageElementUncheckedCreateWithoutCreatorInput> | PageElementCreateWithoutCreatorInput[] | PageElementUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PageElementCreateOrConnectWithoutCreatorInput | PageElementCreateOrConnectWithoutCreatorInput[]
    createMany?: PageElementCreateManyCreatorInputEnvelope
    connect?: PageElementWhereUniqueInput | PageElementWhereUniqueInput[]
  }

  export type TestCaseUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TestCaseCreateWithoutCreatorInput, TestCaseUncheckedCreateWithoutCreatorInput> | TestCaseCreateWithoutCreatorInput[] | TestCaseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TestCaseCreateOrConnectWithoutCreatorInput | TestCaseCreateOrConnectWithoutCreatorInput[]
    createMany?: TestCaseCreateManyCreatorInputEnvelope
    connect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
  }

  export type ProjectInvitationUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<ProjectInvitationCreateWithoutInviterInput, ProjectInvitationUncheckedCreateWithoutInviterInput> | ProjectInvitationCreateWithoutInviterInput[] | ProjectInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: ProjectInvitationCreateOrConnectWithoutInviterInput | ProjectInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: ProjectInvitationCreateManyInviterInputEnvelope
    connect?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
  }

  export type ProjectInvitationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectInvitationCreateWithoutUserInput, ProjectInvitationUncheckedCreateWithoutUserInput> | ProjectInvitationCreateWithoutUserInput[] | ProjectInvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectInvitationCreateOrConnectWithoutUserInput | ProjectInvitationCreateOrConnectWithoutUserInput[]
    createMany?: ProjectInvitationCreateManyUserInputEnvelope
    connect?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
  }

  export type ProjectVariableUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProjectVariableCreateWithoutCreatorInput, ProjectVariableUncheckedCreateWithoutCreatorInput> | ProjectVariableCreateWithoutCreatorInput[] | ProjectVariableUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectVariableCreateOrConnectWithoutCreatorInput | ProjectVariableCreateOrConnectWithoutCreatorInput[]
    createMany?: ProjectVariableCreateManyCreatorInputEnvelope
    connect?: ProjectVariableWhereUniqueInput | ProjectVariableWhereUniqueInput[]
  }

  export type TestSuiteVariableUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TestSuiteVariableCreateWithoutCreatorInput, TestSuiteVariableUncheckedCreateWithoutCreatorInput> | TestSuiteVariableCreateWithoutCreatorInput[] | TestSuiteVariableUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TestSuiteVariableCreateOrConnectWithoutCreatorInput | TestSuiteVariableCreateOrConnectWithoutCreatorInput[]
    createMany?: TestSuiteVariableCreateManyCreatorInputEnvelope
    connect?: TestSuiteVariableWhereUniqueInput | TestSuiteVariableWhereUniqueInput[]
  }

  export type ProjectFunctionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProjectFunctionCreateWithoutCreatorInput, ProjectFunctionUncheckedCreateWithoutCreatorInput> | ProjectFunctionCreateWithoutCreatorInput[] | ProjectFunctionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectFunctionCreateOrConnectWithoutCreatorInput | ProjectFunctionCreateOrConnectWithoutCreatorInput[]
    createMany?: ProjectFunctionCreateManyCreatorInputEnvelope
    connect?: ProjectFunctionWhereUniqueInput | ProjectFunctionWhereUniqueInput[]
  }

  export type TestSuiteFunctionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TestSuiteFunctionCreateWithoutCreatorInput, TestSuiteFunctionUncheckedCreateWithoutCreatorInput> | TestSuiteFunctionCreateWithoutCreatorInput[] | TestSuiteFunctionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TestSuiteFunctionCreateOrConnectWithoutCreatorInput | TestSuiteFunctionCreateOrConnectWithoutCreatorInput[]
    createMany?: TestSuiteFunctionCreateManyCreatorInputEnvelope
    connect?: TestSuiteFunctionWhereUniqueInput | TestSuiteFunctionWhereUniqueInput[]
  }

  export type TestSuitesUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TestSuitesCreateWithoutCreatorInput, TestSuitesUncheckedCreateWithoutCreatorInput> | TestSuitesCreateWithoutCreatorInput[] | TestSuitesUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TestSuitesCreateOrConnectWithoutCreatorInput | TestSuitesCreateOrConnectWithoutCreatorInput[]
    createMany?: TestSuitesCreateManyCreatorInputEnvelope
    connect?: TestSuitesWhereUniqueInput | TestSuitesWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput> | ProjectCreateWithoutCreatorInput[] | ProjectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatorInput | ProjectCreateOrConnectWithoutCreatorInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCreatorInput | ProjectUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProjectCreateManyCreatorInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCreatorInput | ProjectUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCreatorInput | ProjectUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type PageUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PageCreateWithoutCreatorInput, PageUncheckedCreateWithoutCreatorInput> | PageCreateWithoutCreatorInput[] | PageUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PageCreateOrConnectWithoutCreatorInput | PageCreateOrConnectWithoutCreatorInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutCreatorInput | PageUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PageCreateManyCreatorInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutCreatorInput | PageUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PageUpdateManyWithWhereWithoutCreatorInput | PageUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type PageElementUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PageElementCreateWithoutCreatorInput, PageElementUncheckedCreateWithoutCreatorInput> | PageElementCreateWithoutCreatorInput[] | PageElementUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PageElementCreateOrConnectWithoutCreatorInput | PageElementCreateOrConnectWithoutCreatorInput[]
    upsert?: PageElementUpsertWithWhereUniqueWithoutCreatorInput | PageElementUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PageElementCreateManyCreatorInputEnvelope
    set?: PageElementWhereUniqueInput | PageElementWhereUniqueInput[]
    disconnect?: PageElementWhereUniqueInput | PageElementWhereUniqueInput[]
    delete?: PageElementWhereUniqueInput | PageElementWhereUniqueInput[]
    connect?: PageElementWhereUniqueInput | PageElementWhereUniqueInput[]
    update?: PageElementUpdateWithWhereUniqueWithoutCreatorInput | PageElementUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PageElementUpdateManyWithWhereWithoutCreatorInput | PageElementUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PageElementScalarWhereInput | PageElementScalarWhereInput[]
  }

  export type TestCaseUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TestCaseCreateWithoutCreatorInput, TestCaseUncheckedCreateWithoutCreatorInput> | TestCaseCreateWithoutCreatorInput[] | TestCaseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TestCaseCreateOrConnectWithoutCreatorInput | TestCaseCreateOrConnectWithoutCreatorInput[]
    upsert?: TestCaseUpsertWithWhereUniqueWithoutCreatorInput | TestCaseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TestCaseCreateManyCreatorInputEnvelope
    set?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    disconnect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    delete?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    connect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    update?: TestCaseUpdateWithWhereUniqueWithoutCreatorInput | TestCaseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TestCaseUpdateManyWithWhereWithoutCreatorInput | TestCaseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TestCaseScalarWhereInput | TestCaseScalarWhereInput[]
  }

  export type ProjectInvitationUpdateManyWithoutInviterNestedInput = {
    create?: XOR<ProjectInvitationCreateWithoutInviterInput, ProjectInvitationUncheckedCreateWithoutInviterInput> | ProjectInvitationCreateWithoutInviterInput[] | ProjectInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: ProjectInvitationCreateOrConnectWithoutInviterInput | ProjectInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: ProjectInvitationUpsertWithWhereUniqueWithoutInviterInput | ProjectInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: ProjectInvitationCreateManyInviterInputEnvelope
    set?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    disconnect?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    delete?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    connect?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    update?: ProjectInvitationUpdateWithWhereUniqueWithoutInviterInput | ProjectInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: ProjectInvitationUpdateManyWithWhereWithoutInviterInput | ProjectInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: ProjectInvitationScalarWhereInput | ProjectInvitationScalarWhereInput[]
  }

  export type ProjectInvitationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectInvitationCreateWithoutUserInput, ProjectInvitationUncheckedCreateWithoutUserInput> | ProjectInvitationCreateWithoutUserInput[] | ProjectInvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectInvitationCreateOrConnectWithoutUserInput | ProjectInvitationCreateOrConnectWithoutUserInput[]
    upsert?: ProjectInvitationUpsertWithWhereUniqueWithoutUserInput | ProjectInvitationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectInvitationCreateManyUserInputEnvelope
    set?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    disconnect?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    delete?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    connect?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    update?: ProjectInvitationUpdateWithWhereUniqueWithoutUserInput | ProjectInvitationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectInvitationUpdateManyWithWhereWithoutUserInput | ProjectInvitationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectInvitationScalarWhereInput | ProjectInvitationScalarWhereInput[]
  }

  export type ProjectVariableUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProjectVariableCreateWithoutCreatorInput, ProjectVariableUncheckedCreateWithoutCreatorInput> | ProjectVariableCreateWithoutCreatorInput[] | ProjectVariableUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectVariableCreateOrConnectWithoutCreatorInput | ProjectVariableCreateOrConnectWithoutCreatorInput[]
    upsert?: ProjectVariableUpsertWithWhereUniqueWithoutCreatorInput | ProjectVariableUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProjectVariableCreateManyCreatorInputEnvelope
    set?: ProjectVariableWhereUniqueInput | ProjectVariableWhereUniqueInput[]
    disconnect?: ProjectVariableWhereUniqueInput | ProjectVariableWhereUniqueInput[]
    delete?: ProjectVariableWhereUniqueInput | ProjectVariableWhereUniqueInput[]
    connect?: ProjectVariableWhereUniqueInput | ProjectVariableWhereUniqueInput[]
    update?: ProjectVariableUpdateWithWhereUniqueWithoutCreatorInput | ProjectVariableUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProjectVariableUpdateManyWithWhereWithoutCreatorInput | ProjectVariableUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProjectVariableScalarWhereInput | ProjectVariableScalarWhereInput[]
  }

  export type TestSuiteVariableUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TestSuiteVariableCreateWithoutCreatorInput, TestSuiteVariableUncheckedCreateWithoutCreatorInput> | TestSuiteVariableCreateWithoutCreatorInput[] | TestSuiteVariableUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TestSuiteVariableCreateOrConnectWithoutCreatorInput | TestSuiteVariableCreateOrConnectWithoutCreatorInput[]
    upsert?: TestSuiteVariableUpsertWithWhereUniqueWithoutCreatorInput | TestSuiteVariableUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TestSuiteVariableCreateManyCreatorInputEnvelope
    set?: TestSuiteVariableWhereUniqueInput | TestSuiteVariableWhereUniqueInput[]
    disconnect?: TestSuiteVariableWhereUniqueInput | TestSuiteVariableWhereUniqueInput[]
    delete?: TestSuiteVariableWhereUniqueInput | TestSuiteVariableWhereUniqueInput[]
    connect?: TestSuiteVariableWhereUniqueInput | TestSuiteVariableWhereUniqueInput[]
    update?: TestSuiteVariableUpdateWithWhereUniqueWithoutCreatorInput | TestSuiteVariableUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TestSuiteVariableUpdateManyWithWhereWithoutCreatorInput | TestSuiteVariableUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TestSuiteVariableScalarWhereInput | TestSuiteVariableScalarWhereInput[]
  }

  export type ProjectFunctionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProjectFunctionCreateWithoutCreatorInput, ProjectFunctionUncheckedCreateWithoutCreatorInput> | ProjectFunctionCreateWithoutCreatorInput[] | ProjectFunctionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectFunctionCreateOrConnectWithoutCreatorInput | ProjectFunctionCreateOrConnectWithoutCreatorInput[]
    upsert?: ProjectFunctionUpsertWithWhereUniqueWithoutCreatorInput | ProjectFunctionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProjectFunctionCreateManyCreatorInputEnvelope
    set?: ProjectFunctionWhereUniqueInput | ProjectFunctionWhereUniqueInput[]
    disconnect?: ProjectFunctionWhereUniqueInput | ProjectFunctionWhereUniqueInput[]
    delete?: ProjectFunctionWhereUniqueInput | ProjectFunctionWhereUniqueInput[]
    connect?: ProjectFunctionWhereUniqueInput | ProjectFunctionWhereUniqueInput[]
    update?: ProjectFunctionUpdateWithWhereUniqueWithoutCreatorInput | ProjectFunctionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProjectFunctionUpdateManyWithWhereWithoutCreatorInput | ProjectFunctionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProjectFunctionScalarWhereInput | ProjectFunctionScalarWhereInput[]
  }

  export type TestSuiteFunctionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TestSuiteFunctionCreateWithoutCreatorInput, TestSuiteFunctionUncheckedCreateWithoutCreatorInput> | TestSuiteFunctionCreateWithoutCreatorInput[] | TestSuiteFunctionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TestSuiteFunctionCreateOrConnectWithoutCreatorInput | TestSuiteFunctionCreateOrConnectWithoutCreatorInput[]
    upsert?: TestSuiteFunctionUpsertWithWhereUniqueWithoutCreatorInput | TestSuiteFunctionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TestSuiteFunctionCreateManyCreatorInputEnvelope
    set?: TestSuiteFunctionWhereUniqueInput | TestSuiteFunctionWhereUniqueInput[]
    disconnect?: TestSuiteFunctionWhereUniqueInput | TestSuiteFunctionWhereUniqueInput[]
    delete?: TestSuiteFunctionWhereUniqueInput | TestSuiteFunctionWhereUniqueInput[]
    connect?: TestSuiteFunctionWhereUniqueInput | TestSuiteFunctionWhereUniqueInput[]
    update?: TestSuiteFunctionUpdateWithWhereUniqueWithoutCreatorInput | TestSuiteFunctionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TestSuiteFunctionUpdateManyWithWhereWithoutCreatorInput | TestSuiteFunctionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TestSuiteFunctionScalarWhereInput | TestSuiteFunctionScalarWhereInput[]
  }

  export type TestSuitesUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TestSuitesCreateWithoutCreatorInput, TestSuitesUncheckedCreateWithoutCreatorInput> | TestSuitesCreateWithoutCreatorInput[] | TestSuitesUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TestSuitesCreateOrConnectWithoutCreatorInput | TestSuitesCreateOrConnectWithoutCreatorInput[]
    upsert?: TestSuitesUpsertWithWhereUniqueWithoutCreatorInput | TestSuitesUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TestSuitesCreateManyCreatorInputEnvelope
    set?: TestSuitesWhereUniqueInput | TestSuitesWhereUniqueInput[]
    disconnect?: TestSuitesWhereUniqueInput | TestSuitesWhereUniqueInput[]
    delete?: TestSuitesWhereUniqueInput | TestSuitesWhereUniqueInput[]
    connect?: TestSuitesWhereUniqueInput | TestSuitesWhereUniqueInput[]
    update?: TestSuitesUpdateWithWhereUniqueWithoutCreatorInput | TestSuitesUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TestSuitesUpdateManyWithWhereWithoutCreatorInput | TestSuitesUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TestSuitesScalarWhereInput | TestSuitesScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput> | ProjectCreateWithoutCreatorInput[] | ProjectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatorInput | ProjectCreateOrConnectWithoutCreatorInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCreatorInput | ProjectUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProjectCreateManyCreatorInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCreatorInput | ProjectUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCreatorInput | ProjectUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type PageUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PageCreateWithoutCreatorInput, PageUncheckedCreateWithoutCreatorInput> | PageCreateWithoutCreatorInput[] | PageUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PageCreateOrConnectWithoutCreatorInput | PageCreateOrConnectWithoutCreatorInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutCreatorInput | PageUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PageCreateManyCreatorInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutCreatorInput | PageUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PageUpdateManyWithWhereWithoutCreatorInput | PageUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type PageElementUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PageElementCreateWithoutCreatorInput, PageElementUncheckedCreateWithoutCreatorInput> | PageElementCreateWithoutCreatorInput[] | PageElementUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PageElementCreateOrConnectWithoutCreatorInput | PageElementCreateOrConnectWithoutCreatorInput[]
    upsert?: PageElementUpsertWithWhereUniqueWithoutCreatorInput | PageElementUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PageElementCreateManyCreatorInputEnvelope
    set?: PageElementWhereUniqueInput | PageElementWhereUniqueInput[]
    disconnect?: PageElementWhereUniqueInput | PageElementWhereUniqueInput[]
    delete?: PageElementWhereUniqueInput | PageElementWhereUniqueInput[]
    connect?: PageElementWhereUniqueInput | PageElementWhereUniqueInput[]
    update?: PageElementUpdateWithWhereUniqueWithoutCreatorInput | PageElementUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PageElementUpdateManyWithWhereWithoutCreatorInput | PageElementUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PageElementScalarWhereInput | PageElementScalarWhereInput[]
  }

  export type TestCaseUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TestCaseCreateWithoutCreatorInput, TestCaseUncheckedCreateWithoutCreatorInput> | TestCaseCreateWithoutCreatorInput[] | TestCaseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TestCaseCreateOrConnectWithoutCreatorInput | TestCaseCreateOrConnectWithoutCreatorInput[]
    upsert?: TestCaseUpsertWithWhereUniqueWithoutCreatorInput | TestCaseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TestCaseCreateManyCreatorInputEnvelope
    set?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    disconnect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    delete?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    connect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    update?: TestCaseUpdateWithWhereUniqueWithoutCreatorInput | TestCaseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TestCaseUpdateManyWithWhereWithoutCreatorInput | TestCaseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TestCaseScalarWhereInput | TestCaseScalarWhereInput[]
  }

  export type ProjectInvitationUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<ProjectInvitationCreateWithoutInviterInput, ProjectInvitationUncheckedCreateWithoutInviterInput> | ProjectInvitationCreateWithoutInviterInput[] | ProjectInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: ProjectInvitationCreateOrConnectWithoutInviterInput | ProjectInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: ProjectInvitationUpsertWithWhereUniqueWithoutInviterInput | ProjectInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: ProjectInvitationCreateManyInviterInputEnvelope
    set?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    disconnect?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    delete?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    connect?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    update?: ProjectInvitationUpdateWithWhereUniqueWithoutInviterInput | ProjectInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: ProjectInvitationUpdateManyWithWhereWithoutInviterInput | ProjectInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: ProjectInvitationScalarWhereInput | ProjectInvitationScalarWhereInput[]
  }

  export type ProjectInvitationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectInvitationCreateWithoutUserInput, ProjectInvitationUncheckedCreateWithoutUserInput> | ProjectInvitationCreateWithoutUserInput[] | ProjectInvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectInvitationCreateOrConnectWithoutUserInput | ProjectInvitationCreateOrConnectWithoutUserInput[]
    upsert?: ProjectInvitationUpsertWithWhereUniqueWithoutUserInput | ProjectInvitationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectInvitationCreateManyUserInputEnvelope
    set?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    disconnect?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    delete?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    connect?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    update?: ProjectInvitationUpdateWithWhereUniqueWithoutUserInput | ProjectInvitationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectInvitationUpdateManyWithWhereWithoutUserInput | ProjectInvitationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectInvitationScalarWhereInput | ProjectInvitationScalarWhereInput[]
  }

  export type ProjectVariableUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProjectVariableCreateWithoutCreatorInput, ProjectVariableUncheckedCreateWithoutCreatorInput> | ProjectVariableCreateWithoutCreatorInput[] | ProjectVariableUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectVariableCreateOrConnectWithoutCreatorInput | ProjectVariableCreateOrConnectWithoutCreatorInput[]
    upsert?: ProjectVariableUpsertWithWhereUniqueWithoutCreatorInput | ProjectVariableUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProjectVariableCreateManyCreatorInputEnvelope
    set?: ProjectVariableWhereUniqueInput | ProjectVariableWhereUniqueInput[]
    disconnect?: ProjectVariableWhereUniqueInput | ProjectVariableWhereUniqueInput[]
    delete?: ProjectVariableWhereUniqueInput | ProjectVariableWhereUniqueInput[]
    connect?: ProjectVariableWhereUniqueInput | ProjectVariableWhereUniqueInput[]
    update?: ProjectVariableUpdateWithWhereUniqueWithoutCreatorInput | ProjectVariableUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProjectVariableUpdateManyWithWhereWithoutCreatorInput | ProjectVariableUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProjectVariableScalarWhereInput | ProjectVariableScalarWhereInput[]
  }

  export type TestSuiteVariableUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TestSuiteVariableCreateWithoutCreatorInput, TestSuiteVariableUncheckedCreateWithoutCreatorInput> | TestSuiteVariableCreateWithoutCreatorInput[] | TestSuiteVariableUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TestSuiteVariableCreateOrConnectWithoutCreatorInput | TestSuiteVariableCreateOrConnectWithoutCreatorInput[]
    upsert?: TestSuiteVariableUpsertWithWhereUniqueWithoutCreatorInput | TestSuiteVariableUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TestSuiteVariableCreateManyCreatorInputEnvelope
    set?: TestSuiteVariableWhereUniqueInput | TestSuiteVariableWhereUniqueInput[]
    disconnect?: TestSuiteVariableWhereUniqueInput | TestSuiteVariableWhereUniqueInput[]
    delete?: TestSuiteVariableWhereUniqueInput | TestSuiteVariableWhereUniqueInput[]
    connect?: TestSuiteVariableWhereUniqueInput | TestSuiteVariableWhereUniqueInput[]
    update?: TestSuiteVariableUpdateWithWhereUniqueWithoutCreatorInput | TestSuiteVariableUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TestSuiteVariableUpdateManyWithWhereWithoutCreatorInput | TestSuiteVariableUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TestSuiteVariableScalarWhereInput | TestSuiteVariableScalarWhereInput[]
  }

  export type ProjectFunctionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProjectFunctionCreateWithoutCreatorInput, ProjectFunctionUncheckedCreateWithoutCreatorInput> | ProjectFunctionCreateWithoutCreatorInput[] | ProjectFunctionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectFunctionCreateOrConnectWithoutCreatorInput | ProjectFunctionCreateOrConnectWithoutCreatorInput[]
    upsert?: ProjectFunctionUpsertWithWhereUniqueWithoutCreatorInput | ProjectFunctionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProjectFunctionCreateManyCreatorInputEnvelope
    set?: ProjectFunctionWhereUniqueInput | ProjectFunctionWhereUniqueInput[]
    disconnect?: ProjectFunctionWhereUniqueInput | ProjectFunctionWhereUniqueInput[]
    delete?: ProjectFunctionWhereUniqueInput | ProjectFunctionWhereUniqueInput[]
    connect?: ProjectFunctionWhereUniqueInput | ProjectFunctionWhereUniqueInput[]
    update?: ProjectFunctionUpdateWithWhereUniqueWithoutCreatorInput | ProjectFunctionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProjectFunctionUpdateManyWithWhereWithoutCreatorInput | ProjectFunctionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProjectFunctionScalarWhereInput | ProjectFunctionScalarWhereInput[]
  }

  export type TestSuiteFunctionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TestSuiteFunctionCreateWithoutCreatorInput, TestSuiteFunctionUncheckedCreateWithoutCreatorInput> | TestSuiteFunctionCreateWithoutCreatorInput[] | TestSuiteFunctionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TestSuiteFunctionCreateOrConnectWithoutCreatorInput | TestSuiteFunctionCreateOrConnectWithoutCreatorInput[]
    upsert?: TestSuiteFunctionUpsertWithWhereUniqueWithoutCreatorInput | TestSuiteFunctionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TestSuiteFunctionCreateManyCreatorInputEnvelope
    set?: TestSuiteFunctionWhereUniqueInput | TestSuiteFunctionWhereUniqueInput[]
    disconnect?: TestSuiteFunctionWhereUniqueInput | TestSuiteFunctionWhereUniqueInput[]
    delete?: TestSuiteFunctionWhereUniqueInput | TestSuiteFunctionWhereUniqueInput[]
    connect?: TestSuiteFunctionWhereUniqueInput | TestSuiteFunctionWhereUniqueInput[]
    update?: TestSuiteFunctionUpdateWithWhereUniqueWithoutCreatorInput | TestSuiteFunctionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TestSuiteFunctionUpdateManyWithWhereWithoutCreatorInput | TestSuiteFunctionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TestSuiteFunctionScalarWhereInput | TestSuiteFunctionScalarWhereInput[]
  }

  export type TestSuitesUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TestSuitesCreateWithoutCreatorInput, TestSuitesUncheckedCreateWithoutCreatorInput> | TestSuitesCreateWithoutCreatorInput[] | TestSuitesUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TestSuitesCreateOrConnectWithoutCreatorInput | TestSuitesCreateOrConnectWithoutCreatorInput[]
    upsert?: TestSuitesUpsertWithWhereUniqueWithoutCreatorInput | TestSuitesUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TestSuitesCreateManyCreatorInputEnvelope
    set?: TestSuitesWhereUniqueInput | TestSuitesWhereUniqueInput[]
    disconnect?: TestSuitesWhereUniqueInput | TestSuitesWhereUniqueInput[]
    delete?: TestSuitesWhereUniqueInput | TestSuitesWhereUniqueInput[]
    connect?: TestSuitesWhereUniqueInput | TestSuitesWhereUniqueInput[]
    update?: TestSuitesUpdateWithWhereUniqueWithoutCreatorInput | TestSuitesUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TestSuitesUpdateManyWithWhereWithoutCreatorInput | TestSuitesUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TestSuitesScalarWhereInput | TestSuitesScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutCreatedProjectsInput = {
    create?: XOR<UserCreateWithoutCreatedProjectsInput, UserUncheckedCreateWithoutCreatedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectMemberCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type PageCreateNestedManyWithoutProjectInput = {
    create?: XOR<PageCreateWithoutProjectInput, PageUncheckedCreateWithoutProjectInput> | PageCreateWithoutProjectInput[] | PageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PageCreateOrConnectWithoutProjectInput | PageCreateOrConnectWithoutProjectInput[]
    createMany?: PageCreateManyProjectInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type ProjectInvitationCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectInvitationCreateWithoutProjectInput, ProjectInvitationUncheckedCreateWithoutProjectInput> | ProjectInvitationCreateWithoutProjectInput[] | ProjectInvitationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectInvitationCreateOrConnectWithoutProjectInput | ProjectInvitationCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectInvitationCreateManyProjectInputEnvelope
    connect?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
  }

  export type TestSuitesCreateNestedManyWithoutProjectInput = {
    create?: XOR<TestSuitesCreateWithoutProjectInput, TestSuitesUncheckedCreateWithoutProjectInput> | TestSuitesCreateWithoutProjectInput[] | TestSuitesUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TestSuitesCreateOrConnectWithoutProjectInput | TestSuitesCreateOrConnectWithoutProjectInput[]
    createMany?: TestSuitesCreateManyProjectInputEnvelope
    connect?: TestSuitesWhereUniqueInput | TestSuitesWhereUniqueInput[]
  }

  export type ProjectVariableCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectVariableCreateWithoutProjectInput, ProjectVariableUncheckedCreateWithoutProjectInput> | ProjectVariableCreateWithoutProjectInput[] | ProjectVariableUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectVariableCreateOrConnectWithoutProjectInput | ProjectVariableCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectVariableCreateManyProjectInputEnvelope
    connect?: ProjectVariableWhereUniqueInput | ProjectVariableWhereUniqueInput[]
  }

  export type ProjectFunctionCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectFunctionCreateWithoutProjectInput, ProjectFunctionUncheckedCreateWithoutProjectInput> | ProjectFunctionCreateWithoutProjectInput[] | ProjectFunctionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectFunctionCreateOrConnectWithoutProjectInput | ProjectFunctionCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectFunctionCreateManyProjectInputEnvelope
    connect?: ProjectFunctionWhereUniqueInput | ProjectFunctionWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type PageUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<PageCreateWithoutProjectInput, PageUncheckedCreateWithoutProjectInput> | PageCreateWithoutProjectInput[] | PageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PageCreateOrConnectWithoutProjectInput | PageCreateOrConnectWithoutProjectInput[]
    createMany?: PageCreateManyProjectInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type ProjectInvitationUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectInvitationCreateWithoutProjectInput, ProjectInvitationUncheckedCreateWithoutProjectInput> | ProjectInvitationCreateWithoutProjectInput[] | ProjectInvitationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectInvitationCreateOrConnectWithoutProjectInput | ProjectInvitationCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectInvitationCreateManyProjectInputEnvelope
    connect?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
  }

  export type TestSuitesUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TestSuitesCreateWithoutProjectInput, TestSuitesUncheckedCreateWithoutProjectInput> | TestSuitesCreateWithoutProjectInput[] | TestSuitesUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TestSuitesCreateOrConnectWithoutProjectInput | TestSuitesCreateOrConnectWithoutProjectInput[]
    createMany?: TestSuitesCreateManyProjectInputEnvelope
    connect?: TestSuitesWhereUniqueInput | TestSuitesWhereUniqueInput[]
  }

  export type ProjectVariableUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectVariableCreateWithoutProjectInput, ProjectVariableUncheckedCreateWithoutProjectInput> | ProjectVariableCreateWithoutProjectInput[] | ProjectVariableUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectVariableCreateOrConnectWithoutProjectInput | ProjectVariableCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectVariableCreateManyProjectInputEnvelope
    connect?: ProjectVariableWhereUniqueInput | ProjectVariableWhereUniqueInput[]
  }

  export type ProjectFunctionUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectFunctionCreateWithoutProjectInput, ProjectFunctionUncheckedCreateWithoutProjectInput> | ProjectFunctionCreateWithoutProjectInput[] | ProjectFunctionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectFunctionCreateOrConnectWithoutProjectInput | ProjectFunctionCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectFunctionCreateManyProjectInputEnvelope
    connect?: ProjectFunctionWhereUniqueInput | ProjectFunctionWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCreatedProjectsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedProjectsInput, UserUncheckedCreateWithoutCreatedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedProjectsInput
    upsert?: UserUpsertWithoutCreatedProjectsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedProjectsInput, UserUpdateWithoutCreatedProjectsInput>, UserUncheckedUpdateWithoutCreatedProjectsInput>
  }

  export type ProjectMemberUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type PageUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PageCreateWithoutProjectInput, PageUncheckedCreateWithoutProjectInput> | PageCreateWithoutProjectInput[] | PageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PageCreateOrConnectWithoutProjectInput | PageCreateOrConnectWithoutProjectInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutProjectInput | PageUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PageCreateManyProjectInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutProjectInput | PageUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PageUpdateManyWithWhereWithoutProjectInput | PageUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type ProjectInvitationUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectInvitationCreateWithoutProjectInput, ProjectInvitationUncheckedCreateWithoutProjectInput> | ProjectInvitationCreateWithoutProjectInput[] | ProjectInvitationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectInvitationCreateOrConnectWithoutProjectInput | ProjectInvitationCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectInvitationUpsertWithWhereUniqueWithoutProjectInput | ProjectInvitationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectInvitationCreateManyProjectInputEnvelope
    set?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    disconnect?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    delete?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    connect?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    update?: ProjectInvitationUpdateWithWhereUniqueWithoutProjectInput | ProjectInvitationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectInvitationUpdateManyWithWhereWithoutProjectInput | ProjectInvitationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectInvitationScalarWhereInput | ProjectInvitationScalarWhereInput[]
  }

  export type TestSuitesUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TestSuitesCreateWithoutProjectInput, TestSuitesUncheckedCreateWithoutProjectInput> | TestSuitesCreateWithoutProjectInput[] | TestSuitesUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TestSuitesCreateOrConnectWithoutProjectInput | TestSuitesCreateOrConnectWithoutProjectInput[]
    upsert?: TestSuitesUpsertWithWhereUniqueWithoutProjectInput | TestSuitesUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TestSuitesCreateManyProjectInputEnvelope
    set?: TestSuitesWhereUniqueInput | TestSuitesWhereUniqueInput[]
    disconnect?: TestSuitesWhereUniqueInput | TestSuitesWhereUniqueInput[]
    delete?: TestSuitesWhereUniqueInput | TestSuitesWhereUniqueInput[]
    connect?: TestSuitesWhereUniqueInput | TestSuitesWhereUniqueInput[]
    update?: TestSuitesUpdateWithWhereUniqueWithoutProjectInput | TestSuitesUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TestSuitesUpdateManyWithWhereWithoutProjectInput | TestSuitesUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TestSuitesScalarWhereInput | TestSuitesScalarWhereInput[]
  }

  export type ProjectVariableUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectVariableCreateWithoutProjectInput, ProjectVariableUncheckedCreateWithoutProjectInput> | ProjectVariableCreateWithoutProjectInput[] | ProjectVariableUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectVariableCreateOrConnectWithoutProjectInput | ProjectVariableCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectVariableUpsertWithWhereUniqueWithoutProjectInput | ProjectVariableUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectVariableCreateManyProjectInputEnvelope
    set?: ProjectVariableWhereUniqueInput | ProjectVariableWhereUniqueInput[]
    disconnect?: ProjectVariableWhereUniqueInput | ProjectVariableWhereUniqueInput[]
    delete?: ProjectVariableWhereUniqueInput | ProjectVariableWhereUniqueInput[]
    connect?: ProjectVariableWhereUniqueInput | ProjectVariableWhereUniqueInput[]
    update?: ProjectVariableUpdateWithWhereUniqueWithoutProjectInput | ProjectVariableUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectVariableUpdateManyWithWhereWithoutProjectInput | ProjectVariableUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectVariableScalarWhereInput | ProjectVariableScalarWhereInput[]
  }

  export type ProjectFunctionUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectFunctionCreateWithoutProjectInput, ProjectFunctionUncheckedCreateWithoutProjectInput> | ProjectFunctionCreateWithoutProjectInput[] | ProjectFunctionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectFunctionCreateOrConnectWithoutProjectInput | ProjectFunctionCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectFunctionUpsertWithWhereUniqueWithoutProjectInput | ProjectFunctionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectFunctionCreateManyProjectInputEnvelope
    set?: ProjectFunctionWhereUniqueInput | ProjectFunctionWhereUniqueInput[]
    disconnect?: ProjectFunctionWhereUniqueInput | ProjectFunctionWhereUniqueInput[]
    delete?: ProjectFunctionWhereUniqueInput | ProjectFunctionWhereUniqueInput[]
    connect?: ProjectFunctionWhereUniqueInput | ProjectFunctionWhereUniqueInput[]
    update?: ProjectFunctionUpdateWithWhereUniqueWithoutProjectInput | ProjectFunctionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectFunctionUpdateManyWithWhereWithoutProjectInput | ProjectFunctionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectFunctionScalarWhereInput | ProjectFunctionScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type PageUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PageCreateWithoutProjectInput, PageUncheckedCreateWithoutProjectInput> | PageCreateWithoutProjectInput[] | PageUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PageCreateOrConnectWithoutProjectInput | PageCreateOrConnectWithoutProjectInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutProjectInput | PageUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PageCreateManyProjectInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutProjectInput | PageUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PageUpdateManyWithWhereWithoutProjectInput | PageUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type ProjectInvitationUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectInvitationCreateWithoutProjectInput, ProjectInvitationUncheckedCreateWithoutProjectInput> | ProjectInvitationCreateWithoutProjectInput[] | ProjectInvitationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectInvitationCreateOrConnectWithoutProjectInput | ProjectInvitationCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectInvitationUpsertWithWhereUniqueWithoutProjectInput | ProjectInvitationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectInvitationCreateManyProjectInputEnvelope
    set?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    disconnect?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    delete?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    connect?: ProjectInvitationWhereUniqueInput | ProjectInvitationWhereUniqueInput[]
    update?: ProjectInvitationUpdateWithWhereUniqueWithoutProjectInput | ProjectInvitationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectInvitationUpdateManyWithWhereWithoutProjectInput | ProjectInvitationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectInvitationScalarWhereInput | ProjectInvitationScalarWhereInput[]
  }

  export type TestSuitesUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TestSuitesCreateWithoutProjectInput, TestSuitesUncheckedCreateWithoutProjectInput> | TestSuitesCreateWithoutProjectInput[] | TestSuitesUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TestSuitesCreateOrConnectWithoutProjectInput | TestSuitesCreateOrConnectWithoutProjectInput[]
    upsert?: TestSuitesUpsertWithWhereUniqueWithoutProjectInput | TestSuitesUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TestSuitesCreateManyProjectInputEnvelope
    set?: TestSuitesWhereUniqueInput | TestSuitesWhereUniqueInput[]
    disconnect?: TestSuitesWhereUniqueInput | TestSuitesWhereUniqueInput[]
    delete?: TestSuitesWhereUniqueInput | TestSuitesWhereUniqueInput[]
    connect?: TestSuitesWhereUniqueInput | TestSuitesWhereUniqueInput[]
    update?: TestSuitesUpdateWithWhereUniqueWithoutProjectInput | TestSuitesUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TestSuitesUpdateManyWithWhereWithoutProjectInput | TestSuitesUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TestSuitesScalarWhereInput | TestSuitesScalarWhereInput[]
  }

  export type ProjectVariableUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectVariableCreateWithoutProjectInput, ProjectVariableUncheckedCreateWithoutProjectInput> | ProjectVariableCreateWithoutProjectInput[] | ProjectVariableUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectVariableCreateOrConnectWithoutProjectInput | ProjectVariableCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectVariableUpsertWithWhereUniqueWithoutProjectInput | ProjectVariableUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectVariableCreateManyProjectInputEnvelope
    set?: ProjectVariableWhereUniqueInput | ProjectVariableWhereUniqueInput[]
    disconnect?: ProjectVariableWhereUniqueInput | ProjectVariableWhereUniqueInput[]
    delete?: ProjectVariableWhereUniqueInput | ProjectVariableWhereUniqueInput[]
    connect?: ProjectVariableWhereUniqueInput | ProjectVariableWhereUniqueInput[]
    update?: ProjectVariableUpdateWithWhereUniqueWithoutProjectInput | ProjectVariableUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectVariableUpdateManyWithWhereWithoutProjectInput | ProjectVariableUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectVariableScalarWhereInput | ProjectVariableScalarWhereInput[]
  }

  export type ProjectFunctionUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectFunctionCreateWithoutProjectInput, ProjectFunctionUncheckedCreateWithoutProjectInput> | ProjectFunctionCreateWithoutProjectInput[] | ProjectFunctionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectFunctionCreateOrConnectWithoutProjectInput | ProjectFunctionCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectFunctionUpsertWithWhereUniqueWithoutProjectInput | ProjectFunctionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectFunctionCreateManyProjectInputEnvelope
    set?: ProjectFunctionWhereUniqueInput | ProjectFunctionWhereUniqueInput[]
    disconnect?: ProjectFunctionWhereUniqueInput | ProjectFunctionWhereUniqueInput[]
    delete?: ProjectFunctionWhereUniqueInput | ProjectFunctionWhereUniqueInput[]
    connect?: ProjectFunctionWhereUniqueInput | ProjectFunctionWhereUniqueInput[]
    update?: ProjectFunctionUpdateWithWhereUniqueWithoutProjectInput | ProjectFunctionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectFunctionUpdateManyWithWhereWithoutProjectInput | ProjectFunctionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectFunctionScalarWhereInput | ProjectFunctionScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutMembersInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectMembershipsInput = {
    create?: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    upsert?: ProjectUpsertWithoutMembersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMembersInput, ProjectUpdateWithoutMembersInput>, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutProjectMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMembershipsInput
    upsert?: UserUpsertWithoutProjectMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectMembershipsInput, UserUpdateWithoutProjectMembershipsInput>, UserUncheckedUpdateWithoutProjectMembershipsInput>
  }

  export type ProjectCreateNestedOneWithoutTestSuitesInput = {
    create?: XOR<ProjectCreateWithoutTestSuitesInput, ProjectUncheckedCreateWithoutTestSuitesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTestSuitesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTestSuitesInput = {
    create?: XOR<UserCreateWithoutTestSuitesInput, UserUncheckedCreateWithoutTestSuitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestSuitesInput
    connect?: UserWhereUniqueInput
  }

  export type TestCaseCreateNestedManyWithoutTestSuiteInput = {
    create?: XOR<TestCaseCreateWithoutTestSuiteInput, TestCaseUncheckedCreateWithoutTestSuiteInput> | TestCaseCreateWithoutTestSuiteInput[] | TestCaseUncheckedCreateWithoutTestSuiteInput[]
    connectOrCreate?: TestCaseCreateOrConnectWithoutTestSuiteInput | TestCaseCreateOrConnectWithoutTestSuiteInput[]
    createMany?: TestCaseCreateManyTestSuiteInputEnvelope
    connect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
  }

  export type TestSuiteVariableCreateNestedManyWithoutTestSuiteInput = {
    create?: XOR<TestSuiteVariableCreateWithoutTestSuiteInput, TestSuiteVariableUncheckedCreateWithoutTestSuiteInput> | TestSuiteVariableCreateWithoutTestSuiteInput[] | TestSuiteVariableUncheckedCreateWithoutTestSuiteInput[]
    connectOrCreate?: TestSuiteVariableCreateOrConnectWithoutTestSuiteInput | TestSuiteVariableCreateOrConnectWithoutTestSuiteInput[]
    createMany?: TestSuiteVariableCreateManyTestSuiteInputEnvelope
    connect?: TestSuiteVariableWhereUniqueInput | TestSuiteVariableWhereUniqueInput[]
  }

  export type TestSuiteFunctionCreateNestedManyWithoutTestSuiteInput = {
    create?: XOR<TestSuiteFunctionCreateWithoutTestSuiteInput, TestSuiteFunctionUncheckedCreateWithoutTestSuiteInput> | TestSuiteFunctionCreateWithoutTestSuiteInput[] | TestSuiteFunctionUncheckedCreateWithoutTestSuiteInput[]
    connectOrCreate?: TestSuiteFunctionCreateOrConnectWithoutTestSuiteInput | TestSuiteFunctionCreateOrConnectWithoutTestSuiteInput[]
    createMany?: TestSuiteFunctionCreateManyTestSuiteInputEnvelope
    connect?: TestSuiteFunctionWhereUniqueInput | TestSuiteFunctionWhereUniqueInput[]
  }

  export type TestCaseUncheckedCreateNestedManyWithoutTestSuiteInput = {
    create?: XOR<TestCaseCreateWithoutTestSuiteInput, TestCaseUncheckedCreateWithoutTestSuiteInput> | TestCaseCreateWithoutTestSuiteInput[] | TestCaseUncheckedCreateWithoutTestSuiteInput[]
    connectOrCreate?: TestCaseCreateOrConnectWithoutTestSuiteInput | TestCaseCreateOrConnectWithoutTestSuiteInput[]
    createMany?: TestCaseCreateManyTestSuiteInputEnvelope
    connect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
  }

  export type TestSuiteVariableUncheckedCreateNestedManyWithoutTestSuiteInput = {
    create?: XOR<TestSuiteVariableCreateWithoutTestSuiteInput, TestSuiteVariableUncheckedCreateWithoutTestSuiteInput> | TestSuiteVariableCreateWithoutTestSuiteInput[] | TestSuiteVariableUncheckedCreateWithoutTestSuiteInput[]
    connectOrCreate?: TestSuiteVariableCreateOrConnectWithoutTestSuiteInput | TestSuiteVariableCreateOrConnectWithoutTestSuiteInput[]
    createMany?: TestSuiteVariableCreateManyTestSuiteInputEnvelope
    connect?: TestSuiteVariableWhereUniqueInput | TestSuiteVariableWhereUniqueInput[]
  }

  export type TestSuiteFunctionUncheckedCreateNestedManyWithoutTestSuiteInput = {
    create?: XOR<TestSuiteFunctionCreateWithoutTestSuiteInput, TestSuiteFunctionUncheckedCreateWithoutTestSuiteInput> | TestSuiteFunctionCreateWithoutTestSuiteInput[] | TestSuiteFunctionUncheckedCreateWithoutTestSuiteInput[]
    connectOrCreate?: TestSuiteFunctionCreateOrConnectWithoutTestSuiteInput | TestSuiteFunctionCreateOrConnectWithoutTestSuiteInput[]
    createMany?: TestSuiteFunctionCreateManyTestSuiteInputEnvelope
    connect?: TestSuiteFunctionWhereUniqueInput | TestSuiteFunctionWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutTestSuitesNestedInput = {
    create?: XOR<ProjectCreateWithoutTestSuitesInput, ProjectUncheckedCreateWithoutTestSuitesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTestSuitesInput
    upsert?: ProjectUpsertWithoutTestSuitesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTestSuitesInput, ProjectUpdateWithoutTestSuitesInput>, ProjectUncheckedUpdateWithoutTestSuitesInput>
  }

  export type UserUpdateOneWithoutTestSuitesNestedInput = {
    create?: XOR<UserCreateWithoutTestSuitesInput, UserUncheckedCreateWithoutTestSuitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestSuitesInput
    upsert?: UserUpsertWithoutTestSuitesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTestSuitesInput, UserUpdateWithoutTestSuitesInput>, UserUncheckedUpdateWithoutTestSuitesInput>
  }

  export type TestCaseUpdateManyWithoutTestSuiteNestedInput = {
    create?: XOR<TestCaseCreateWithoutTestSuiteInput, TestCaseUncheckedCreateWithoutTestSuiteInput> | TestCaseCreateWithoutTestSuiteInput[] | TestCaseUncheckedCreateWithoutTestSuiteInput[]
    connectOrCreate?: TestCaseCreateOrConnectWithoutTestSuiteInput | TestCaseCreateOrConnectWithoutTestSuiteInput[]
    upsert?: TestCaseUpsertWithWhereUniqueWithoutTestSuiteInput | TestCaseUpsertWithWhereUniqueWithoutTestSuiteInput[]
    createMany?: TestCaseCreateManyTestSuiteInputEnvelope
    set?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    disconnect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    delete?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    connect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    update?: TestCaseUpdateWithWhereUniqueWithoutTestSuiteInput | TestCaseUpdateWithWhereUniqueWithoutTestSuiteInput[]
    updateMany?: TestCaseUpdateManyWithWhereWithoutTestSuiteInput | TestCaseUpdateManyWithWhereWithoutTestSuiteInput[]
    deleteMany?: TestCaseScalarWhereInput | TestCaseScalarWhereInput[]
  }

  export type TestSuiteVariableUpdateManyWithoutTestSuiteNestedInput = {
    create?: XOR<TestSuiteVariableCreateWithoutTestSuiteInput, TestSuiteVariableUncheckedCreateWithoutTestSuiteInput> | TestSuiteVariableCreateWithoutTestSuiteInput[] | TestSuiteVariableUncheckedCreateWithoutTestSuiteInput[]
    connectOrCreate?: TestSuiteVariableCreateOrConnectWithoutTestSuiteInput | TestSuiteVariableCreateOrConnectWithoutTestSuiteInput[]
    upsert?: TestSuiteVariableUpsertWithWhereUniqueWithoutTestSuiteInput | TestSuiteVariableUpsertWithWhereUniqueWithoutTestSuiteInput[]
    createMany?: TestSuiteVariableCreateManyTestSuiteInputEnvelope
    set?: TestSuiteVariableWhereUniqueInput | TestSuiteVariableWhereUniqueInput[]
    disconnect?: TestSuiteVariableWhereUniqueInput | TestSuiteVariableWhereUniqueInput[]
    delete?: TestSuiteVariableWhereUniqueInput | TestSuiteVariableWhereUniqueInput[]
    connect?: TestSuiteVariableWhereUniqueInput | TestSuiteVariableWhereUniqueInput[]
    update?: TestSuiteVariableUpdateWithWhereUniqueWithoutTestSuiteInput | TestSuiteVariableUpdateWithWhereUniqueWithoutTestSuiteInput[]
    updateMany?: TestSuiteVariableUpdateManyWithWhereWithoutTestSuiteInput | TestSuiteVariableUpdateManyWithWhereWithoutTestSuiteInput[]
    deleteMany?: TestSuiteVariableScalarWhereInput | TestSuiteVariableScalarWhereInput[]
  }

  export type TestSuiteFunctionUpdateManyWithoutTestSuiteNestedInput = {
    create?: XOR<TestSuiteFunctionCreateWithoutTestSuiteInput, TestSuiteFunctionUncheckedCreateWithoutTestSuiteInput> | TestSuiteFunctionCreateWithoutTestSuiteInput[] | TestSuiteFunctionUncheckedCreateWithoutTestSuiteInput[]
    connectOrCreate?: TestSuiteFunctionCreateOrConnectWithoutTestSuiteInput | TestSuiteFunctionCreateOrConnectWithoutTestSuiteInput[]
    upsert?: TestSuiteFunctionUpsertWithWhereUniqueWithoutTestSuiteInput | TestSuiteFunctionUpsertWithWhereUniqueWithoutTestSuiteInput[]
    createMany?: TestSuiteFunctionCreateManyTestSuiteInputEnvelope
    set?: TestSuiteFunctionWhereUniqueInput | TestSuiteFunctionWhereUniqueInput[]
    disconnect?: TestSuiteFunctionWhereUniqueInput | TestSuiteFunctionWhereUniqueInput[]
    delete?: TestSuiteFunctionWhereUniqueInput | TestSuiteFunctionWhereUniqueInput[]
    connect?: TestSuiteFunctionWhereUniqueInput | TestSuiteFunctionWhereUniqueInput[]
    update?: TestSuiteFunctionUpdateWithWhereUniqueWithoutTestSuiteInput | TestSuiteFunctionUpdateWithWhereUniqueWithoutTestSuiteInput[]
    updateMany?: TestSuiteFunctionUpdateManyWithWhereWithoutTestSuiteInput | TestSuiteFunctionUpdateManyWithWhereWithoutTestSuiteInput[]
    deleteMany?: TestSuiteFunctionScalarWhereInput | TestSuiteFunctionScalarWhereInput[]
  }

  export type TestCaseUncheckedUpdateManyWithoutTestSuiteNestedInput = {
    create?: XOR<TestCaseCreateWithoutTestSuiteInput, TestCaseUncheckedCreateWithoutTestSuiteInput> | TestCaseCreateWithoutTestSuiteInput[] | TestCaseUncheckedCreateWithoutTestSuiteInput[]
    connectOrCreate?: TestCaseCreateOrConnectWithoutTestSuiteInput | TestCaseCreateOrConnectWithoutTestSuiteInput[]
    upsert?: TestCaseUpsertWithWhereUniqueWithoutTestSuiteInput | TestCaseUpsertWithWhereUniqueWithoutTestSuiteInput[]
    createMany?: TestCaseCreateManyTestSuiteInputEnvelope
    set?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    disconnect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    delete?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    connect?: TestCaseWhereUniqueInput | TestCaseWhereUniqueInput[]
    update?: TestCaseUpdateWithWhereUniqueWithoutTestSuiteInput | TestCaseUpdateWithWhereUniqueWithoutTestSuiteInput[]
    updateMany?: TestCaseUpdateManyWithWhereWithoutTestSuiteInput | TestCaseUpdateManyWithWhereWithoutTestSuiteInput[]
    deleteMany?: TestCaseScalarWhereInput | TestCaseScalarWhereInput[]
  }

  export type TestSuiteVariableUncheckedUpdateManyWithoutTestSuiteNestedInput = {
    create?: XOR<TestSuiteVariableCreateWithoutTestSuiteInput, TestSuiteVariableUncheckedCreateWithoutTestSuiteInput> | TestSuiteVariableCreateWithoutTestSuiteInput[] | TestSuiteVariableUncheckedCreateWithoutTestSuiteInput[]
    connectOrCreate?: TestSuiteVariableCreateOrConnectWithoutTestSuiteInput | TestSuiteVariableCreateOrConnectWithoutTestSuiteInput[]
    upsert?: TestSuiteVariableUpsertWithWhereUniqueWithoutTestSuiteInput | TestSuiteVariableUpsertWithWhereUniqueWithoutTestSuiteInput[]
    createMany?: TestSuiteVariableCreateManyTestSuiteInputEnvelope
    set?: TestSuiteVariableWhereUniqueInput | TestSuiteVariableWhereUniqueInput[]
    disconnect?: TestSuiteVariableWhereUniqueInput | TestSuiteVariableWhereUniqueInput[]
    delete?: TestSuiteVariableWhereUniqueInput | TestSuiteVariableWhereUniqueInput[]
    connect?: TestSuiteVariableWhereUniqueInput | TestSuiteVariableWhereUniqueInput[]
    update?: TestSuiteVariableUpdateWithWhereUniqueWithoutTestSuiteInput | TestSuiteVariableUpdateWithWhereUniqueWithoutTestSuiteInput[]
    updateMany?: TestSuiteVariableUpdateManyWithWhereWithoutTestSuiteInput | TestSuiteVariableUpdateManyWithWhereWithoutTestSuiteInput[]
    deleteMany?: TestSuiteVariableScalarWhereInput | TestSuiteVariableScalarWhereInput[]
  }

  export type TestSuiteFunctionUncheckedUpdateManyWithoutTestSuiteNestedInput = {
    create?: XOR<TestSuiteFunctionCreateWithoutTestSuiteInput, TestSuiteFunctionUncheckedCreateWithoutTestSuiteInput> | TestSuiteFunctionCreateWithoutTestSuiteInput[] | TestSuiteFunctionUncheckedCreateWithoutTestSuiteInput[]
    connectOrCreate?: TestSuiteFunctionCreateOrConnectWithoutTestSuiteInput | TestSuiteFunctionCreateOrConnectWithoutTestSuiteInput[]
    upsert?: TestSuiteFunctionUpsertWithWhereUniqueWithoutTestSuiteInput | TestSuiteFunctionUpsertWithWhereUniqueWithoutTestSuiteInput[]
    createMany?: TestSuiteFunctionCreateManyTestSuiteInputEnvelope
    set?: TestSuiteFunctionWhereUniqueInput | TestSuiteFunctionWhereUniqueInput[]
    disconnect?: TestSuiteFunctionWhereUniqueInput | TestSuiteFunctionWhereUniqueInput[]
    delete?: TestSuiteFunctionWhereUniqueInput | TestSuiteFunctionWhereUniqueInput[]
    connect?: TestSuiteFunctionWhereUniqueInput | TestSuiteFunctionWhereUniqueInput[]
    update?: TestSuiteFunctionUpdateWithWhereUniqueWithoutTestSuiteInput | TestSuiteFunctionUpdateWithWhereUniqueWithoutTestSuiteInput[]
    updateMany?: TestSuiteFunctionUpdateManyWithWhereWithoutTestSuiteInput | TestSuiteFunctionUpdateManyWithWhereWithoutTestSuiteInput[]
    deleteMany?: TestSuiteFunctionScalarWhereInput | TestSuiteFunctionScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutGlobalVariablesInput = {
    create?: XOR<ProjectCreateWithoutGlobalVariablesInput, ProjectUncheckedCreateWithoutGlobalVariablesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutGlobalVariablesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectVariablesInput = {
    create?: XOR<UserCreateWithoutProjectVariablesInput, UserUncheckedCreateWithoutProjectVariablesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectVariablesInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutGlobalVariablesNestedInput = {
    create?: XOR<ProjectCreateWithoutGlobalVariablesInput, ProjectUncheckedCreateWithoutGlobalVariablesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutGlobalVariablesInput
    upsert?: ProjectUpsertWithoutGlobalVariablesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutGlobalVariablesInput, ProjectUpdateWithoutGlobalVariablesInput>, ProjectUncheckedUpdateWithoutGlobalVariablesInput>
  }

  export type UserUpdateOneWithoutProjectVariablesNestedInput = {
    create?: XOR<UserCreateWithoutProjectVariablesInput, UserUncheckedCreateWithoutProjectVariablesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectVariablesInput
    upsert?: UserUpsertWithoutProjectVariablesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectVariablesInput, UserUpdateWithoutProjectVariablesInput>, UserUncheckedUpdateWithoutProjectVariablesInput>
  }

  export type TestSuitesCreateNestedOneWithoutVariablesInput = {
    create?: XOR<TestSuitesCreateWithoutVariablesInput, TestSuitesUncheckedCreateWithoutVariablesInput>
    connectOrCreate?: TestSuitesCreateOrConnectWithoutVariablesInput
    connect?: TestSuitesWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTestSuiteVariablesInput = {
    create?: XOR<UserCreateWithoutTestSuiteVariablesInput, UserUncheckedCreateWithoutTestSuiteVariablesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestSuiteVariablesInput
    connect?: UserWhereUniqueInput
  }

  export type TestSuitesUpdateOneRequiredWithoutVariablesNestedInput = {
    create?: XOR<TestSuitesCreateWithoutVariablesInput, TestSuitesUncheckedCreateWithoutVariablesInput>
    connectOrCreate?: TestSuitesCreateOrConnectWithoutVariablesInput
    upsert?: TestSuitesUpsertWithoutVariablesInput
    connect?: TestSuitesWhereUniqueInput
    update?: XOR<XOR<TestSuitesUpdateToOneWithWhereWithoutVariablesInput, TestSuitesUpdateWithoutVariablesInput>, TestSuitesUncheckedUpdateWithoutVariablesInput>
  }

  export type UserUpdateOneWithoutTestSuiteVariablesNestedInput = {
    create?: XOR<UserCreateWithoutTestSuiteVariablesInput, UserUncheckedCreateWithoutTestSuiteVariablesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestSuiteVariablesInput
    upsert?: UserUpsertWithoutTestSuiteVariablesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTestSuiteVariablesInput, UserUpdateWithoutTestSuiteVariablesInput>, UserUncheckedUpdateWithoutTestSuiteVariablesInput>
  }

  export type ProjectCreateNestedOneWithoutGlobalFunctionsInput = {
    create?: XOR<ProjectCreateWithoutGlobalFunctionsInput, ProjectUncheckedCreateWithoutGlobalFunctionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutGlobalFunctionsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectFunctionsInput = {
    create?: XOR<UserCreateWithoutProjectFunctionsInput, UserUncheckedCreateWithoutProjectFunctionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectFunctionsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutGlobalFunctionsNestedInput = {
    create?: XOR<ProjectCreateWithoutGlobalFunctionsInput, ProjectUncheckedCreateWithoutGlobalFunctionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutGlobalFunctionsInput
    upsert?: ProjectUpsertWithoutGlobalFunctionsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutGlobalFunctionsInput, ProjectUpdateWithoutGlobalFunctionsInput>, ProjectUncheckedUpdateWithoutGlobalFunctionsInput>
  }

  export type UserUpdateOneWithoutProjectFunctionsNestedInput = {
    create?: XOR<UserCreateWithoutProjectFunctionsInput, UserUncheckedCreateWithoutProjectFunctionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectFunctionsInput
    upsert?: UserUpsertWithoutProjectFunctionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectFunctionsInput, UserUpdateWithoutProjectFunctionsInput>, UserUncheckedUpdateWithoutProjectFunctionsInput>
  }

  export type TestSuitesCreateNestedOneWithoutFunctionsInput = {
    create?: XOR<TestSuitesCreateWithoutFunctionsInput, TestSuitesUncheckedCreateWithoutFunctionsInput>
    connectOrCreate?: TestSuitesCreateOrConnectWithoutFunctionsInput
    connect?: TestSuitesWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTestSuiteFunctionsInput = {
    create?: XOR<UserCreateWithoutTestSuiteFunctionsInput, UserUncheckedCreateWithoutTestSuiteFunctionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestSuiteFunctionsInput
    connect?: UserWhereUniqueInput
  }

  export type TestSuitesUpdateOneRequiredWithoutFunctionsNestedInput = {
    create?: XOR<TestSuitesCreateWithoutFunctionsInput, TestSuitesUncheckedCreateWithoutFunctionsInput>
    connectOrCreate?: TestSuitesCreateOrConnectWithoutFunctionsInput
    upsert?: TestSuitesUpsertWithoutFunctionsInput
    connect?: TestSuitesWhereUniqueInput
    update?: XOR<XOR<TestSuitesUpdateToOneWithWhereWithoutFunctionsInput, TestSuitesUpdateWithoutFunctionsInput>, TestSuitesUncheckedUpdateWithoutFunctionsInput>
  }

  export type UserUpdateOneWithoutTestSuiteFunctionsNestedInput = {
    create?: XOR<UserCreateWithoutTestSuiteFunctionsInput, UserUncheckedCreateWithoutTestSuiteFunctionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestSuiteFunctionsInput
    upsert?: UserUpsertWithoutTestSuiteFunctionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTestSuiteFunctionsInput, UserUpdateWithoutTestSuiteFunctionsInput>, UserUncheckedUpdateWithoutTestSuiteFunctionsInput>
  }

  export type ProjectCreateNestedOneWithoutPagesInput = {
    create?: XOR<ProjectCreateWithoutPagesInput, ProjectUncheckedCreateWithoutPagesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPagesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedPagesInput = {
    create?: XOR<UserCreateWithoutCreatedPagesInput, UserUncheckedCreateWithoutCreatedPagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPagesInput
    connect?: UserWhereUniqueInput
  }

  export type PageElementCreateNestedManyWithoutPageInput = {
    create?: XOR<PageElementCreateWithoutPageInput, PageElementUncheckedCreateWithoutPageInput> | PageElementCreateWithoutPageInput[] | PageElementUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PageElementCreateOrConnectWithoutPageInput | PageElementCreateOrConnectWithoutPageInput[]
    createMany?: PageElementCreateManyPageInputEnvelope
    connect?: PageElementWhereUniqueInput | PageElementWhereUniqueInput[]
  }

  export type PageElementUncheckedCreateNestedManyWithoutPageInput = {
    create?: XOR<PageElementCreateWithoutPageInput, PageElementUncheckedCreateWithoutPageInput> | PageElementCreateWithoutPageInput[] | PageElementUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PageElementCreateOrConnectWithoutPageInput | PageElementCreateOrConnectWithoutPageInput[]
    createMany?: PageElementCreateManyPageInputEnvelope
    connect?: PageElementWhereUniqueInput | PageElementWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutPagesNestedInput = {
    create?: XOR<ProjectCreateWithoutPagesInput, ProjectUncheckedCreateWithoutPagesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPagesInput
    upsert?: ProjectUpsertWithoutPagesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutPagesInput, ProjectUpdateWithoutPagesInput>, ProjectUncheckedUpdateWithoutPagesInput>
  }

  export type UserUpdateOneWithoutCreatedPagesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedPagesInput, UserUncheckedCreateWithoutCreatedPagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPagesInput
    upsert?: UserUpsertWithoutCreatedPagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedPagesInput, UserUpdateWithoutCreatedPagesInput>, UserUncheckedUpdateWithoutCreatedPagesInput>
  }

  export type PageElementUpdateManyWithoutPageNestedInput = {
    create?: XOR<PageElementCreateWithoutPageInput, PageElementUncheckedCreateWithoutPageInput> | PageElementCreateWithoutPageInput[] | PageElementUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PageElementCreateOrConnectWithoutPageInput | PageElementCreateOrConnectWithoutPageInput[]
    upsert?: PageElementUpsertWithWhereUniqueWithoutPageInput | PageElementUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: PageElementCreateManyPageInputEnvelope
    set?: PageElementWhereUniqueInput | PageElementWhereUniqueInput[]
    disconnect?: PageElementWhereUniqueInput | PageElementWhereUniqueInput[]
    delete?: PageElementWhereUniqueInput | PageElementWhereUniqueInput[]
    connect?: PageElementWhereUniqueInput | PageElementWhereUniqueInput[]
    update?: PageElementUpdateWithWhereUniqueWithoutPageInput | PageElementUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: PageElementUpdateManyWithWhereWithoutPageInput | PageElementUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: PageElementScalarWhereInput | PageElementScalarWhereInput[]
  }

  export type PageElementUncheckedUpdateManyWithoutPageNestedInput = {
    create?: XOR<PageElementCreateWithoutPageInput, PageElementUncheckedCreateWithoutPageInput> | PageElementCreateWithoutPageInput[] | PageElementUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PageElementCreateOrConnectWithoutPageInput | PageElementCreateOrConnectWithoutPageInput[]
    upsert?: PageElementUpsertWithWhereUniqueWithoutPageInput | PageElementUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: PageElementCreateManyPageInputEnvelope
    set?: PageElementWhereUniqueInput | PageElementWhereUniqueInput[]
    disconnect?: PageElementWhereUniqueInput | PageElementWhereUniqueInput[]
    delete?: PageElementWhereUniqueInput | PageElementWhereUniqueInput[]
    connect?: PageElementWhereUniqueInput | PageElementWhereUniqueInput[]
    update?: PageElementUpdateWithWhereUniqueWithoutPageInput | PageElementUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: PageElementUpdateManyWithWhereWithoutPageInput | PageElementUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: PageElementScalarWhereInput | PageElementScalarWhereInput[]
  }

  export type PageCreateNestedOneWithoutElementsInput = {
    create?: XOR<PageCreateWithoutElementsInput, PageUncheckedCreateWithoutElementsInput>
    connectOrCreate?: PageCreateOrConnectWithoutElementsInput
    connect?: PageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedPageElementsInput = {
    create?: XOR<UserCreateWithoutCreatedPageElementsInput, UserUncheckedCreateWithoutCreatedPageElementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPageElementsInput
    connect?: UserWhereUniqueInput
  }

  export type PageUpdateOneRequiredWithoutElementsNestedInput = {
    create?: XOR<PageCreateWithoutElementsInput, PageUncheckedCreateWithoutElementsInput>
    connectOrCreate?: PageCreateOrConnectWithoutElementsInput
    upsert?: PageUpsertWithoutElementsInput
    connect?: PageWhereUniqueInput
    update?: XOR<XOR<PageUpdateToOneWithWhereWithoutElementsInput, PageUpdateWithoutElementsInput>, PageUncheckedUpdateWithoutElementsInput>
  }

  export type UserUpdateOneWithoutCreatedPageElementsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedPageElementsInput, UserUncheckedCreateWithoutCreatedPageElementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPageElementsInput
    upsert?: UserUpsertWithoutCreatedPageElementsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedPageElementsInput, UserUpdateWithoutCreatedPageElementsInput>, UserUncheckedUpdateWithoutCreatedPageElementsInput>
  }

  export type TestSuitesCreateNestedOneWithoutTestCasesInput = {
    create?: XOR<TestSuitesCreateWithoutTestCasesInput, TestSuitesUncheckedCreateWithoutTestCasesInput>
    connectOrCreate?: TestSuitesCreateOrConnectWithoutTestCasesInput
    connect?: TestSuitesWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedTestCasesInput = {
    create?: XOR<UserCreateWithoutCreatedTestCasesInput, UserUncheckedCreateWithoutCreatedTestCasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTestCasesInput
    connect?: UserWhereUniqueInput
  }

  export type TestSuitesUpdateOneWithoutTestCasesNestedInput = {
    create?: XOR<TestSuitesCreateWithoutTestCasesInput, TestSuitesUncheckedCreateWithoutTestCasesInput>
    connectOrCreate?: TestSuitesCreateOrConnectWithoutTestCasesInput
    upsert?: TestSuitesUpsertWithoutTestCasesInput
    disconnect?: TestSuitesWhereInput | boolean
    delete?: TestSuitesWhereInput | boolean
    connect?: TestSuitesWhereUniqueInput
    update?: XOR<XOR<TestSuitesUpdateToOneWithWhereWithoutTestCasesInput, TestSuitesUpdateWithoutTestCasesInput>, TestSuitesUncheckedUpdateWithoutTestCasesInput>
  }

  export type UserUpdateOneWithoutCreatedTestCasesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTestCasesInput, UserUncheckedCreateWithoutCreatedTestCasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTestCasesInput
    upsert?: UserUpsertWithoutCreatedTestCasesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTestCasesInput, UserUpdateWithoutCreatedTestCasesInput>, UserUncheckedUpdateWithoutCreatedTestCasesInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<ProjectCreateWithoutInvitationsInput, ProjectUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInvitationsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentInvitationsInput = {
    create?: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedInvitationsInput = {
    create?: XOR<UserCreateWithoutReceivedInvitationsInput, UserUncheckedCreateWithoutReceivedInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumProjectInvitationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectInvitationStatus
  }

  export type ProjectUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<ProjectCreateWithoutInvitationsInput, ProjectUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInvitationsInput
    upsert?: ProjectUpsertWithoutInvitationsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutInvitationsInput, ProjectUpdateWithoutInvitationsInput>, ProjectUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserUpdateOneRequiredWithoutSentInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitationsInput
    upsert?: UserUpsertWithoutSentInvitationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentInvitationsInput, UserUpdateWithoutSentInvitationsInput>, UserUncheckedUpdateWithoutSentInvitationsInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedInvitationsInput, UserUncheckedCreateWithoutReceivedInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedInvitationsInput
    upsert?: UserUpsertWithoutReceivedInvitationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedInvitationsInput, UserUpdateWithoutReceivedInvitationsInput>, UserUncheckedUpdateWithoutReceivedInvitationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumProjectInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectInvitationStatus | EnumProjectInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectInvitationStatus[] | ListEnumProjectInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectInvitationStatus[] | ListEnumProjectInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectInvitationStatusFilter<$PrismaModel> | $Enums.ProjectInvitationStatus
  }

  export type NestedEnumProjectInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectInvitationStatus | EnumProjectInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectInvitationStatus[] | ListEnumProjectInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectInvitationStatus[] | ListEnumProjectInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectInvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectInvitationStatusFilter<$PrismaModel>
  }

  export type SessionCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutCreatorInput = {
    name: string
    description?: string | null
    baseUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    pages?: PageCreateNestedManyWithoutProjectInput
    invitations?: ProjectInvitationCreateNestedManyWithoutProjectInput
    testSuites?: TestSuitesCreateNestedManyWithoutProjectInput
    globalVariables?: ProjectVariableCreateNestedManyWithoutProjectInput
    globalFunctions?: ProjectFunctionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCreatorInput = {
    id?: number
    name: string
    description?: string | null
    baseUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    pages?: PageUncheckedCreateNestedManyWithoutProjectInput
    invitations?: ProjectInvitationUncheckedCreateNestedManyWithoutProjectInput
    testSuites?: TestSuitesUncheckedCreateNestedManyWithoutProjectInput
    globalVariables?: ProjectVariableUncheckedCreateNestedManyWithoutProjectInput
    globalFunctions?: ProjectFunctionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCreatorInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput>
  }

  export type ProjectCreateManyCreatorInputEnvelope = {
    data: ProjectCreateManyCreatorInput | ProjectCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMemberCreateWithoutUserInput = {
    role: string
    joinedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
  }

  export type ProjectMemberUncheckedCreateWithoutUserInput = {
    id?: number
    projectId: number
    role: string
    joinedAt?: Date | string
  }

  export type ProjectMemberCreateOrConnectWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberCreateManyUserInputEnvelope = {
    data: ProjectMemberCreateManyUserInput | ProjectMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PageCreateWithoutCreatorInput = {
    name: string
    url: string
    description?: string | null
    isProtected?: boolean
    authFunction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPagesInput
    elements?: PageElementCreateNestedManyWithoutPageInput
  }

  export type PageUncheckedCreateWithoutCreatorInput = {
    id?: number
    projectId: number
    name: string
    url: string
    description?: string | null
    isProtected?: boolean
    authFunction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    elements?: PageElementUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageCreateOrConnectWithoutCreatorInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutCreatorInput, PageUncheckedCreateWithoutCreatorInput>
  }

  export type PageCreateManyCreatorInputEnvelope = {
    data: PageCreateManyCreatorInput | PageCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type PageElementCreateWithoutCreatorInput = {
    elementName: string
    selector: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    page: PageCreateNestedOneWithoutElementsInput
  }

  export type PageElementUncheckedCreateWithoutCreatorInput = {
    id?: number
    pageId: number
    elementName: string
    selector: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageElementCreateOrConnectWithoutCreatorInput = {
    where: PageElementWhereUniqueInput
    create: XOR<PageElementCreateWithoutCreatorInput, PageElementUncheckedCreateWithoutCreatorInput>
  }

  export type PageElementCreateManyCreatorInputEnvelope = {
    data: PageElementCreateManyCreatorInput | PageElementCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type TestCaseCreateWithoutCreatorInput = {
    projectId: number
    name: string
    description?: string | null
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    testSuite?: TestSuitesCreateNestedOneWithoutTestCasesInput
  }

  export type TestCaseUncheckedCreateWithoutCreatorInput = {
    id?: number
    projectId: number
    testSuiteId?: number | null
    name: string
    description?: string | null
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestCaseCreateOrConnectWithoutCreatorInput = {
    where: TestCaseWhereUniqueInput
    create: XOR<TestCaseCreateWithoutCreatorInput, TestCaseUncheckedCreateWithoutCreatorInput>
  }

  export type TestCaseCreateManyCreatorInputEnvelope = {
    data: TestCaseCreateManyCreatorInput | TestCaseCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ProjectInvitationCreateWithoutInviterInput = {
    status?: $Enums.ProjectInvitationStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutInvitationsInput
    user: UserCreateNestedOneWithoutReceivedInvitationsInput
  }

  export type ProjectInvitationUncheckedCreateWithoutInviterInput = {
    id?: number
    projectId: number
    userId: string
    status?: $Enums.ProjectInvitationStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectInvitationCreateOrConnectWithoutInviterInput = {
    where: ProjectInvitationWhereUniqueInput
    create: XOR<ProjectInvitationCreateWithoutInviterInput, ProjectInvitationUncheckedCreateWithoutInviterInput>
  }

  export type ProjectInvitationCreateManyInviterInputEnvelope = {
    data: ProjectInvitationCreateManyInviterInput | ProjectInvitationCreateManyInviterInput[]
    skipDuplicates?: boolean
  }

  export type ProjectInvitationCreateWithoutUserInput = {
    status?: $Enums.ProjectInvitationStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutInvitationsInput
    inviter: UserCreateNestedOneWithoutSentInvitationsInput
  }

  export type ProjectInvitationUncheckedCreateWithoutUserInput = {
    id?: number
    projectId: number
    invitedBy: string
    status?: $Enums.ProjectInvitationStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectInvitationCreateOrConnectWithoutUserInput = {
    where: ProjectInvitationWhereUniqueInput
    create: XOR<ProjectInvitationCreateWithoutUserInput, ProjectInvitationUncheckedCreateWithoutUserInput>
  }

  export type ProjectInvitationCreateManyUserInputEnvelope = {
    data: ProjectInvitationCreateManyUserInput | ProjectInvitationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectVariableCreateWithoutCreatorInput = {
    name: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutGlobalVariablesInput
  }

  export type ProjectVariableUncheckedCreateWithoutCreatorInput = {
    id?: number
    projectId: number
    name: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectVariableCreateOrConnectWithoutCreatorInput = {
    where: ProjectVariableWhereUniqueInput
    create: XOR<ProjectVariableCreateWithoutCreatorInput, ProjectVariableUncheckedCreateWithoutCreatorInput>
  }

  export type ProjectVariableCreateManyCreatorInputEnvelope = {
    data: ProjectVariableCreateManyCreatorInput | ProjectVariableCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type TestSuiteVariableCreateWithoutCreatorInput = {
    name: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testSuite: TestSuitesCreateNestedOneWithoutVariablesInput
  }

  export type TestSuiteVariableUncheckedCreateWithoutCreatorInput = {
    id?: number
    testSuiteId: number
    name: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestSuiteVariableCreateOrConnectWithoutCreatorInput = {
    where: TestSuiteVariableWhereUniqueInput
    create: XOR<TestSuiteVariableCreateWithoutCreatorInput, TestSuiteVariableUncheckedCreateWithoutCreatorInput>
  }

  export type TestSuiteVariableCreateManyCreatorInputEnvelope = {
    data: TestSuiteVariableCreateManyCreatorInput | TestSuiteVariableCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ProjectFunctionCreateWithoutCreatorInput = {
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutGlobalFunctionsInput
  }

  export type ProjectFunctionUncheckedCreateWithoutCreatorInput = {
    id?: number
    projectId: number
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectFunctionCreateOrConnectWithoutCreatorInput = {
    where: ProjectFunctionWhereUniqueInput
    create: XOR<ProjectFunctionCreateWithoutCreatorInput, ProjectFunctionUncheckedCreateWithoutCreatorInput>
  }

  export type ProjectFunctionCreateManyCreatorInputEnvelope = {
    data: ProjectFunctionCreateManyCreatorInput | ProjectFunctionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type TestSuiteFunctionCreateWithoutCreatorInput = {
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testSuite: TestSuitesCreateNestedOneWithoutFunctionsInput
  }

  export type TestSuiteFunctionUncheckedCreateWithoutCreatorInput = {
    id?: number
    testSuiteId: number
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestSuiteFunctionCreateOrConnectWithoutCreatorInput = {
    where: TestSuiteFunctionWhereUniqueInput
    create: XOR<TestSuiteFunctionCreateWithoutCreatorInput, TestSuiteFunctionUncheckedCreateWithoutCreatorInput>
  }

  export type TestSuiteFunctionCreateManyCreatorInputEnvelope = {
    data: TestSuiteFunctionCreateManyCreatorInput | TestSuiteFunctionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type TestSuitesCreateWithoutCreatorInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTestSuitesInput
    testCases?: TestCaseCreateNestedManyWithoutTestSuiteInput
    variables?: TestSuiteVariableCreateNestedManyWithoutTestSuiteInput
    functions?: TestSuiteFunctionCreateNestedManyWithoutTestSuiteInput
  }

  export type TestSuitesUncheckedCreateWithoutCreatorInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testCases?: TestCaseUncheckedCreateNestedManyWithoutTestSuiteInput
    variables?: TestSuiteVariableUncheckedCreateNestedManyWithoutTestSuiteInput
    functions?: TestSuiteFunctionUncheckedCreateNestedManyWithoutTestSuiteInput
  }

  export type TestSuitesCreateOrConnectWithoutCreatorInput = {
    where: TestSuitesWhereUniqueInput
    create: XOR<TestSuitesCreateWithoutCreatorInput, TestSuitesUncheckedCreateWithoutCreatorInput>
  }

  export type TestSuitesCreateManyCreatorInputEnvelope = {
    data: TestSuitesCreateManyCreatorInput | TestSuitesCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutCreatorInput, ProjectUncheckedUpdateWithoutCreatorInput>
    create: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutCreatorInput, ProjectUncheckedUpdateWithoutCreatorInput>
  }

  export type ProjectUpdateManyWithWhereWithoutCreatorInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: IntFilter<"Project"> | number
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    baseUrl?: StringNullableFilter<"Project"> | string | null
    createdBy?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutUserInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectMemberScalarWhereInput = {
    AND?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    OR?: ProjectMemberScalarWhereInput[]
    NOT?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    id?: IntFilter<"ProjectMember"> | number
    projectId?: IntFilter<"ProjectMember"> | number
    userId?: StringFilter<"ProjectMember"> | string
    role?: StringFilter<"ProjectMember"> | string
    joinedAt?: DateTimeFilter<"ProjectMember"> | Date | string
  }

  export type PageUpsertWithWhereUniqueWithoutCreatorInput = {
    where: PageWhereUniqueInput
    update: XOR<PageUpdateWithoutCreatorInput, PageUncheckedUpdateWithoutCreatorInput>
    create: XOR<PageCreateWithoutCreatorInput, PageUncheckedCreateWithoutCreatorInput>
  }

  export type PageUpdateWithWhereUniqueWithoutCreatorInput = {
    where: PageWhereUniqueInput
    data: XOR<PageUpdateWithoutCreatorInput, PageUncheckedUpdateWithoutCreatorInput>
  }

  export type PageUpdateManyWithWhereWithoutCreatorInput = {
    where: PageScalarWhereInput
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyWithoutCreatorInput>
  }

  export type PageScalarWhereInput = {
    AND?: PageScalarWhereInput | PageScalarWhereInput[]
    OR?: PageScalarWhereInput[]
    NOT?: PageScalarWhereInput | PageScalarWhereInput[]
    id?: IntFilter<"Page"> | number
    projectId?: IntFilter<"Page"> | number
    name?: StringFilter<"Page"> | string
    url?: StringFilter<"Page"> | string
    description?: StringNullableFilter<"Page"> | string | null
    isProtected?: BoolFilter<"Page"> | boolean
    authFunction?: StringNullableFilter<"Page"> | string | null
    createdBy?: StringNullableFilter<"Page"> | string | null
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
  }

  export type PageElementUpsertWithWhereUniqueWithoutCreatorInput = {
    where: PageElementWhereUniqueInput
    update: XOR<PageElementUpdateWithoutCreatorInput, PageElementUncheckedUpdateWithoutCreatorInput>
    create: XOR<PageElementCreateWithoutCreatorInput, PageElementUncheckedCreateWithoutCreatorInput>
  }

  export type PageElementUpdateWithWhereUniqueWithoutCreatorInput = {
    where: PageElementWhereUniqueInput
    data: XOR<PageElementUpdateWithoutCreatorInput, PageElementUncheckedUpdateWithoutCreatorInput>
  }

  export type PageElementUpdateManyWithWhereWithoutCreatorInput = {
    where: PageElementScalarWhereInput
    data: XOR<PageElementUpdateManyMutationInput, PageElementUncheckedUpdateManyWithoutCreatorInput>
  }

  export type PageElementScalarWhereInput = {
    AND?: PageElementScalarWhereInput | PageElementScalarWhereInput[]
    OR?: PageElementScalarWhereInput[]
    NOT?: PageElementScalarWhereInput | PageElementScalarWhereInput[]
    id?: IntFilter<"PageElement"> | number
    pageId?: IntFilter<"PageElement"> | number
    elementName?: StringFilter<"PageElement"> | string
    selector?: StringFilter<"PageElement"> | string
    description?: StringNullableFilter<"PageElement"> | string | null
    createdBy?: StringNullableFilter<"PageElement"> | string | null
    createdAt?: DateTimeFilter<"PageElement"> | Date | string
    updatedAt?: DateTimeFilter<"PageElement"> | Date | string
  }

  export type TestCaseUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TestCaseWhereUniqueInput
    update: XOR<TestCaseUpdateWithoutCreatorInput, TestCaseUncheckedUpdateWithoutCreatorInput>
    create: XOR<TestCaseCreateWithoutCreatorInput, TestCaseUncheckedCreateWithoutCreatorInput>
  }

  export type TestCaseUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TestCaseWhereUniqueInput
    data: XOR<TestCaseUpdateWithoutCreatorInput, TestCaseUncheckedUpdateWithoutCreatorInput>
  }

  export type TestCaseUpdateManyWithWhereWithoutCreatorInput = {
    where: TestCaseScalarWhereInput
    data: XOR<TestCaseUpdateManyMutationInput, TestCaseUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TestCaseScalarWhereInput = {
    AND?: TestCaseScalarWhereInput | TestCaseScalarWhereInput[]
    OR?: TestCaseScalarWhereInput[]
    NOT?: TestCaseScalarWhereInput | TestCaseScalarWhereInput[]
    id?: IntFilter<"TestCase"> | number
    projectId?: IntFilter<"TestCase"> | number
    testSuiteId?: IntNullableFilter<"TestCase"> | number | null
    name?: StringFilter<"TestCase"> | string
    description?: StringNullableFilter<"TestCase"> | string | null
    code?: StringFilter<"TestCase"> | string
    createdBy?: StringNullableFilter<"TestCase"> | string | null
    createdAt?: DateTimeFilter<"TestCase"> | Date | string
    updatedAt?: DateTimeFilter<"TestCase"> | Date | string
  }

  export type ProjectInvitationUpsertWithWhereUniqueWithoutInviterInput = {
    where: ProjectInvitationWhereUniqueInput
    update: XOR<ProjectInvitationUpdateWithoutInviterInput, ProjectInvitationUncheckedUpdateWithoutInviterInput>
    create: XOR<ProjectInvitationCreateWithoutInviterInput, ProjectInvitationUncheckedCreateWithoutInviterInput>
  }

  export type ProjectInvitationUpdateWithWhereUniqueWithoutInviterInput = {
    where: ProjectInvitationWhereUniqueInput
    data: XOR<ProjectInvitationUpdateWithoutInviterInput, ProjectInvitationUncheckedUpdateWithoutInviterInput>
  }

  export type ProjectInvitationUpdateManyWithWhereWithoutInviterInput = {
    where: ProjectInvitationScalarWhereInput
    data: XOR<ProjectInvitationUpdateManyMutationInput, ProjectInvitationUncheckedUpdateManyWithoutInviterInput>
  }

  export type ProjectInvitationScalarWhereInput = {
    AND?: ProjectInvitationScalarWhereInput | ProjectInvitationScalarWhereInput[]
    OR?: ProjectInvitationScalarWhereInput[]
    NOT?: ProjectInvitationScalarWhereInput | ProjectInvitationScalarWhereInput[]
    id?: IntFilter<"ProjectInvitation"> | number
    projectId?: IntFilter<"ProjectInvitation"> | number
    userId?: StringFilter<"ProjectInvitation"> | string
    invitedBy?: StringFilter<"ProjectInvitation"> | string
    status?: EnumProjectInvitationStatusFilter<"ProjectInvitation"> | $Enums.ProjectInvitationStatus
    expiresAt?: DateTimeFilter<"ProjectInvitation"> | Date | string
    createdAt?: DateTimeFilter<"ProjectInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectInvitation"> | Date | string
  }

  export type ProjectInvitationUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectInvitationWhereUniqueInput
    update: XOR<ProjectInvitationUpdateWithoutUserInput, ProjectInvitationUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectInvitationCreateWithoutUserInput, ProjectInvitationUncheckedCreateWithoutUserInput>
  }

  export type ProjectInvitationUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectInvitationWhereUniqueInput
    data: XOR<ProjectInvitationUpdateWithoutUserInput, ProjectInvitationUncheckedUpdateWithoutUserInput>
  }

  export type ProjectInvitationUpdateManyWithWhereWithoutUserInput = {
    where: ProjectInvitationScalarWhereInput
    data: XOR<ProjectInvitationUpdateManyMutationInput, ProjectInvitationUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectVariableUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ProjectVariableWhereUniqueInput
    update: XOR<ProjectVariableUpdateWithoutCreatorInput, ProjectVariableUncheckedUpdateWithoutCreatorInput>
    create: XOR<ProjectVariableCreateWithoutCreatorInput, ProjectVariableUncheckedCreateWithoutCreatorInput>
  }

  export type ProjectVariableUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ProjectVariableWhereUniqueInput
    data: XOR<ProjectVariableUpdateWithoutCreatorInput, ProjectVariableUncheckedUpdateWithoutCreatorInput>
  }

  export type ProjectVariableUpdateManyWithWhereWithoutCreatorInput = {
    where: ProjectVariableScalarWhereInput
    data: XOR<ProjectVariableUpdateManyMutationInput, ProjectVariableUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ProjectVariableScalarWhereInput = {
    AND?: ProjectVariableScalarWhereInput | ProjectVariableScalarWhereInput[]
    OR?: ProjectVariableScalarWhereInput[]
    NOT?: ProjectVariableScalarWhereInput | ProjectVariableScalarWhereInput[]
    id?: IntFilter<"ProjectVariable"> | number
    projectId?: IntFilter<"ProjectVariable"> | number
    name?: StringFilter<"ProjectVariable"> | string
    value?: StringFilter<"ProjectVariable"> | string
    description?: StringNullableFilter<"ProjectVariable"> | string | null
    createdBy?: StringNullableFilter<"ProjectVariable"> | string | null
    createdAt?: DateTimeFilter<"ProjectVariable"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectVariable"> | Date | string
  }

  export type TestSuiteVariableUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TestSuiteVariableWhereUniqueInput
    update: XOR<TestSuiteVariableUpdateWithoutCreatorInput, TestSuiteVariableUncheckedUpdateWithoutCreatorInput>
    create: XOR<TestSuiteVariableCreateWithoutCreatorInput, TestSuiteVariableUncheckedCreateWithoutCreatorInput>
  }

  export type TestSuiteVariableUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TestSuiteVariableWhereUniqueInput
    data: XOR<TestSuiteVariableUpdateWithoutCreatorInput, TestSuiteVariableUncheckedUpdateWithoutCreatorInput>
  }

  export type TestSuiteVariableUpdateManyWithWhereWithoutCreatorInput = {
    where: TestSuiteVariableScalarWhereInput
    data: XOR<TestSuiteVariableUpdateManyMutationInput, TestSuiteVariableUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TestSuiteVariableScalarWhereInput = {
    AND?: TestSuiteVariableScalarWhereInput | TestSuiteVariableScalarWhereInput[]
    OR?: TestSuiteVariableScalarWhereInput[]
    NOT?: TestSuiteVariableScalarWhereInput | TestSuiteVariableScalarWhereInput[]
    id?: IntFilter<"TestSuiteVariable"> | number
    testSuiteId?: IntFilter<"TestSuiteVariable"> | number
    name?: StringFilter<"TestSuiteVariable"> | string
    value?: StringFilter<"TestSuiteVariable"> | string
    description?: StringNullableFilter<"TestSuiteVariable"> | string | null
    createdBy?: StringNullableFilter<"TestSuiteVariable"> | string | null
    createdAt?: DateTimeFilter<"TestSuiteVariable"> | Date | string
    updatedAt?: DateTimeFilter<"TestSuiteVariable"> | Date | string
  }

  export type ProjectFunctionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ProjectFunctionWhereUniqueInput
    update: XOR<ProjectFunctionUpdateWithoutCreatorInput, ProjectFunctionUncheckedUpdateWithoutCreatorInput>
    create: XOR<ProjectFunctionCreateWithoutCreatorInput, ProjectFunctionUncheckedCreateWithoutCreatorInput>
  }

  export type ProjectFunctionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ProjectFunctionWhereUniqueInput
    data: XOR<ProjectFunctionUpdateWithoutCreatorInput, ProjectFunctionUncheckedUpdateWithoutCreatorInput>
  }

  export type ProjectFunctionUpdateManyWithWhereWithoutCreatorInput = {
    where: ProjectFunctionScalarWhereInput
    data: XOR<ProjectFunctionUpdateManyMutationInput, ProjectFunctionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ProjectFunctionScalarWhereInput = {
    AND?: ProjectFunctionScalarWhereInput | ProjectFunctionScalarWhereInput[]
    OR?: ProjectFunctionScalarWhereInput[]
    NOT?: ProjectFunctionScalarWhereInput | ProjectFunctionScalarWhereInput[]
    id?: IntFilter<"ProjectFunction"> | number
    projectId?: IntFilter<"ProjectFunction"> | number
    name?: StringFilter<"ProjectFunction"> | string
    code?: StringFilter<"ProjectFunction"> | string
    description?: StringNullableFilter<"ProjectFunction"> | string | null
    createdBy?: StringNullableFilter<"ProjectFunction"> | string | null
    createdAt?: DateTimeFilter<"ProjectFunction"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectFunction"> | Date | string
  }

  export type TestSuiteFunctionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TestSuiteFunctionWhereUniqueInput
    update: XOR<TestSuiteFunctionUpdateWithoutCreatorInput, TestSuiteFunctionUncheckedUpdateWithoutCreatorInput>
    create: XOR<TestSuiteFunctionCreateWithoutCreatorInput, TestSuiteFunctionUncheckedCreateWithoutCreatorInput>
  }

  export type TestSuiteFunctionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TestSuiteFunctionWhereUniqueInput
    data: XOR<TestSuiteFunctionUpdateWithoutCreatorInput, TestSuiteFunctionUncheckedUpdateWithoutCreatorInput>
  }

  export type TestSuiteFunctionUpdateManyWithWhereWithoutCreatorInput = {
    where: TestSuiteFunctionScalarWhereInput
    data: XOR<TestSuiteFunctionUpdateManyMutationInput, TestSuiteFunctionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TestSuiteFunctionScalarWhereInput = {
    AND?: TestSuiteFunctionScalarWhereInput | TestSuiteFunctionScalarWhereInput[]
    OR?: TestSuiteFunctionScalarWhereInput[]
    NOT?: TestSuiteFunctionScalarWhereInput | TestSuiteFunctionScalarWhereInput[]
    id?: IntFilter<"TestSuiteFunction"> | number
    testSuiteId?: IntFilter<"TestSuiteFunction"> | number
    name?: StringFilter<"TestSuiteFunction"> | string
    code?: StringFilter<"TestSuiteFunction"> | string
    description?: StringNullableFilter<"TestSuiteFunction"> | string | null
    createdBy?: StringNullableFilter<"TestSuiteFunction"> | string | null
    createdAt?: DateTimeFilter<"TestSuiteFunction"> | Date | string
    updatedAt?: DateTimeFilter<"TestSuiteFunction"> | Date | string
  }

  export type TestSuitesUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TestSuitesWhereUniqueInput
    update: XOR<TestSuitesUpdateWithoutCreatorInput, TestSuitesUncheckedUpdateWithoutCreatorInput>
    create: XOR<TestSuitesCreateWithoutCreatorInput, TestSuitesUncheckedCreateWithoutCreatorInput>
  }

  export type TestSuitesUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TestSuitesWhereUniqueInput
    data: XOR<TestSuitesUpdateWithoutCreatorInput, TestSuitesUncheckedUpdateWithoutCreatorInput>
  }

  export type TestSuitesUpdateManyWithWhereWithoutCreatorInput = {
    where: TestSuitesScalarWhereInput
    data: XOR<TestSuitesUpdateManyMutationInput, TestSuitesUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TestSuitesScalarWhereInput = {
    AND?: TestSuitesScalarWhereInput | TestSuitesScalarWhereInput[]
    OR?: TestSuitesScalarWhereInput[]
    NOT?: TestSuitesScalarWhereInput | TestSuitesScalarWhereInput[]
    id?: IntFilter<"TestSuites"> | number
    projectId?: IntFilter<"TestSuites"> | number
    name?: StringFilter<"TestSuites"> | string
    description?: StringNullableFilter<"TestSuites"> | string | null
    createdBy?: StringNullableFilter<"TestSuites"> | string | null
    createdAt?: DateTimeFilter<"TestSuites"> | Date | string
    updatedAt?: DateTimeFilter<"TestSuites"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementUncheckedCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableUncheckedCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUncheckedUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUncheckedUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUncheckedUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementUncheckedCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableUncheckedCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUncheckedUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUncheckedUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUncheckedUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutCreatedProjectsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedProjectsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementUncheckedCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableUncheckedCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedProjectsInput, UserUncheckedCreateWithoutCreatedProjectsInput>
  }

  export type ProjectMemberCreateWithoutProjectInput = {
    role: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectMembershipsInput
  }

  export type ProjectMemberUncheckedCreateWithoutProjectInput = {
    id?: number
    userId: string
    role: string
    joinedAt?: Date | string
  }

  export type ProjectMemberCreateOrConnectWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberCreateManyProjectInputEnvelope = {
    data: ProjectMemberCreateManyProjectInput | ProjectMemberCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type PageCreateWithoutProjectInput = {
    name: string
    url: string
    description?: string | null
    isProtected?: boolean
    authFunction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutCreatedPagesInput
    elements?: PageElementCreateNestedManyWithoutPageInput
  }

  export type PageUncheckedCreateWithoutProjectInput = {
    id?: number
    name: string
    url: string
    description?: string | null
    isProtected?: boolean
    authFunction?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    elements?: PageElementUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageCreateOrConnectWithoutProjectInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutProjectInput, PageUncheckedCreateWithoutProjectInput>
  }

  export type PageCreateManyProjectInputEnvelope = {
    data: PageCreateManyProjectInput | PageCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectInvitationCreateWithoutProjectInput = {
    status?: $Enums.ProjectInvitationStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    inviter: UserCreateNestedOneWithoutSentInvitationsInput
    user: UserCreateNestedOneWithoutReceivedInvitationsInput
  }

  export type ProjectInvitationUncheckedCreateWithoutProjectInput = {
    id?: number
    userId: string
    invitedBy: string
    status?: $Enums.ProjectInvitationStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectInvitationCreateOrConnectWithoutProjectInput = {
    where: ProjectInvitationWhereUniqueInput
    create: XOR<ProjectInvitationCreateWithoutProjectInput, ProjectInvitationUncheckedCreateWithoutProjectInput>
  }

  export type ProjectInvitationCreateManyProjectInputEnvelope = {
    data: ProjectInvitationCreateManyProjectInput | ProjectInvitationCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TestSuitesCreateWithoutProjectInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutTestSuitesInput
    testCases?: TestCaseCreateNestedManyWithoutTestSuiteInput
    variables?: TestSuiteVariableCreateNestedManyWithoutTestSuiteInput
    functions?: TestSuiteFunctionCreateNestedManyWithoutTestSuiteInput
  }

  export type TestSuitesUncheckedCreateWithoutProjectInput = {
    id?: number
    name: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testCases?: TestCaseUncheckedCreateNestedManyWithoutTestSuiteInput
    variables?: TestSuiteVariableUncheckedCreateNestedManyWithoutTestSuiteInput
    functions?: TestSuiteFunctionUncheckedCreateNestedManyWithoutTestSuiteInput
  }

  export type TestSuitesCreateOrConnectWithoutProjectInput = {
    where: TestSuitesWhereUniqueInput
    create: XOR<TestSuitesCreateWithoutProjectInput, TestSuitesUncheckedCreateWithoutProjectInput>
  }

  export type TestSuitesCreateManyProjectInputEnvelope = {
    data: TestSuitesCreateManyProjectInput | TestSuitesCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectVariableCreateWithoutProjectInput = {
    name: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutProjectVariablesInput
  }

  export type ProjectVariableUncheckedCreateWithoutProjectInput = {
    id?: number
    name: string
    value: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectVariableCreateOrConnectWithoutProjectInput = {
    where: ProjectVariableWhereUniqueInput
    create: XOR<ProjectVariableCreateWithoutProjectInput, ProjectVariableUncheckedCreateWithoutProjectInput>
  }

  export type ProjectVariableCreateManyProjectInputEnvelope = {
    data: ProjectVariableCreateManyProjectInput | ProjectVariableCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectFunctionCreateWithoutProjectInput = {
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutProjectFunctionsInput
  }

  export type ProjectFunctionUncheckedCreateWithoutProjectInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectFunctionCreateOrConnectWithoutProjectInput = {
    where: ProjectFunctionWhereUniqueInput
    create: XOR<ProjectFunctionCreateWithoutProjectInput, ProjectFunctionUncheckedCreateWithoutProjectInput>
  }

  export type ProjectFunctionCreateManyProjectInputEnvelope = {
    data: ProjectFunctionCreateManyProjectInput | ProjectFunctionCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedProjectsInput = {
    update: XOR<UserUpdateWithoutCreatedProjectsInput, UserUncheckedUpdateWithoutCreatedProjectsInput>
    create: XOR<UserCreateWithoutCreatedProjectsInput, UserUncheckedCreateWithoutCreatedProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedProjectsInput, UserUncheckedUpdateWithoutCreatedProjectsInput>
  }

  export type UserUpdateWithoutCreatedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUncheckedUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUncheckedUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUncheckedUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutProjectInput>
  }

  export type PageUpsertWithWhereUniqueWithoutProjectInput = {
    where: PageWhereUniqueInput
    update: XOR<PageUpdateWithoutProjectInput, PageUncheckedUpdateWithoutProjectInput>
    create: XOR<PageCreateWithoutProjectInput, PageUncheckedCreateWithoutProjectInput>
  }

  export type PageUpdateWithWhereUniqueWithoutProjectInput = {
    where: PageWhereUniqueInput
    data: XOR<PageUpdateWithoutProjectInput, PageUncheckedUpdateWithoutProjectInput>
  }

  export type PageUpdateManyWithWhereWithoutProjectInput = {
    where: PageScalarWhereInput
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectInvitationUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectInvitationWhereUniqueInput
    update: XOR<ProjectInvitationUpdateWithoutProjectInput, ProjectInvitationUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectInvitationCreateWithoutProjectInput, ProjectInvitationUncheckedCreateWithoutProjectInput>
  }

  export type ProjectInvitationUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectInvitationWhereUniqueInput
    data: XOR<ProjectInvitationUpdateWithoutProjectInput, ProjectInvitationUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectInvitationUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectInvitationScalarWhereInput
    data: XOR<ProjectInvitationUpdateManyMutationInput, ProjectInvitationUncheckedUpdateManyWithoutProjectInput>
  }

  export type TestSuitesUpsertWithWhereUniqueWithoutProjectInput = {
    where: TestSuitesWhereUniqueInput
    update: XOR<TestSuitesUpdateWithoutProjectInput, TestSuitesUncheckedUpdateWithoutProjectInput>
    create: XOR<TestSuitesCreateWithoutProjectInput, TestSuitesUncheckedCreateWithoutProjectInput>
  }

  export type TestSuitesUpdateWithWhereUniqueWithoutProjectInput = {
    where: TestSuitesWhereUniqueInput
    data: XOR<TestSuitesUpdateWithoutProjectInput, TestSuitesUncheckedUpdateWithoutProjectInput>
  }

  export type TestSuitesUpdateManyWithWhereWithoutProjectInput = {
    where: TestSuitesScalarWhereInput
    data: XOR<TestSuitesUpdateManyMutationInput, TestSuitesUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectVariableUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectVariableWhereUniqueInput
    update: XOR<ProjectVariableUpdateWithoutProjectInput, ProjectVariableUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectVariableCreateWithoutProjectInput, ProjectVariableUncheckedCreateWithoutProjectInput>
  }

  export type ProjectVariableUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectVariableWhereUniqueInput
    data: XOR<ProjectVariableUpdateWithoutProjectInput, ProjectVariableUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectVariableUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectVariableScalarWhereInput
    data: XOR<ProjectVariableUpdateManyMutationInput, ProjectVariableUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectFunctionUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectFunctionWhereUniqueInput
    update: XOR<ProjectFunctionUpdateWithoutProjectInput, ProjectFunctionUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectFunctionCreateWithoutProjectInput, ProjectFunctionUncheckedCreateWithoutProjectInput>
  }

  export type ProjectFunctionUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectFunctionWhereUniqueInput
    data: XOR<ProjectFunctionUpdateWithoutProjectInput, ProjectFunctionUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectFunctionUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectFunctionScalarWhereInput
    data: XOR<ProjectFunctionUpdateManyMutationInput, ProjectFunctionUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCreateWithoutMembersInput = {
    name: string
    description?: string | null
    baseUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutCreatedProjectsInput
    pages?: PageCreateNestedManyWithoutProjectInput
    invitations?: ProjectInvitationCreateNestedManyWithoutProjectInput
    testSuites?: TestSuitesCreateNestedManyWithoutProjectInput
    globalVariables?: ProjectVariableCreateNestedManyWithoutProjectInput
    globalFunctions?: ProjectFunctionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMembersInput = {
    id?: number
    name: string
    description?: string | null
    baseUrl?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pages?: PageUncheckedCreateNestedManyWithoutProjectInput
    invitations?: ProjectInvitationUncheckedCreateNestedManyWithoutProjectInput
    testSuites?: TestSuitesUncheckedCreateNestedManyWithoutProjectInput
    globalVariables?: ProjectVariableUncheckedCreateNestedManyWithoutProjectInput
    globalFunctions?: ProjectFunctionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMembersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutProjectMembershipsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutProjectMembershipsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementUncheckedCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableUncheckedCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutProjectMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
  }

  export type ProjectUpsertWithoutMembersInput = {
    update: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMembersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type ProjectUpdateWithoutMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutCreatedProjectsNestedInput
    pages?: PageUpdateManyWithoutProjectNestedInput
    invitations?: ProjectInvitationUpdateManyWithoutProjectNestedInput
    testSuites?: TestSuitesUpdateManyWithoutProjectNestedInput
    globalVariables?: ProjectVariableUpdateManyWithoutProjectNestedInput
    globalFunctions?: ProjectFunctionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pages?: PageUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: ProjectInvitationUncheckedUpdateManyWithoutProjectNestedInput
    testSuites?: TestSuitesUncheckedUpdateManyWithoutProjectNestedInput
    globalVariables?: ProjectVariableUncheckedUpdateManyWithoutProjectNestedInput
    globalFunctions?: ProjectFunctionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectMembershipsInput = {
    update: XOR<UserUpdateWithoutProjectMembershipsInput, UserUncheckedUpdateWithoutProjectMembershipsInput>
    create: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectMembershipsInput, UserUncheckedUpdateWithoutProjectMembershipsInput>
  }

  export type UserUpdateWithoutProjectMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUncheckedUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUncheckedUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUncheckedUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ProjectCreateWithoutTestSuitesInput = {
    name: string
    description?: string | null
    baseUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutCreatedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    pages?: PageCreateNestedManyWithoutProjectInput
    invitations?: ProjectInvitationCreateNestedManyWithoutProjectInput
    globalVariables?: ProjectVariableCreateNestedManyWithoutProjectInput
    globalFunctions?: ProjectFunctionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTestSuitesInput = {
    id?: number
    name: string
    description?: string | null
    baseUrl?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    pages?: PageUncheckedCreateNestedManyWithoutProjectInput
    invitations?: ProjectInvitationUncheckedCreateNestedManyWithoutProjectInput
    globalVariables?: ProjectVariableUncheckedCreateNestedManyWithoutProjectInput
    globalFunctions?: ProjectFunctionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTestSuitesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTestSuitesInput, ProjectUncheckedCreateWithoutTestSuitesInput>
  }

  export type UserCreateWithoutTestSuitesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutTestSuitesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementUncheckedCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableUncheckedCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutTestSuitesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTestSuitesInput, UserUncheckedCreateWithoutTestSuitesInput>
  }

  export type TestCaseCreateWithoutTestSuiteInput = {
    projectId: number
    name: string
    description?: string | null
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutCreatedTestCasesInput
  }

  export type TestCaseUncheckedCreateWithoutTestSuiteInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    code: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestCaseCreateOrConnectWithoutTestSuiteInput = {
    where: TestCaseWhereUniqueInput
    create: XOR<TestCaseCreateWithoutTestSuiteInput, TestCaseUncheckedCreateWithoutTestSuiteInput>
  }

  export type TestCaseCreateManyTestSuiteInputEnvelope = {
    data: TestCaseCreateManyTestSuiteInput | TestCaseCreateManyTestSuiteInput[]
    skipDuplicates?: boolean
  }

  export type TestSuiteVariableCreateWithoutTestSuiteInput = {
    name: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutTestSuiteVariablesInput
  }

  export type TestSuiteVariableUncheckedCreateWithoutTestSuiteInput = {
    id?: number
    name: string
    value: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestSuiteVariableCreateOrConnectWithoutTestSuiteInput = {
    where: TestSuiteVariableWhereUniqueInput
    create: XOR<TestSuiteVariableCreateWithoutTestSuiteInput, TestSuiteVariableUncheckedCreateWithoutTestSuiteInput>
  }

  export type TestSuiteVariableCreateManyTestSuiteInputEnvelope = {
    data: TestSuiteVariableCreateManyTestSuiteInput | TestSuiteVariableCreateManyTestSuiteInput[]
    skipDuplicates?: boolean
  }

  export type TestSuiteFunctionCreateWithoutTestSuiteInput = {
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutTestSuiteFunctionsInput
  }

  export type TestSuiteFunctionUncheckedCreateWithoutTestSuiteInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestSuiteFunctionCreateOrConnectWithoutTestSuiteInput = {
    where: TestSuiteFunctionWhereUniqueInput
    create: XOR<TestSuiteFunctionCreateWithoutTestSuiteInput, TestSuiteFunctionUncheckedCreateWithoutTestSuiteInput>
  }

  export type TestSuiteFunctionCreateManyTestSuiteInputEnvelope = {
    data: TestSuiteFunctionCreateManyTestSuiteInput | TestSuiteFunctionCreateManyTestSuiteInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutTestSuitesInput = {
    update: XOR<ProjectUpdateWithoutTestSuitesInput, ProjectUncheckedUpdateWithoutTestSuitesInput>
    create: XOR<ProjectCreateWithoutTestSuitesInput, ProjectUncheckedCreateWithoutTestSuitesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTestSuitesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTestSuitesInput, ProjectUncheckedUpdateWithoutTestSuitesInput>
  }

  export type ProjectUpdateWithoutTestSuitesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutCreatedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    pages?: PageUpdateManyWithoutProjectNestedInput
    invitations?: ProjectInvitationUpdateManyWithoutProjectNestedInput
    globalVariables?: ProjectVariableUpdateManyWithoutProjectNestedInput
    globalFunctions?: ProjectFunctionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTestSuitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    pages?: PageUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: ProjectInvitationUncheckedUpdateManyWithoutProjectNestedInput
    globalVariables?: ProjectVariableUncheckedUpdateManyWithoutProjectNestedInput
    globalFunctions?: ProjectFunctionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutTestSuitesInput = {
    update: XOR<UserUpdateWithoutTestSuitesInput, UserUncheckedUpdateWithoutTestSuitesInput>
    create: XOR<UserCreateWithoutTestSuitesInput, UserUncheckedCreateWithoutTestSuitesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTestSuitesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTestSuitesInput, UserUncheckedUpdateWithoutTestSuitesInput>
  }

  export type UserUpdateWithoutTestSuitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutTestSuitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUncheckedUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUncheckedUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUncheckedUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type TestCaseUpsertWithWhereUniqueWithoutTestSuiteInput = {
    where: TestCaseWhereUniqueInput
    update: XOR<TestCaseUpdateWithoutTestSuiteInput, TestCaseUncheckedUpdateWithoutTestSuiteInput>
    create: XOR<TestCaseCreateWithoutTestSuiteInput, TestCaseUncheckedCreateWithoutTestSuiteInput>
  }

  export type TestCaseUpdateWithWhereUniqueWithoutTestSuiteInput = {
    where: TestCaseWhereUniqueInput
    data: XOR<TestCaseUpdateWithoutTestSuiteInput, TestCaseUncheckedUpdateWithoutTestSuiteInput>
  }

  export type TestCaseUpdateManyWithWhereWithoutTestSuiteInput = {
    where: TestCaseScalarWhereInput
    data: XOR<TestCaseUpdateManyMutationInput, TestCaseUncheckedUpdateManyWithoutTestSuiteInput>
  }

  export type TestSuiteVariableUpsertWithWhereUniqueWithoutTestSuiteInput = {
    where: TestSuiteVariableWhereUniqueInput
    update: XOR<TestSuiteVariableUpdateWithoutTestSuiteInput, TestSuiteVariableUncheckedUpdateWithoutTestSuiteInput>
    create: XOR<TestSuiteVariableCreateWithoutTestSuiteInput, TestSuiteVariableUncheckedCreateWithoutTestSuiteInput>
  }

  export type TestSuiteVariableUpdateWithWhereUniqueWithoutTestSuiteInput = {
    where: TestSuiteVariableWhereUniqueInput
    data: XOR<TestSuiteVariableUpdateWithoutTestSuiteInput, TestSuiteVariableUncheckedUpdateWithoutTestSuiteInput>
  }

  export type TestSuiteVariableUpdateManyWithWhereWithoutTestSuiteInput = {
    where: TestSuiteVariableScalarWhereInput
    data: XOR<TestSuiteVariableUpdateManyMutationInput, TestSuiteVariableUncheckedUpdateManyWithoutTestSuiteInput>
  }

  export type TestSuiteFunctionUpsertWithWhereUniqueWithoutTestSuiteInput = {
    where: TestSuiteFunctionWhereUniqueInput
    update: XOR<TestSuiteFunctionUpdateWithoutTestSuiteInput, TestSuiteFunctionUncheckedUpdateWithoutTestSuiteInput>
    create: XOR<TestSuiteFunctionCreateWithoutTestSuiteInput, TestSuiteFunctionUncheckedCreateWithoutTestSuiteInput>
  }

  export type TestSuiteFunctionUpdateWithWhereUniqueWithoutTestSuiteInput = {
    where: TestSuiteFunctionWhereUniqueInput
    data: XOR<TestSuiteFunctionUpdateWithoutTestSuiteInput, TestSuiteFunctionUncheckedUpdateWithoutTestSuiteInput>
  }

  export type TestSuiteFunctionUpdateManyWithWhereWithoutTestSuiteInput = {
    where: TestSuiteFunctionScalarWhereInput
    data: XOR<TestSuiteFunctionUpdateManyMutationInput, TestSuiteFunctionUncheckedUpdateManyWithoutTestSuiteInput>
  }

  export type ProjectCreateWithoutGlobalVariablesInput = {
    name: string
    description?: string | null
    baseUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutCreatedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    pages?: PageCreateNestedManyWithoutProjectInput
    invitations?: ProjectInvitationCreateNestedManyWithoutProjectInput
    testSuites?: TestSuitesCreateNestedManyWithoutProjectInput
    globalFunctions?: ProjectFunctionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutGlobalVariablesInput = {
    id?: number
    name: string
    description?: string | null
    baseUrl?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    pages?: PageUncheckedCreateNestedManyWithoutProjectInput
    invitations?: ProjectInvitationUncheckedCreateNestedManyWithoutProjectInput
    testSuites?: TestSuitesUncheckedCreateNestedManyWithoutProjectInput
    globalFunctions?: ProjectFunctionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutGlobalVariablesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutGlobalVariablesInput, ProjectUncheckedCreateWithoutGlobalVariablesInput>
  }

  export type UserCreateWithoutProjectVariablesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationCreateNestedManyWithoutUserInput
    testSuiteVariables?: TestSuiteVariableCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutProjectVariablesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementUncheckedCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutUserInput
    testSuiteVariables?: TestSuiteVariableUncheckedCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutProjectVariablesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectVariablesInput, UserUncheckedCreateWithoutProjectVariablesInput>
  }

  export type ProjectUpsertWithoutGlobalVariablesInput = {
    update: XOR<ProjectUpdateWithoutGlobalVariablesInput, ProjectUncheckedUpdateWithoutGlobalVariablesInput>
    create: XOR<ProjectCreateWithoutGlobalVariablesInput, ProjectUncheckedCreateWithoutGlobalVariablesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutGlobalVariablesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutGlobalVariablesInput, ProjectUncheckedUpdateWithoutGlobalVariablesInput>
  }

  export type ProjectUpdateWithoutGlobalVariablesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutCreatedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    pages?: PageUpdateManyWithoutProjectNestedInput
    invitations?: ProjectInvitationUpdateManyWithoutProjectNestedInput
    testSuites?: TestSuitesUpdateManyWithoutProjectNestedInput
    globalFunctions?: ProjectFunctionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutGlobalVariablesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    pages?: PageUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: ProjectInvitationUncheckedUpdateManyWithoutProjectNestedInput
    testSuites?: TestSuitesUncheckedUpdateManyWithoutProjectNestedInput
    globalFunctions?: ProjectFunctionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectVariablesInput = {
    update: XOR<UserUpdateWithoutProjectVariablesInput, UserUncheckedUpdateWithoutProjectVariablesInput>
    create: XOR<UserCreateWithoutProjectVariablesInput, UserUncheckedCreateWithoutProjectVariablesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectVariablesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectVariablesInput, UserUncheckedUpdateWithoutProjectVariablesInput>
  }

  export type UserUpdateWithoutProjectVariablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUpdateManyWithoutUserNestedInput
    testSuiteVariables?: TestSuiteVariableUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectVariablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUncheckedUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUncheckedUpdateManyWithoutUserNestedInput
    testSuiteVariables?: TestSuiteVariableUncheckedUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type TestSuitesCreateWithoutVariablesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTestSuitesInput
    creator?: UserCreateNestedOneWithoutTestSuitesInput
    testCases?: TestCaseCreateNestedManyWithoutTestSuiteInput
    functions?: TestSuiteFunctionCreateNestedManyWithoutTestSuiteInput
  }

  export type TestSuitesUncheckedCreateWithoutVariablesInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testCases?: TestCaseUncheckedCreateNestedManyWithoutTestSuiteInput
    functions?: TestSuiteFunctionUncheckedCreateNestedManyWithoutTestSuiteInput
  }

  export type TestSuitesCreateOrConnectWithoutVariablesInput = {
    where: TestSuitesWhereUniqueInput
    create: XOR<TestSuitesCreateWithoutVariablesInput, TestSuitesUncheckedCreateWithoutVariablesInput>
  }

  export type UserCreateWithoutTestSuiteVariablesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutTestSuiteVariablesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementUncheckedCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableUncheckedCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutTestSuiteVariablesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTestSuiteVariablesInput, UserUncheckedCreateWithoutTestSuiteVariablesInput>
  }

  export type TestSuitesUpsertWithoutVariablesInput = {
    update: XOR<TestSuitesUpdateWithoutVariablesInput, TestSuitesUncheckedUpdateWithoutVariablesInput>
    create: XOR<TestSuitesCreateWithoutVariablesInput, TestSuitesUncheckedCreateWithoutVariablesInput>
    where?: TestSuitesWhereInput
  }

  export type TestSuitesUpdateToOneWithWhereWithoutVariablesInput = {
    where?: TestSuitesWhereInput
    data: XOR<TestSuitesUpdateWithoutVariablesInput, TestSuitesUncheckedUpdateWithoutVariablesInput>
  }

  export type TestSuitesUpdateWithoutVariablesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTestSuitesNestedInput
    creator?: UserUpdateOneWithoutTestSuitesNestedInput
    testCases?: TestCaseUpdateManyWithoutTestSuiteNestedInput
    functions?: TestSuiteFunctionUpdateManyWithoutTestSuiteNestedInput
  }

  export type TestSuitesUncheckedUpdateWithoutVariablesInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testCases?: TestCaseUncheckedUpdateManyWithoutTestSuiteNestedInput
    functions?: TestSuiteFunctionUncheckedUpdateManyWithoutTestSuiteNestedInput
  }

  export type UserUpsertWithoutTestSuiteVariablesInput = {
    update: XOR<UserUpdateWithoutTestSuiteVariablesInput, UserUncheckedUpdateWithoutTestSuiteVariablesInput>
    create: XOR<UserCreateWithoutTestSuiteVariablesInput, UserUncheckedCreateWithoutTestSuiteVariablesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTestSuiteVariablesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTestSuiteVariablesInput, UserUncheckedUpdateWithoutTestSuiteVariablesInput>
  }

  export type UserUpdateWithoutTestSuiteVariablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutTestSuiteVariablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUncheckedUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUncheckedUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUncheckedUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ProjectCreateWithoutGlobalFunctionsInput = {
    name: string
    description?: string | null
    baseUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutCreatedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    pages?: PageCreateNestedManyWithoutProjectInput
    invitations?: ProjectInvitationCreateNestedManyWithoutProjectInput
    testSuites?: TestSuitesCreateNestedManyWithoutProjectInput
    globalVariables?: ProjectVariableCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutGlobalFunctionsInput = {
    id?: number
    name: string
    description?: string | null
    baseUrl?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    pages?: PageUncheckedCreateNestedManyWithoutProjectInput
    invitations?: ProjectInvitationUncheckedCreateNestedManyWithoutProjectInput
    testSuites?: TestSuitesUncheckedCreateNestedManyWithoutProjectInput
    globalVariables?: ProjectVariableUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutGlobalFunctionsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutGlobalFunctionsInput, ProjectUncheckedCreateWithoutGlobalFunctionsInput>
  }

  export type UserCreateWithoutProjectFunctionsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutProjectFunctionsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementUncheckedCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutProjectFunctionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectFunctionsInput, UserUncheckedCreateWithoutProjectFunctionsInput>
  }

  export type ProjectUpsertWithoutGlobalFunctionsInput = {
    update: XOR<ProjectUpdateWithoutGlobalFunctionsInput, ProjectUncheckedUpdateWithoutGlobalFunctionsInput>
    create: XOR<ProjectCreateWithoutGlobalFunctionsInput, ProjectUncheckedCreateWithoutGlobalFunctionsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutGlobalFunctionsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutGlobalFunctionsInput, ProjectUncheckedUpdateWithoutGlobalFunctionsInput>
  }

  export type ProjectUpdateWithoutGlobalFunctionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutCreatedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    pages?: PageUpdateManyWithoutProjectNestedInput
    invitations?: ProjectInvitationUpdateManyWithoutProjectNestedInput
    testSuites?: TestSuitesUpdateManyWithoutProjectNestedInput
    globalVariables?: ProjectVariableUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutGlobalFunctionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    pages?: PageUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: ProjectInvitationUncheckedUpdateManyWithoutProjectNestedInput
    testSuites?: TestSuitesUncheckedUpdateManyWithoutProjectNestedInput
    globalVariables?: ProjectVariableUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectFunctionsInput = {
    update: XOR<UserUpdateWithoutProjectFunctionsInput, UserUncheckedUpdateWithoutProjectFunctionsInput>
    create: XOR<UserCreateWithoutProjectFunctionsInput, UserUncheckedCreateWithoutProjectFunctionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectFunctionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectFunctionsInput, UserUncheckedUpdateWithoutProjectFunctionsInput>
  }

  export type UserUpdateWithoutProjectFunctionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectFunctionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUncheckedUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUncheckedUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type TestSuitesCreateWithoutFunctionsInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTestSuitesInput
    creator?: UserCreateNestedOneWithoutTestSuitesInput
    testCases?: TestCaseCreateNestedManyWithoutTestSuiteInput
    variables?: TestSuiteVariableCreateNestedManyWithoutTestSuiteInput
  }

  export type TestSuitesUncheckedCreateWithoutFunctionsInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testCases?: TestCaseUncheckedCreateNestedManyWithoutTestSuiteInput
    variables?: TestSuiteVariableUncheckedCreateNestedManyWithoutTestSuiteInput
  }

  export type TestSuitesCreateOrConnectWithoutFunctionsInput = {
    where: TestSuitesWhereUniqueInput
    create: XOR<TestSuitesCreateWithoutFunctionsInput, TestSuitesUncheckedCreateWithoutFunctionsInput>
  }

  export type UserCreateWithoutTestSuiteFunctionsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutTestSuiteFunctionsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementUncheckedCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableUncheckedCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutTestSuiteFunctionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTestSuiteFunctionsInput, UserUncheckedCreateWithoutTestSuiteFunctionsInput>
  }

  export type TestSuitesUpsertWithoutFunctionsInput = {
    update: XOR<TestSuitesUpdateWithoutFunctionsInput, TestSuitesUncheckedUpdateWithoutFunctionsInput>
    create: XOR<TestSuitesCreateWithoutFunctionsInput, TestSuitesUncheckedCreateWithoutFunctionsInput>
    where?: TestSuitesWhereInput
  }

  export type TestSuitesUpdateToOneWithWhereWithoutFunctionsInput = {
    where?: TestSuitesWhereInput
    data: XOR<TestSuitesUpdateWithoutFunctionsInput, TestSuitesUncheckedUpdateWithoutFunctionsInput>
  }

  export type TestSuitesUpdateWithoutFunctionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTestSuitesNestedInput
    creator?: UserUpdateOneWithoutTestSuitesNestedInput
    testCases?: TestCaseUpdateManyWithoutTestSuiteNestedInput
    variables?: TestSuiteVariableUpdateManyWithoutTestSuiteNestedInput
  }

  export type TestSuitesUncheckedUpdateWithoutFunctionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testCases?: TestCaseUncheckedUpdateManyWithoutTestSuiteNestedInput
    variables?: TestSuiteVariableUncheckedUpdateManyWithoutTestSuiteNestedInput
  }

  export type UserUpsertWithoutTestSuiteFunctionsInput = {
    update: XOR<UserUpdateWithoutTestSuiteFunctionsInput, UserUncheckedUpdateWithoutTestSuiteFunctionsInput>
    create: XOR<UserCreateWithoutTestSuiteFunctionsInput, UserUncheckedCreateWithoutTestSuiteFunctionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTestSuiteFunctionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTestSuiteFunctionsInput, UserUncheckedUpdateWithoutTestSuiteFunctionsInput>
  }

  export type UserUpdateWithoutTestSuiteFunctionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutTestSuiteFunctionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUncheckedUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUncheckedUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUncheckedUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ProjectCreateWithoutPagesInput = {
    name: string
    description?: string | null
    baseUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutCreatedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    invitations?: ProjectInvitationCreateNestedManyWithoutProjectInput
    testSuites?: TestSuitesCreateNestedManyWithoutProjectInput
    globalVariables?: ProjectVariableCreateNestedManyWithoutProjectInput
    globalFunctions?: ProjectFunctionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutPagesInput = {
    id?: number
    name: string
    description?: string | null
    baseUrl?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    invitations?: ProjectInvitationUncheckedCreateNestedManyWithoutProjectInput
    testSuites?: TestSuitesUncheckedCreateNestedManyWithoutProjectInput
    globalVariables?: ProjectVariableUncheckedCreateNestedManyWithoutProjectInput
    globalFunctions?: ProjectFunctionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPagesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPagesInput, ProjectUncheckedCreateWithoutPagesInput>
  }

  export type UserCreateWithoutCreatedPagesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdPageElements?: PageElementCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedPagesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdPageElements?: PageElementUncheckedCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableUncheckedCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedPagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedPagesInput, UserUncheckedCreateWithoutCreatedPagesInput>
  }

  export type PageElementCreateWithoutPageInput = {
    elementName: string
    selector: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutCreatedPageElementsInput
  }

  export type PageElementUncheckedCreateWithoutPageInput = {
    id?: number
    elementName: string
    selector: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageElementCreateOrConnectWithoutPageInput = {
    where: PageElementWhereUniqueInput
    create: XOR<PageElementCreateWithoutPageInput, PageElementUncheckedCreateWithoutPageInput>
  }

  export type PageElementCreateManyPageInputEnvelope = {
    data: PageElementCreateManyPageInput | PageElementCreateManyPageInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutPagesInput = {
    update: XOR<ProjectUpdateWithoutPagesInput, ProjectUncheckedUpdateWithoutPagesInput>
    create: XOR<ProjectCreateWithoutPagesInput, ProjectUncheckedCreateWithoutPagesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutPagesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutPagesInput, ProjectUncheckedUpdateWithoutPagesInput>
  }

  export type ProjectUpdateWithoutPagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutCreatedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    invitations?: ProjectInvitationUpdateManyWithoutProjectNestedInput
    testSuites?: TestSuitesUpdateManyWithoutProjectNestedInput
    globalVariables?: ProjectVariableUpdateManyWithoutProjectNestedInput
    globalFunctions?: ProjectFunctionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: ProjectInvitationUncheckedUpdateManyWithoutProjectNestedInput
    testSuites?: TestSuitesUncheckedUpdateManyWithoutProjectNestedInput
    globalVariables?: ProjectVariableUncheckedUpdateManyWithoutProjectNestedInput
    globalFunctions?: ProjectFunctionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutCreatedPagesInput = {
    update: XOR<UserUpdateWithoutCreatedPagesInput, UserUncheckedUpdateWithoutCreatedPagesInput>
    create: XOR<UserCreateWithoutCreatedPagesInput, UserUncheckedCreateWithoutCreatedPagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedPagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedPagesInput, UserUncheckedUpdateWithoutCreatedPagesInput>
  }

  export type UserUpdateWithoutCreatedPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdPageElements?: PageElementUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdPageElements?: PageElementUncheckedUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUncheckedUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUncheckedUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type PageElementUpsertWithWhereUniqueWithoutPageInput = {
    where: PageElementWhereUniqueInput
    update: XOR<PageElementUpdateWithoutPageInput, PageElementUncheckedUpdateWithoutPageInput>
    create: XOR<PageElementCreateWithoutPageInput, PageElementUncheckedCreateWithoutPageInput>
  }

  export type PageElementUpdateWithWhereUniqueWithoutPageInput = {
    where: PageElementWhereUniqueInput
    data: XOR<PageElementUpdateWithoutPageInput, PageElementUncheckedUpdateWithoutPageInput>
  }

  export type PageElementUpdateManyWithWhereWithoutPageInput = {
    where: PageElementScalarWhereInput
    data: XOR<PageElementUpdateManyMutationInput, PageElementUncheckedUpdateManyWithoutPageInput>
  }

  export type PageCreateWithoutElementsInput = {
    name: string
    url: string
    description?: string | null
    isProtected?: boolean
    authFunction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPagesInput
    creator?: UserCreateNestedOneWithoutCreatedPagesInput
  }

  export type PageUncheckedCreateWithoutElementsInput = {
    id?: number
    projectId: number
    name: string
    url: string
    description?: string | null
    isProtected?: boolean
    authFunction?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageCreateOrConnectWithoutElementsInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutElementsInput, PageUncheckedCreateWithoutElementsInput>
  }

  export type UserCreateWithoutCreatedPageElementsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedPageElementsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableUncheckedCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedPageElementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedPageElementsInput, UserUncheckedCreateWithoutCreatedPageElementsInput>
  }

  export type PageUpsertWithoutElementsInput = {
    update: XOR<PageUpdateWithoutElementsInput, PageUncheckedUpdateWithoutElementsInput>
    create: XOR<PageCreateWithoutElementsInput, PageUncheckedCreateWithoutElementsInput>
    where?: PageWhereInput
  }

  export type PageUpdateToOneWithWhereWithoutElementsInput = {
    where?: PageWhereInput
    data: XOR<PageUpdateWithoutElementsInput, PageUncheckedUpdateWithoutElementsInput>
  }

  export type PageUpdateWithoutElementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProtected?: BoolFieldUpdateOperationsInput | boolean
    authFunction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPagesNestedInput
    creator?: UserUpdateOneWithoutCreatedPagesNestedInput
  }

  export type PageUncheckedUpdateWithoutElementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProtected?: BoolFieldUpdateOperationsInput | boolean
    authFunction?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCreatedPageElementsInput = {
    update: XOR<UserUpdateWithoutCreatedPageElementsInput, UserUncheckedUpdateWithoutCreatedPageElementsInput>
    create: XOR<UserCreateWithoutCreatedPageElementsInput, UserUncheckedCreateWithoutCreatedPageElementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedPageElementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedPageElementsInput, UserUncheckedUpdateWithoutCreatedPageElementsInput>
  }

  export type UserUpdateWithoutCreatedPageElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedPageElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUncheckedUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUncheckedUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type TestSuitesCreateWithoutTestCasesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTestSuitesInput
    creator?: UserCreateNestedOneWithoutTestSuitesInput
    variables?: TestSuiteVariableCreateNestedManyWithoutTestSuiteInput
    functions?: TestSuiteFunctionCreateNestedManyWithoutTestSuiteInput
  }

  export type TestSuitesUncheckedCreateWithoutTestCasesInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variables?: TestSuiteVariableUncheckedCreateNestedManyWithoutTestSuiteInput
    functions?: TestSuiteFunctionUncheckedCreateNestedManyWithoutTestSuiteInput
  }

  export type TestSuitesCreateOrConnectWithoutTestCasesInput = {
    where: TestSuitesWhereUniqueInput
    create: XOR<TestSuitesCreateWithoutTestCasesInput, TestSuitesUncheckedCreateWithoutTestCasesInput>
  }

  export type UserCreateWithoutCreatedTestCasesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedTestCasesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementUncheckedCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableUncheckedCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedTestCasesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTestCasesInput, UserUncheckedCreateWithoutCreatedTestCasesInput>
  }

  export type TestSuitesUpsertWithoutTestCasesInput = {
    update: XOR<TestSuitesUpdateWithoutTestCasesInput, TestSuitesUncheckedUpdateWithoutTestCasesInput>
    create: XOR<TestSuitesCreateWithoutTestCasesInput, TestSuitesUncheckedCreateWithoutTestCasesInput>
    where?: TestSuitesWhereInput
  }

  export type TestSuitesUpdateToOneWithWhereWithoutTestCasesInput = {
    where?: TestSuitesWhereInput
    data: XOR<TestSuitesUpdateWithoutTestCasesInput, TestSuitesUncheckedUpdateWithoutTestCasesInput>
  }

  export type TestSuitesUpdateWithoutTestCasesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTestSuitesNestedInput
    creator?: UserUpdateOneWithoutTestSuitesNestedInput
    variables?: TestSuiteVariableUpdateManyWithoutTestSuiteNestedInput
    functions?: TestSuiteFunctionUpdateManyWithoutTestSuiteNestedInput
  }

  export type TestSuitesUncheckedUpdateWithoutTestCasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variables?: TestSuiteVariableUncheckedUpdateManyWithoutTestSuiteNestedInput
    functions?: TestSuiteFunctionUncheckedUpdateManyWithoutTestSuiteNestedInput
  }

  export type UserUpsertWithoutCreatedTestCasesInput = {
    update: XOR<UserUpdateWithoutCreatedTestCasesInput, UserUncheckedUpdateWithoutCreatedTestCasesInput>
    create: XOR<UserCreateWithoutCreatedTestCasesInput, UserUncheckedCreateWithoutCreatedTestCasesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTestCasesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTestCasesInput, UserUncheckedUpdateWithoutCreatedTestCasesInput>
  }

  export type UserUpdateWithoutCreatedTestCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTestCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUncheckedUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: ProjectInvitationUncheckedUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUncheckedUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ProjectCreateWithoutInvitationsInput = {
    name: string
    description?: string | null
    baseUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutCreatedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    pages?: PageCreateNestedManyWithoutProjectInput
    testSuites?: TestSuitesCreateNestedManyWithoutProjectInput
    globalVariables?: ProjectVariableCreateNestedManyWithoutProjectInput
    globalFunctions?: ProjectFunctionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutInvitationsInput = {
    id?: number
    name: string
    description?: string | null
    baseUrl?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    pages?: PageUncheckedCreateNestedManyWithoutProjectInput
    testSuites?: TestSuitesUncheckedCreateNestedManyWithoutProjectInput
    globalVariables?: ProjectVariableUncheckedCreateNestedManyWithoutProjectInput
    globalFunctions?: ProjectFunctionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutInvitationsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutInvitationsInput, ProjectUncheckedCreateWithoutInvitationsInput>
  }

  export type UserCreateWithoutSentInvitationsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatorInput
    receivedInvitations?: ProjectInvitationCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutSentInvitationsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementUncheckedCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatorInput
    receivedInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutUserInput
    projectVariables?: ProjectVariableUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableUncheckedCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSentInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
  }

  export type UserCreateWithoutReceivedInvitationsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdPages?: PageCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationCreateNestedManyWithoutInviterInput
    projectVariables?: ProjectVariableCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutReceivedInvitationsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdPages?: PageUncheckedCreateNestedManyWithoutCreatorInput
    createdPageElements?: PageElementUncheckedCreateNestedManyWithoutCreatorInput
    createdTestCases?: TestCaseUncheckedCreateNestedManyWithoutCreatorInput
    sentInvitations?: ProjectInvitationUncheckedCreateNestedManyWithoutInviterInput
    projectVariables?: ProjectVariableUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteVariables?: TestSuiteVariableUncheckedCreateNestedManyWithoutCreatorInput
    projectFunctions?: ProjectFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedCreateNestedManyWithoutCreatorInput
    testSuites?: TestSuitesUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutReceivedInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedInvitationsInput, UserUncheckedCreateWithoutReceivedInvitationsInput>
  }

  export type ProjectUpsertWithoutInvitationsInput = {
    update: XOR<ProjectUpdateWithoutInvitationsInput, ProjectUncheckedUpdateWithoutInvitationsInput>
    create: XOR<ProjectCreateWithoutInvitationsInput, ProjectUncheckedCreateWithoutInvitationsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutInvitationsInput, ProjectUncheckedUpdateWithoutInvitationsInput>
  }

  export type ProjectUpdateWithoutInvitationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutCreatedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    pages?: PageUpdateManyWithoutProjectNestedInput
    testSuites?: TestSuitesUpdateManyWithoutProjectNestedInput
    globalVariables?: ProjectVariableUpdateManyWithoutProjectNestedInput
    globalFunctions?: ProjectFunctionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutInvitationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    pages?: PageUncheckedUpdateManyWithoutProjectNestedInput
    testSuites?: TestSuitesUncheckedUpdateManyWithoutProjectNestedInput
    globalVariables?: ProjectVariableUncheckedUpdateManyWithoutProjectNestedInput
    globalFunctions?: ProjectFunctionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutSentInvitationsInput = {
    update: XOR<UserUpdateWithoutSentInvitationsInput, UserUncheckedUpdateWithoutSentInvitationsInput>
    create: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentInvitationsInput, UserUncheckedUpdateWithoutSentInvitationsInput>
  }

  export type UserUpdateWithoutSentInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatorNestedInput
    receivedInvitations?: ProjectInvitationUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutSentInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUncheckedUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatorNestedInput
    receivedInvitations?: ProjectInvitationUncheckedUpdateManyWithoutUserNestedInput
    projectVariables?: ProjectVariableUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUncheckedUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutReceivedInvitationsInput = {
    update: XOR<UserUpdateWithoutReceivedInvitationsInput, UserUncheckedUpdateWithoutReceivedInvitationsInput>
    create: XOR<UserCreateWithoutReceivedInvitationsInput, UserUncheckedCreateWithoutReceivedInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedInvitationsInput, UserUncheckedUpdateWithoutReceivedInvitationsInput>
  }

  export type UserUpdateWithoutReceivedInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdPages?: PageUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUpdateManyWithoutInviterNestedInput
    projectVariables?: ProjectVariableUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdPages?: PageUncheckedUpdateManyWithoutCreatorNestedInput
    createdPageElements?: PageElementUncheckedUpdateManyWithoutCreatorNestedInput
    createdTestCases?: TestCaseUncheckedUpdateManyWithoutCreatorNestedInput
    sentInvitations?: ProjectInvitationUncheckedUpdateManyWithoutInviterNestedInput
    projectVariables?: ProjectVariableUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteVariables?: TestSuiteVariableUncheckedUpdateManyWithoutCreatorNestedInput
    projectFunctions?: ProjectFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuiteFunctions?: TestSuiteFunctionUncheckedUpdateManyWithoutCreatorNestedInput
    testSuites?: TestSuitesUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type SessionCreateManyUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AccountCreateManyUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ProjectCreateManyCreatorInput = {
    id?: number
    name: string
    description?: string | null
    baseUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMemberCreateManyUserInput = {
    id?: number
    projectId: number
    role: string
    joinedAt?: Date | string
  }

  export type PageCreateManyCreatorInput = {
    id?: number
    projectId: number
    name: string
    url: string
    description?: string | null
    isProtected?: boolean
    authFunction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageElementCreateManyCreatorInput = {
    id?: number
    pageId: number
    elementName: string
    selector: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestCaseCreateManyCreatorInput = {
    id?: number
    projectId: number
    testSuiteId?: number | null
    name: string
    description?: string | null
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectInvitationCreateManyInviterInput = {
    id?: number
    projectId: number
    userId: string
    status?: $Enums.ProjectInvitationStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectInvitationCreateManyUserInput = {
    id?: number
    projectId: number
    invitedBy: string
    status?: $Enums.ProjectInvitationStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectVariableCreateManyCreatorInput = {
    id?: number
    projectId: number
    name: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestSuiteVariableCreateManyCreatorInput = {
    id?: number
    testSuiteId: number
    name: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectFunctionCreateManyCreatorInput = {
    id?: number
    projectId: number
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestSuiteFunctionCreateManyCreatorInput = {
    id?: number
    testSuiteId: number
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestSuitesCreateManyCreatorInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    pages?: PageUpdateManyWithoutProjectNestedInput
    invitations?: ProjectInvitationUpdateManyWithoutProjectNestedInput
    testSuites?: TestSuitesUpdateManyWithoutProjectNestedInput
    globalVariables?: ProjectVariableUpdateManyWithoutProjectNestedInput
    globalFunctions?: ProjectFunctionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    pages?: PageUncheckedUpdateManyWithoutProjectNestedInput
    invitations?: ProjectInvitationUncheckedUpdateManyWithoutProjectNestedInput
    testSuites?: TestSuitesUncheckedUpdateManyWithoutProjectNestedInput
    globalVariables?: ProjectVariableUncheckedUpdateManyWithoutProjectNestedInput
    globalFunctions?: ProjectFunctionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUpdateWithoutUserInput = {
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUpdateWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProtected?: BoolFieldUpdateOperationsInput | boolean
    authFunction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPagesNestedInput
    elements?: PageElementUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProtected?: BoolFieldUpdateOperationsInput | boolean
    authFunction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elements?: PageElementUncheckedUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProtected?: BoolFieldUpdateOperationsInput | boolean
    authFunction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageElementUpdateWithoutCreatorInput = {
    elementName?: StringFieldUpdateOperationsInput | string
    selector?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    page?: PageUpdateOneRequiredWithoutElementsNestedInput
  }

  export type PageElementUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    pageId?: IntFieldUpdateOperationsInput | number
    elementName?: StringFieldUpdateOperationsInput | string
    selector?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageElementUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    pageId?: IntFieldUpdateOperationsInput | number
    elementName?: StringFieldUpdateOperationsInput | string
    selector?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestCaseUpdateWithoutCreatorInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testSuite?: TestSuitesUpdateOneWithoutTestCasesNestedInput
  }

  export type TestCaseUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    testSuiteId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestCaseUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    testSuiteId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInvitationUpdateWithoutInviterInput = {
    status?: EnumProjectInvitationStatusFieldUpdateOperationsInput | $Enums.ProjectInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutInvitationsNestedInput
    user?: UserUpdateOneRequiredWithoutReceivedInvitationsNestedInput
  }

  export type ProjectInvitationUncheckedUpdateWithoutInviterInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectInvitationStatusFieldUpdateOperationsInput | $Enums.ProjectInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInvitationUncheckedUpdateManyWithoutInviterInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectInvitationStatusFieldUpdateOperationsInput | $Enums.ProjectInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInvitationUpdateWithoutUserInput = {
    status?: EnumProjectInvitationStatusFieldUpdateOperationsInput | $Enums.ProjectInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutInvitationsNestedInput
    inviter?: UserUpdateOneRequiredWithoutSentInvitationsNestedInput
  }

  export type ProjectInvitationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    invitedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectInvitationStatusFieldUpdateOperationsInput | $Enums.ProjectInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInvitationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    invitedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectInvitationStatusFieldUpdateOperationsInput | $Enums.ProjectInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectVariableUpdateWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutGlobalVariablesNestedInput
  }

  export type ProjectVariableUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectVariableUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestSuiteVariableUpdateWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testSuite?: TestSuitesUpdateOneRequiredWithoutVariablesNestedInput
  }

  export type TestSuiteVariableUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    testSuiteId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestSuiteVariableUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    testSuiteId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFunctionUpdateWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutGlobalFunctionsNestedInput
  }

  export type ProjectFunctionUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFunctionUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestSuiteFunctionUpdateWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testSuite?: TestSuitesUpdateOneRequiredWithoutFunctionsNestedInput
  }

  export type TestSuiteFunctionUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    testSuiteId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestSuiteFunctionUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    testSuiteId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestSuitesUpdateWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTestSuitesNestedInput
    testCases?: TestCaseUpdateManyWithoutTestSuiteNestedInput
    variables?: TestSuiteVariableUpdateManyWithoutTestSuiteNestedInput
    functions?: TestSuiteFunctionUpdateManyWithoutTestSuiteNestedInput
  }

  export type TestSuitesUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testCases?: TestCaseUncheckedUpdateManyWithoutTestSuiteNestedInput
    variables?: TestSuiteVariableUncheckedUpdateManyWithoutTestSuiteNestedInput
    functions?: TestSuiteFunctionUncheckedUpdateManyWithoutTestSuiteNestedInput
  }

  export type TestSuitesUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateManyProjectInput = {
    id?: number
    userId: string
    role: string
    joinedAt?: Date | string
  }

  export type PageCreateManyProjectInput = {
    id?: number
    name: string
    url: string
    description?: string | null
    isProtected?: boolean
    authFunction?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectInvitationCreateManyProjectInput = {
    id?: number
    userId: string
    invitedBy: string
    status?: $Enums.ProjectInvitationStatus
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestSuitesCreateManyProjectInput = {
    id?: number
    name: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectVariableCreateManyProjectInput = {
    id?: number
    name: string
    value: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectFunctionCreateManyProjectInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMemberUpdateWithoutProjectInput = {
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectMembershipsNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProtected?: BoolFieldUpdateOperationsInput | boolean
    authFunction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutCreatedPagesNestedInput
    elements?: PageElementUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProtected?: BoolFieldUpdateOperationsInput | boolean
    authFunction?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elements?: PageElementUncheckedUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isProtected?: BoolFieldUpdateOperationsInput | boolean
    authFunction?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInvitationUpdateWithoutProjectInput = {
    status?: EnumProjectInvitationStatusFieldUpdateOperationsInput | $Enums.ProjectInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviter?: UserUpdateOneRequiredWithoutSentInvitationsNestedInput
    user?: UserUpdateOneRequiredWithoutReceivedInvitationsNestedInput
  }

  export type ProjectInvitationUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectInvitationStatusFieldUpdateOperationsInput | $Enums.ProjectInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInvitationUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectInvitationStatusFieldUpdateOperationsInput | $Enums.ProjectInvitationStatus
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestSuitesUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutTestSuitesNestedInput
    testCases?: TestCaseUpdateManyWithoutTestSuiteNestedInput
    variables?: TestSuiteVariableUpdateManyWithoutTestSuiteNestedInput
    functions?: TestSuiteFunctionUpdateManyWithoutTestSuiteNestedInput
  }

  export type TestSuitesUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testCases?: TestCaseUncheckedUpdateManyWithoutTestSuiteNestedInput
    variables?: TestSuiteVariableUncheckedUpdateManyWithoutTestSuiteNestedInput
    functions?: TestSuiteFunctionUncheckedUpdateManyWithoutTestSuiteNestedInput
  }

  export type TestSuitesUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectVariableUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutProjectVariablesNestedInput
  }

  export type ProjectVariableUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectVariableUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFunctionUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutProjectFunctionsNestedInput
  }

  export type ProjectFunctionUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFunctionUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestCaseCreateManyTestSuiteInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    code: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestSuiteVariableCreateManyTestSuiteInput = {
    id?: number
    name: string
    value: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestSuiteFunctionCreateManyTestSuiteInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestCaseUpdateWithoutTestSuiteInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutCreatedTestCasesNestedInput
  }

  export type TestCaseUncheckedUpdateWithoutTestSuiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestCaseUncheckedUpdateManyWithoutTestSuiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestSuiteVariableUpdateWithoutTestSuiteInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutTestSuiteVariablesNestedInput
  }

  export type TestSuiteVariableUncheckedUpdateWithoutTestSuiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestSuiteVariableUncheckedUpdateManyWithoutTestSuiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestSuiteFunctionUpdateWithoutTestSuiteInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutTestSuiteFunctionsNestedInput
  }

  export type TestSuiteFunctionUncheckedUpdateWithoutTestSuiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestSuiteFunctionUncheckedUpdateManyWithoutTestSuiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageElementCreateManyPageInput = {
    id?: number
    elementName: string
    selector: string
    description?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageElementUpdateWithoutPageInput = {
    elementName?: StringFieldUpdateOperationsInput | string
    selector?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutCreatedPageElementsNestedInput
  }

  export type PageElementUncheckedUpdateWithoutPageInput = {
    id?: IntFieldUpdateOperationsInput | number
    elementName?: StringFieldUpdateOperationsInput | string
    selector?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageElementUncheckedUpdateManyWithoutPageInput = {
    id?: IntFieldUpdateOperationsInput | number
    elementName?: StringFieldUpdateOperationsInput | string
    selector?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}